"FrontEN","BackEN","FrontES","BackES","Tags","Category","Page"
"What is the intent of the Composite pattern?","Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.","¿Cuál es la intención del patrón Composite?","Componer objetos en estructuras de árbol para representar jerarquías parte-todo. Composite permite a los clientes tratar objetos individuales y composiciones de objetos de manera uniforme.","intent composite structural","Structural","43"
"When would you use the Composite pattern?","• You want to represent part-whole hierarchies of objects
• You want clients to be able to ignore the difference between compositions of objects and individual objects
• You need to treat single elements and groups of elements uniformly","¿Cuándo usarías el patrón Composite?","• Quieres representar jerarquías parte-todo de objetos
• Quieres que los clientes puedan ignorar la diferencia entre composiciones de objetos y objetos individuales
• Necesitas tratar elementos individuales y grupos de elementos de manera uniforme","use-case composite structural","Structural","43"
"What are the key participants in the Composite pattern?","• Glyph: Abstract class for all objects in document structure
• Character/Rectangle: Leaf primitive elements
• Row/Column: Composite structural elements
• Composition: Special composite using formatting algorithm","¿Cuáles son los participantes clave en el patrón Composite?","• Glyph: Clase abstracta para todos los objetos en la estructura del documento
• Character/Rectangle: Elementos primitivos hoja
• Row/Column: Elementos estructurales compuestos
• Composition: Compuesto especial que usa algoritmo de formato","key-concepts composite structural","Structural","46"
"What are the benefits and drawbacks of the Composite pattern?","Benefits:
• Makes client code simpler by treating primitives and composites uniformly
• Makes it easy to add new kinds of components
• Provides flexibility at the finest levels of design

Drawbacks:
• Can make the design overly general
• Can make it harder to restrict components of a composite","¿Cuáles son los beneficios y desventajas del patrón Composite?","Beneficios:
• Hace el código cliente más simple al tratar primitivas y compuestos de manera uniforme
• Facilita agregar nuevos tipos de componentes
• Proporciona flexibilidad en los niveles más finos del diseño

Desventajas:
• Puede hacer el diseño excesivamente general
• Puede dificultar la restricción de componentes de un compuesto","benefits-drawbacks composite structural","Structural","47"
"What patterns are related to the Composite pattern?","• Iterator: Often used together to traverse composite structures
• Visitor: Can be used to apply operations over composite structures
• Decorator: Similar structure but different intent - Decorator adds responsibilities","¿Qué patrones están relacionados con el patrón Composite?","• Iterator: A menudo se usa junto con Composite para recorrer estructuras compuestas
• Visitor: Se puede usar para aplicar operaciones sobre estructuras compuestas
• Decorator: Estructura similar pero intención diferente - Decorator añade responsabilidades","related-patterns composite structural","Structural","47"
"What are key implementation considerations for the Composite pattern?","• Use inheritance to define common interface for all components
• Components should implement operations like Draw that work recursively
• Parent references let you traverse structure up and down
• Child management operations (Insert, Remove, Child) should be in common interface","¿Cuáles son las consideraciones de implementación clave para el patrón Composite?","• Usar herencia para definir interfaz común para todos los componentes
• Los componentes deben implementar operaciones como Draw que funcionen recursivamente
• Las referencias padre permiten recorrer la estructura hacia arriba y hacia abajo
• Las operaciones de gestión de hijos (Insert, Remove, Child) deben estar en la interfaz común","implementation composite structural","Structural","47"
"What are real-world examples of the Composite pattern?","• Document editors with text and graphics
• UI frameworks with nested components
• File system directories and files","¿Cuáles son ejemplos del mundo real del patrón Composite?","• Editores de documentos con texto y gráficos
• Frameworks de UI con componentes anidados
• Directorios y archivos del sistema de archivos","real-world composite structural","Structural","47"
"What is the intent of the Strategy pattern?","Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.","¿Cuál es la intención del patrón Strategy?","Definir una familia de algoritmos, encapsular cada uno y hacerlos intercambiables. Strategy permite que el algoritmo varíe independientemente de los clientes que lo usan.","intent strategy behavioral","Behavioral","48"
"When would you use the Strategy pattern?","• Many related classes differ only in their behavior
• You need different variants of an algorithm
• An algorithm uses data that clients shouldn't know about
• A class defines many behaviors that appear as multiple conditional statements","¿Cuándo usarías el patrón Strategy?","• Muchas clases relacionadas difieren solo en su comportamiento
• Necesitas diferentes variantes de un algoritmo
• Un algoritmo usa datos que los clientes no deberían conocer
• Una clase define muchos comportamientos que aparecen como múltiples declaraciones condicionales","use-case strategy behavioral","Behavioral","48"
"What are the key participants in the Strategy pattern?","• Strategy (Compositor): Declares interface common to all supported algorithms
• ConcreteStrategy (SimpleCompositor, TeXCompositor): Implements the algorithm using the Strategy interface
• Context (Composition): Maintains reference to a Strategy object and may define interface for Strategy to access its data","¿Cuáles son los participantes clave en el patrón Strategy?","• Strategy (Compositor): Declara la interfaz común a todos los algoritmos soportados
• ConcreteStrategy (SimpleCompositor, TeXCompositor): Implementa el algoritmo usando la interfaz Strategy
• Context (Composition): Mantiene una referencia a un objeto Strategy y puede definir una interfaz para que Strategy acceda a sus datos","key-concepts strategy behavioral","Behavioral","49"
"What are the benefits and drawbacks of the Strategy pattern?","Benefits:
• Families of related algorithms can be defined
• Alternative to subclassing for providing different behaviors
• Eliminates conditional statements
• Provides different implementations of same behavior

Drawbacks:
• Clients must be aware of different Strategies
• Communication overhead between Strategy and Context
• Increased number of objects","¿Cuáles son los beneficios y desventajas del patrón Strategy?","Beneficios:
• Se pueden definir familias de algoritmos relacionados
• Alternativa a la subclasificación para proporcionar diferentes comportamientos
• Elimina declaraciones condicionales
• Proporciona diferentes implementaciones del mismo comportamiento

Desventajas:
• Los clientes deben conocer las diferentes Strategies
• Sobrecarga de comunicación entre Strategy y Context
• Mayor número de objetos","benefits-drawbacks strategy behavioral","Behavioral","50"
"What patterns are related to the Strategy pattern?","• State: Similar structure but Strategy is about algorithms while State is about states
• Flyweight: Strategy objects often make good flyweights","¿Qué patrones están relacionados con el patrón Strategy?","• State: Estructura similar pero Strategy trata sobre algoritmos mientras que State trata sobre estados
• Flyweight: Los objetos Strategy a menudo son buenos flyweights","related-patterns strategy behavioral","Behavioral","50"
"What are key implementation considerations for the Strategy pattern?","• Define interfaces for Strategy and Context that are general enough to support range of algorithms
• Strategy interface should give ConcreteStrategies access to data they need from Context
• Make Strategy objects good Flyweights if they have no state","¿Cuáles son las consideraciones de implementación clave para el patrón Strategy?","• Definir interfaces para Strategy y Context que sean lo suficientemente generales para soportar un rango de algoritmos
• La interfaz Strategy debe dar a las ConcreteStrategies acceso a los datos que necesitan del Context
• Hacer que los objetos Strategy sean buenos Flyweights si no tienen estado","implementation strategy behavioral","Behavioral","50"
"What are real-world examples of the Strategy pattern?","• Text formatting algorithms (TeX, simple line breaking)
• Sorting algorithms that can be swapped
• Compression strategies
• Validation strategies","¿Cuáles son ejemplos del mundo real del patrón Strategy?","• Algoritmos de formato de texto (TeX, salto de línea simple)
• Algoritmos de ordenamiento que pueden intercambiarse
• Estrategias de compresión
• Estrategias de validación","real-world strategy behavioral","Behavioral","50"
"What is the intent of the Decorator pattern?","Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.","¿Cuál es la intención del patrón Decorator?","Adjuntar responsabilidades adicionales a un objeto dinámicamente. Los Decorators proporcionan una alternativa flexible a la subclasificación para extender funcionalidad.","intent decorator structural","Structural","51"
"When would you use the Decorator pattern?","• Add responsibilities to individual objects dynamically and transparently
• Responsibilities can be withdrawn
• Extension by subclassing is impractical due to explosion of subclasses
• You want to add functionality without affecting other objects","¿Cuándo usarías el patrón Decorator?","• Añadir responsabilidades a objetos individuales de forma dinámica y transparente
• Las responsabilidades pueden retirarse
• La extensión por subclasificación es impráctica debido a la explosión de subclases
• Quieres añadir funcionalidad sin afectar a otros objetos","use-case decorator structural","Structural","51"
"What are the key participants in the Decorator pattern?","• Component (Glyph): Defines interface for objects that can have responsibilities added
• ConcreteComponent (Composition): Defines object to which additional responsibilities can be attached
• Decorator (MonoGlyph): Maintains reference to Component object and defines interface that conforms to Component
• ConcreteDecorator (Border, Scroller): Adds responsibilities to the component","¿Cuáles son los participantes clave en el patrón Decorator?","• Component (Glyph): Define la interfaz para objetos que pueden tener responsabilidades añadidas
• ConcreteComponent (Composition): Define el objeto al que se pueden adjuntar responsabilidades adicionales
• Decorator (MonoGlyph): Mantiene referencia a objeto Component y define interfaz que se ajusta a Component
• ConcreteDecorator (Border, Scroller): Añade responsabilidades al componente","key-concepts decorator structural","Structural","52"
"What are the benefits and drawbacks of the Decorator pattern?","Benefits:
• More flexibility than static inheritance
• Avoids feature-laden classes high up in the hierarchy
• Responsibilities can be added and removed at run-time
• Functionality can be composed from simple pieces

Drawbacks:
• Decorator and its component aren't identical
• Lots of little objects that differ only in how they're interconnected
• Can complicate debugging","¿Cuáles son los beneficios y desventajas del patrón Decorator?","Beneficios:
• Más flexibilidad que la herencia estática
• Evita clases con muchas características en la parte superior de la jerarquía
• Las responsabilidades pueden añadirse y eliminarse en tiempo de ejecución
• Se pueden combinar múltiples decoradores

Desventajas:
• Muchos objetos pequeños en el sistema
• Puede ser difícil distinguir los decoradores entre sí
• Dificulta la configuración inicial","benefits-drawbacks decorator structural","Structural","53"
"What patterns are related to the Decorator pattern?","• Adapter: Adapter changes interface, Decorator enhances responsibilities
• Composite: Decorator can be viewed as degenerate composite with one component
• Strategy: Decorator changes skin of object, Strategy changes guts","¿Qué patrones están relacionados con el patrón Decorator?","• Adapter: Cambia la interfaz de un objeto; Decorator mejora las responsabilidades
• Composite: Estructura similar pero intención diferente - Composite representa jerarquías parte-todo
• Strategy: Cambia el interior de un objeto; Decorator cambia el exterior","related-patterns decorator structural","Structural","53"
"What are key implementation considerations for the Decorator pattern?","• Decorator must have same interface as component it decorates
• Keep Component classes lightweight - focus on interface not storage
• Use transparent enclosure - decorator forwards all requests by default
• Decorator can add operations before/after forwarding","¿Cuáles son las consideraciones de implementación clave para el patrón Decorator?","• Mantener interfaz del componente simple para permitir decoración flexible
• Omitir la clase Decorator abstracta si solo necesitas un decorador
• Mantener ligeras las clases Component para evitar sobrecarga por decoración
• Los decoradores deben actuar como proxies transparentes","implementation decorator structural","Structural","53"
"What are real-world examples of the Decorator pattern?","• Scrollable and bordered windows
• Stream decorators (BufferedInputStream, etc.)
• UI component embellishments","¿Cuáles son ejemplos del mundo real del patrón Decorator?","• Añadir bordes y barras de desplazamiento a componentes de UI
• Flujos de E/S con características como buffering, compresión, encriptación
• Embellecimientos de texto con diferentes estilos de formato","real-world decorator structural","Structural","53"
"What is the intent of the Abstract Factory pattern?","Provide an interface for creating families of related or dependent objects without specifying their concrete classes.","¿Cuál es la intención del patrón Abstract Factory?","Proporcionar una interfaz para crear familias de objetos relacionados o dependientes sin especificar sus clases concretas.","intent abstract-factory creational","Creational","54"
"When would you use the Abstract Factory pattern?","• System should be independent of how its products are created
• System should be configured with one of multiple families of products
• Family of related product objects is designed to be used together
• You want to provide class library of products and reveal only interfaces","¿Cuándo usarías el patrón Abstract Factory?","• Un sistema debe ser independiente de cómo se crean, componen y representan sus productos
• Un sistema debe configurarse con una de múltiples familias de productos
• Una familia de objetos de producto relacionados está diseñada para usarse juntos
• Quieres proporcionar una biblioteca de productos y solo revelar sus interfaces, no sus implementaciones","use-case abstract-factory creational","Creational","54"
"What are the key participants in the Abstract Factory pattern?","• AbstractFactory (GUIFactory): Declares interface for operations that create abstract product objects
• ConcreteFactory (MotifFactory, PMFactory): Implements operations to create concrete product objects
• AbstractProduct (ScrollBar, Button): Declares interface for a type of product object
• ConcreteProduct (MotifScrollBar, PMButton): Defines product object to be created by corresponding concrete factory
• Client: Uses only interfaces declared by AbstractFactory and AbstractProduct","¿Cuáles son los participantes clave en el patrón Abstract Factory?","• AbstractFactory (WidgetFactory): Declara interfaz para operaciones que crean objetos producto abstractos
• ConcreteFactory (MotifWidgetFactory, PMWidgetFactory): Implementa operaciones para crear objetos producto concretos
• AbstractProduct (ScrollBar, Window): Declara interfaz para un tipo de objeto producto
• ConcreteProduct (MotifScrollBar, PMWindow): Define un objeto producto para ser creado por la fábrica correspondiente
• Client: Usa solo interfaces declaradas por AbstractFactory y AbstractProduct","key-concepts abstract-factory creational","Creational","55"
"What are the benefits and drawbacks of the Abstract Factory pattern?","Benefits:
• Isolates concrete classes from clients
• Makes exchanging product families easy
• Promotes consistency among products
• Supports different look-and-feel standards

Drawbacks:
• Supporting new kinds of products is difficult
• Abstract factory interface must be extended to create new products","¿Cuáles son los beneficios y desventajas del patrón Abstract Factory?","Beneficios:
• Aísla clases concretas de los clientes
• Facilita el intercambio de familias de productos
• Promueve la consistencia entre productos
• Soporta configuración flexible

Desventajas:
• Difícil de extender para soportar nuevos tipos de productos
• Puede llevar a muchas clases pequeñas","benefits-drawbacks abstract-factory creational","Creational","58"
"What patterns are related to the Abstract Factory pattern?","• Factory Method: Abstract Factory classes often implemented with Factory Methods
• Prototype: Concrete factory can be implemented using Prototype
• Singleton: Concrete factory is often a Singleton","¿Qué patrones están relacionados con el patrón Abstract Factory?","• Factory Method: A menudo implementado usando métodos factory
• Singleton: Las fábricas concretas a menudo son singletons
• Prototype: Las fábricas pueden usar Prototype para clonar productos predefinidos","related-patterns abstract-factory creational","Creational","58"
"What are key implementation considerations for the Abstract Factory pattern?","• Factories are often singletons
• Creating products - usually use Factory Method
• Can use Prototype to eliminate need for new ConcreteFactory class
• Define extensible factories using parameters to specify products","¿Cuáles son las consideraciones de implementación clave para el patrón Abstract Factory?","• Las fábricas suelen implementarse como singletons
• Crear productos usando Factory Method o Prototype
• Definir fábrica extensible añadiendo parámetro a operaciones de creación
• AbstractFactory solo declara interfaz para crear productos; responsabilidad del ConcreteProduct crearlos","implementation abstract-factory creational","Creational","58"
"What are real-world examples of the Abstract Factory pattern?","• UI toolkit widgets for different look-and-feel standards (Motif, Windows, Mac)
• Database access layers supporting multiple database vendors
• Cross-platform UI frameworks","¿Cuáles son ejemplos del mundo real del patrón Abstract Factory?","• Widgets de toolkit de UI para diferentes estándares de apariencia (Motif, Windows, Mac)
• Capas de acceso a base de datos que soportan múltiples proveedores de base de datos
• Frameworks de UI multiplataforma","real-world abstract-factory creational","Creational","58"
"What is the intent of the Bridge pattern?","Decouple an abstraction from its implementation so that the two can vary independently.","¿Cuál es la intención del patrón Bridge?","Desacoplar una abstracción de su implementación para que ambas puedan variar independientemente.","intent bridge structural","Structural","58"
"When would you use the Bridge pattern?","• Want to avoid permanent binding between abstraction and implementation
• Both abstractions and implementations should be extensible by subclassing
• Changes in implementation should not impact clients
• Want to hide implementation from clients
• Want to share implementation among multiple objects","¿Cuándo usarías el patrón Bridge?","• Quieres evitar un enlace permanente entre abstracción e implementación
• Tanto las abstracciones como las implementaciones deben ser extensibles mediante subclasificación
• Los cambios en la implementación no deben impactar a los clientes
• Quieres ocultar la implementación de los clientes
• Quieres compartir implementación entre múltiples objetos","use-case bridge structural","Structural","59"
"What are the key participants in the Bridge pattern?","• Abstraction (Window): Defines abstraction's interface and maintains reference to Implementor
• RefinedAbstraction (ApplicationWindow, IconWindow): Extends interface defined by Abstraction
• Implementor (WindowImp): Defines interface for implementation classes
• ConcreteImplementor (XWindowImp, PMWindowImp): Implements Implementor interface and defines concrete implementation","¿Cuáles son los participantes clave en el patrón Bridge?","• Abstraction (Window): Define la interfaz de la abstracción y mantiene referencia al Implementor
• RefinedAbstraction (ApplicationWindow, IconWindow): Extiende la interfaz definida por Abstraction
• Implementor (WindowImp): Define la interfaz para las clases de implementación
• ConcreteImplementor (XWindowImp, PMWindowImp): Implementa la interfaz Implementor y define la implementación concreta","key-concepts bridge structural","Structural","61"
"What are the benefits and drawbacks of the Bridge pattern?","Benefits:
• Decouples interface and implementation
• Improves extensibility - abstraction and implementation hierarchies can vary independently
• Hides implementation details from clients
• Allows run-time binding of implementation

Drawbacks:
• Increased complexity due to additional indirection","¿Cuáles son los beneficios y desventajas del patrón Bridge?","Beneficios:
• Desacopla interfaz e implementación
• Mejora la extensibilidad - las jerarquías de abstracción e implementación pueden variar independientemente
• Oculta los detalles de implementación de los clientes
• Permite enlace de implementación en tiempo de ejecución

Desventajas:
• Mayor complejidad debido a la indirección adicional","benefits-drawbacks bridge structural","Structural","64"
"What patterns are related to the Bridge pattern?","• Abstract Factory: Can create and configure particular Bridge
• Adapter: Makes unrelated classes work together; Bridge designed up-front","¿Qué patrones están relacionados con el patrón Bridge?","• Abstract Factory: Puede crear y configurar un Bridge particular
• Adapter: Hace que clases no relacionadas funcionen juntas; Bridge se diseña desde el principio","related-patterns bridge structural","Structural","64"
"What are key implementation considerations for the Bridge pattern?","• Create Implementor when Abstraction is created, or choose from existing implementations
• Share Implementors among multiple Abstractions
• Use Abstract Factory to create and configure particular Bridge
• Window's interface caters to application programmers while WindowImp caters to window systems","¿Cuáles son las consideraciones de implementación clave para el patrón Bridge?","• Crear Implementor cuando se crea Abstraction, o elegir de implementaciones existentes
• Compartir Implementors entre múltiples Abstractions
• Usar Abstract Factory para crear y configurar un Bridge particular
• La interfaz de Window atiende a programadores de aplicaciones mientras que WindowImp atiende a sistemas de ventanas","implementation bridge structural","Structural","63"
"What are real-world examples of the Bridge pattern?","• Window abstractions with platform-specific implementations (X11, Windows, Mac)
• Device-independent graphics libraries
• Persistent object stores with different back-ends","¿Cuáles son ejemplos del mundo real del patrón Bridge?","• Abstracciones de ventanas con implementaciones específicas de plataforma (X11, Windows, Mac)
• Bibliotecas gráficas independientes de dispositivo
• Almacenes de objetos persistentes con diferentes backends","real-world bridge structural","Structural","64"
"Which patterns use the concept 'Encapsulation of Variation'?","Identify the aspects that vary and separate them from what stays the same.

Patterns: Strategy, Abstract Factory, Bridge, Decorator

Strategy encapsulates formatting algorithms, Abstract Factory encapsulates widget families, Bridge encapsulates window implementations, and Decorator encapsulates embellishments.","¿Qué patrones usan el concepto 'Encapsulación de la Variación'?","Identificar los aspectos que varían y separarlos de lo que permanece igual.

Patrones: Strategy, Abstract Factory, Bridge, Decorator

Strategy encapsula algoritmos de formato, Abstract Factory encapsula familias de widgets, Bridge encapsula implementaciones de ventanas y Decorator encapsula embellecimientos.","cross-cutting encapsulation-of-variation","Cross-Cutting","42"
"Which patterns use the concept 'Composition over Inheritance'?","Favor object composition over class inheritance to achieve flexibility. New functionality is added by composing objects in new ways rather than defining new subclasses. Reduces class explosion and enables run-time configuration.

Patterns: Composite, Decorator, Strategy, Bridge","¿Qué patrones usan el concepto 'Composición sobre Herencia'?","Favorecer la composición de objetos sobre la herencia de clases para lograr flexibilidad. La nueva funcionalidad se añade componiendo objetos de nuevas formas en lugar de definir nuevas subclases. Reduce la explosión de clases y permite configuración en tiempo de ejecución.

Patrones: Composite, Decorator, Strategy, Bridge","cross-cutting composition-over-inheritance","Cross-Cutting","42"
"Which patterns use the concept 'Program to Interface, not Implementation'?","Clients should remain unaware of specific types and classes of objects they use. Declare variables to be instances of abstract classes and commit only to interfaces defined by abstract classes.

Patterns: Abstract Factory, Strategy, Bridge, Composite","¿Qué patrones usan el concepto 'Programar a Interfaz, no a Implementación'?","Los clientes deben permanecer sin conocimiento de los tipos y clases específicos de objetos que usan. Declarar variables para que sean instancias de clases abstractas y comprometerse solo a interfaces definidas por clases abstractas.

Patrones: Abstract Factory, Strategy, Bridge, Composite","cross-cutting program-to-interface","Cross-Cutting","42"
"Which patterns use the concept 'Separation of Concerns'?","Separate different aspects of a design into independent parts.

Patterns: Bridge, Strategy, Abstract Factory

Bridge separates window abstraction from implementation, Strategy separates formatting from document structure, Abstract Factory separates product creation from use.","¿Qué patrones usan el concepto 'Separación de Preocupaciones'?","Separar diferentes aspectos de un diseño en partes independientes.

Patrones: Bridge, Strategy, Abstract Factory

Bridge separa la abstracción de ventana de la implementación, Strategy separa el formato de la estructura del documento, Abstract Factory separa la creación de productos del uso.","cross-cutting separation-of-concerns","Cross-Cutting","42"
"Which patterns use the concept 'Delegation'?","Make composition as powerful as inheritance by having receiving object delegate operations to its delegate.

Patterns: Decorator, Strategy, Bridge

Decorator delegates to component, Strategy context delegates to strategy object, Bridge abstraction delegates to implementor.","¿Qué patrones usan el concepto 'Delegación'?","Hacer que la composición sea tan poderosa como la herencia haciendo que el objeto receptor delegue operaciones a su delegado.

Patrones: Decorator, Strategy, Bridge

Decorator delega al componente, el contexto de Strategy delega al objeto strategy, la abstracción de Bridge delega al implementor.","cross-cutting delegation","Cross-Cutting","42"
"Compare Composite vs Decorator","Similarities:
• Both use recursive composition
• Similar structure with component references
• Both part of Structural patterns

Differences:
• Composite: Treats groups uniformly, can have multiple children, represents part-whole hierarchies
• Decorator: Adds responsibilities, single child (transparent enclosure), enhances behavior

When to use each:
• Composite: When you need hierarchical tree structures
• Decorator: When you need to add responsibilities dynamically","Comparar Composite vs Decorator","Similitudes:
• Ambos usan composición recursiva
• Estructura similar con referencias a componentes
• Ambos son patrones estructurales

Diferencias:
• Composite: Trata grupos uniformemente, puede tener múltiples hijos, representa jerarquías parte-todo
• Decorator: Añade responsabilidades, un solo hijo (envoltura transparente), mejora el comportamiento

Cuándo usar cada uno:
• Composite: Cuando necesitas estructuras jerárquicas de árbol
• Decorator: Cuando necesitas añadir responsabilidades dinámicamente","comparison composite decorator structural","Comparison","47"
"Compare Strategy vs State","Similarities:
• Similar structure with context and strategy/state object
• Both encapsulate behavior in separate objects
• Both allow behavior changes at runtime

Differences:
• Strategy: About interchangeable algorithms, client usually specifies which strategy
• State: About object's internal state, state transitions often automatic

When to use each:
• Strategy: When you have multiple algorithms for same task
• State: When object behavior depends on its state","Comparar Strategy vs State","Similitudes:
• Estructura similar con contexto y objeto strategy/state
• Ambos encapsulan comportamiento en objetos separados
• Ambos permiten cambios de comportamiento en tiempo de ejecución

Diferencias:
• Strategy: Sobre algoritmos intercambiables, el cliente usualmente especifica qué strategy
• State: Sobre el estado interno del objeto, las transiciones de estado a menudo son automáticas

Cuándo usar cada uno:
• Strategy: Cuando tienes múltiples algoritmos para la misma tarea
• State: Cuando el comportamiento del objeto depende de su estado","comparison strategy state behavioral","Comparison","50"
"Compare Abstract Factory vs Factory Method","Similarities:
• Both are Creational patterns
• Both defer object creation
• Both work with families of related objects

Differences:
• Abstract Factory: Creates families of related products through object composition
• Factory Method: Creates one product using inheritance/subclassing

When to use each:
• Abstract Factory: When you need to create families of related objects
• Factory Method: When you need to defer instantiation to subclasses","Comparar Abstract Factory vs Factory Method","Similitudes:
• Ambos son patrones creacionales
• Ambos difieren la creación de objetos
• Ambos trabajan con familias de objetos relacionados

Diferencias:
• Abstract Factory: Crea familias de productos relacionados a través de composición de objetos
• Factory Method: Crea un producto usando herencia/subclasificación

Cuándo usar cada uno:
• Abstract Factory: Cuando necesitas crear familias de objetos relacionados
• Factory Method: Cuando necesitas diferir la instanciación a subclases","comparison abstract-factory factory-method creational","Comparison","58"
"Compare Bridge vs Adapter","Similarities:
• Both separate interface from implementation
• Both use composition
• Both are Structural patterns

Differences:
• Bridge: Designed up-front to let abstractions and implementations vary independently
• Adapter: Makes unrelated classes work together after they're designed, changes interface

When to use each:
• Bridge: When designing new code to support multiple implementations
• Adapter: When integrating existing incompatible interfaces","Comparar Bridge vs Adapter","Similitudes:
• Ambos separan interfaz de implementación
• Ambos usan composición
• Ambos son patrones estructurales

Diferencias:
• Bridge: Diseñado desde el principio para permitir que abstracciones e implementaciones varíen independientemente
• Adapter: Hace que clases no relacionadas funcionen juntas después de que están diseñadas, cambia la interfaz

Cuándo usar cada uno:
• Bridge: Al diseñar código nuevo para soportar múltiples implementaciones
• Adapter: Al integrar interfaces incompatibles existentes","comparison bridge adapter structural","Comparison","64"
"What is the intent of the Command pattern?","Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.","¿Cuál es la intención del patrón Command?","Encapsular una solicitud como un objeto, permitiendo así parametrizar clientes con diferentes solicitudes, poner en cola o registrar solicitudes, y soportar operaciones que se puedan deshacer.","intent command behavioral","Behavioral","66"
"When would you use the Command pattern?","• Parameterize objects by an action to perform (callback-like mechanism)
• Specify, queue, and execute requests at different times
• Support undo/redo with Execute and Unexecute operations
• Support logging changes for crash recovery
• Structure a system around high-level operations built on primitive operations","¿Cuándo usarías el patrón Command?","• Parametrizar objetos por una acción a realizar (mecanismo similar a callback)
• Especificar, poner en cola y ejecutar solicitudes en diferentes momentos
• Soportar deshacer/rehacer con operaciones Execute y Unexecute
• Soportar registro de cambios para recuperación de fallos
• Estructurar un sistema alrededor de operaciones de alto nivel construidas sobre operaciones primitivas","use-case command behavioral","Behavioral","66"
"What are the key participants in the Command pattern?","• Command: Declares interface for executing an operation with Execute() method
• ConcreteCommand: Implements Execute by invoking operations on Receiver, stores state for undo
• Client: Creates ConcreteCommand object and sets its receiver
• Invoker: Asks the command to carry out the request by calling Execute
• Receiver: Knows how to perform the operations to carry out the request","¿Cuáles son los participantes clave en el patrón Command?","• Command: Declara interfaz para ejecutar una operación con método Execute()
• ConcreteCommand: Implementa Execute invocando operaciones en Receiver, almacena estado para deshacer
• Client: Crea objeto ConcreteCommand y establece su receptor
• Invoker: Pide al comando que ejecute la solicitud llamando a Execute
• Receiver: Sabe cómo realizar las operaciones para llevar a cabo la solicitud","key-concepts command behavioral","Behavioral","66"
"What are the benefits and drawbacks of the Command pattern?","Benefits:
• Decouples object that invokes operation from one that knows how to perform it
• Commands are first-class objects that can be manipulated and extended
• Can assemble commands into composite commands using Composite pattern
• Easy to add new Commands without changing existing classes

Drawbacks:
• Can result in many small command classes
• Complexity increases with command history and undo/redo mechanisms","¿Cuáles son los beneficios y desventajas del patrón Command?","Beneficios:
• Desacopla el objeto que invoca la operación de aquel que sabe cómo realizarla
• Los comandos son objetos de primera clase que pueden ser manipulados y extendidos
• Puede ensamblar comandos en comandos compuestos usando el patrón Composite
• Fácil añadir nuevos Commands sin cambiar clases existentes

Desventajas:
• Puede resultar en muchas clases de comando pequeñas
• La complejidad aumenta con el historial de comandos y mecanismos de deshacer/rehacer","benefits-drawbacks command behavioral","Behavioral","66"
"What patterns are related to the Command pattern?","• Composite: Can be used to implement MacroCommands
• Memento: Can keep state for undoing effects
• Prototype: Commands that must be copied before being placed on history list act as prototypes","¿Qué patrones están relacionados con el patrón Command?","• Composite: Puede usarse para implementar MacroCommands
• Memento: Puede mantener el estado para deshacer efectos
• Prototype: Los comandos que deben ser copiados antes de colocarse en la lista de historial actúan como prototipos","related-patterns command behavioral","Behavioral","66"
"What are key implementation considerations for the Command pattern?","• Add Unexecute operation to Command interface for undo/redo support
• Add Reversible operation to determine if command is undoable at runtime
• Maintain command history as list of executed/unexecuted commands
• Track present position in history for undo (move left) and redo (move right)
• Commands may delegate all, part, or none of implementation to other objects","¿Cuáles son las consideraciones clave de implementación para el patrón Command?","• Añadir operación Unexecute a la interfaz Command para soporte de deshacer/rehacer
• Añadir operación Reversible para determinar si el comando es deshacible en tiempo de ejecución
• Mantener historial de comandos como lista de comandos ejecutados/no ejecutados
• Rastrear posición actual en el historial para deshacer (mover a la izquierda) y rehacer (mover a la derecha)
• Los comandos pueden delegar toda, parte o ninguna implementación a otros objetos","implementation command behavioral","Behavioral","66"
"What are real-world examples of the Command pattern?","• Menu items and buttons in GUI applications
• Undo/redo functionality in document editors
• Transaction systems and logging mechanisms
• Request queuing and scheduling systems","¿Cuáles son ejemplos del mundo real del patrón Command?","• Elementos de menú y botones en aplicaciones GUI
• Funcionalidad de deshacer/rehacer en editores de documentos
• Sistemas de transacciones y mecanismos de registro
• Sistemas de cola de solicitudes y planificación","real-world command behavioral","Behavioral","66"
"What are common misuses of the Command pattern?","• Creating too many small command classes without justification
• Implementing complex undo/redo without proper command history management
• Not properly managing state in commands, making undo operations unreliable
• Overcomplicating simple operations that don't need the full command infrastructure","¿Cuáles son los usos incorrectos comunes del patrón Command?","• Crear demasiadas clases de comando pequeñas sin justificación
• Implementar deshacer/rehacer complejo sin gestión adecuada del historial de comandos
• No gestionar correctamente el estado en los comandos, haciendo que las operaciones de deshacer no sean confiables
• Sobrecomplicar operaciones simples que no necesitan toda la infraestructura de comandos","anti-pattern command behavioral","Behavioral","66"
"What is the intent of the Iterator pattern?","Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.","¿Cuál es la intención del patrón Iterator?","Proporcionar una forma de acceder a los elementos de un objeto agregado secuencialmente sin exponer su representación subyacente.","intent iterator behavioral","Behavioral","70"
"When would you use the Iterator pattern?","• Access aggregate object's contents without exposing internal representation
• Support multiple traversals of aggregate objects
• Provide uniform interface for traversing different aggregate structures","¿Cuándo usarías el patrón Iterator?","• Acceder al contenido de un objeto agregado sin exponer su representación interna
• Soportar múltiples recorridos de objetos agregados
• Proporcionar una interfaz uniforme para recorrer diferentes estructuras agregadas","use-case iterator behavioral","Behavioral","70"
"What are the key participants in the Iterator pattern?","• Iterator: Defines interface for accessing and traversing elements with First(), Next(), IsDone(), CurrentItem()
• ConcreteIterator: Implements Iterator interface and keeps track of current position in traversal
• Aggregate: Defines interface for creating Iterator object via CreateIterator()
• ConcreteAggregate: Implements CreateIterator to return instance of proper ConcreteIterator based on internal structure","¿Cuáles son los participantes clave en el patrón Iterator?","• Iterator: Define interfaz para acceder y recorrer elementos con First(), Next(), IsDone(), CurrentItem()
• ConcreteIterator: Implementa interfaz Iterator y mantiene seguimiento de la posición actual en el recorrido
• Aggregate: Define interfaz para crear objeto Iterator mediante CreateIterator()
• ConcreteAggregate: Implementa CreateIterator para devolver instancia del ConcreteIterator apropiado basado en estructura interna","key-concepts iterator behavioral","Behavioral","70"
"What are the benefits and drawbacks of the Iterator pattern?","Benefits:
• Supports variations in traversal of aggregate
• Iterators simplify Aggregate interface
• More than one traversal can be active on aggregate simultaneously
• Hides internal structure of aggregate from clients

Drawbacks:
• Additional complexity from iterator class hierarchy
• Cursor handling can be tricky with concurrent modifications","¿Cuáles son los beneficios y desventajas del patrón Iterator?","Beneficios:
• Soporta variaciones en el recorrido del agregado
• Los iteradores simplifican la interfaz del Aggregate
• Puede haber más de un recorrido activo en el agregado simultáneamente
• Oculta la estructura interna del agregado de los clientes

Desventajas:
• Complejidad adicional por la jerarquía de clases de iteradores
• El manejo de cursores puede ser complicado con modificaciones concurrentes","benefits-drawbacks iterator behavioral","Behavioral","70"
"What patterns are related to the Iterator pattern?","• Composite: Iterators often used to traverse Composite structures
• Factory Method: Polymorphic iterators rely on factory methods to instantiate appropriate iterator
• Memento: Can be used with Iterator to capture state of iteration","¿Qué patrones están relacionados con el patrón Iterator?","• Composite: Los iteradores a menudo se usan para recorrer estructuras Composite
• Factory Method: Los iteradores polimórficos dependen de métodos de fábrica para instanciar el iterador apropiado
• Memento: Puede usarse con Iterator para capturar el estado de la iteración","related-patterns iterator behavioral","Behavioral","70"
"What are key implementation considerations for the Iterator pattern?","• CreateIterator returns appropriate iterator type based on aggregate's internal structure
• NullIterator for leaf elements (IsDone always returns true)
• ListIterator/ArrayIterator for containers storing children in lists/arrays
• PreorderIterator uses stack to maintain iterator state during traversal
• Iterators can be parameterized by type in C++ using templates for reuse","¿Cuáles son las consideraciones clave de implementación para el patrón Iterator?","• CreateIterator devuelve el tipo de iterador apropiado basado en la estructura interna del agregado
• NullIterator para elementos hoja (IsDone siempre devuelve true)
• ListIterator/ArrayIterator para contenedores que almacenan hijos en listas/arrays
• PreorderIterator usa pila para mantener el estado del iterador durante el recorrido
• Los iteradores pueden ser parametrizados por tipo en C++ usando plantillas para reutilización","implementation iterator behavioral","Behavioral","70"
"Iterator<Glyph*>* i = g->CreateIterator();

for (i->First(); !i->IsDone(); i->Next()) {
  Glyph* child = i->CurrentItem();
  // do something with current child
}","Pattern: Iterator
Key elements: Basic iteration pattern using Iterator interface with First(), IsDone(), Next(), and CurrentItem() operations to traverse aggregate without exposing internal structure","Iterator<Glyph*>* i = g->CreateIterator();

for (i->First(); !i->IsDone(); i->Next()) {
  Glyph* child = i->CurrentItem();
  // hacer algo con el hijo actual
}","Patrón: Iterator
Elementos clave: Patrón de iteración básico usando interfaz Iterator con operaciones First(), IsDone(), Next() y CurrentItem() para recorrer agregado sin exponer estructura interna","code-example iterator behavioral cpp","Behavioral","70"
"What are real-world examples of the Iterator pattern?","• Traversing UI component hierarchies
• Iterating over document structures
• Collection iteration in standard libraries (STL, Java Collections)
• Tree and graph traversal algorithms","¿Cuál es la intención del patrón Visitor?","Representar una operación a realizar sobre los elementos de una estructura de objetos. Visitor permite definir una nueva operación sin cambiar las clases de los elementos sobre los que opera.","real-world iterator behavioral","Behavioral","70"
"What are common misuses of the Iterator pattern?","• Not handling concurrent modifications to the collection during iteration
• Creating overly complex iterator hierarchies when simple iteration suffices
• Exposing internal collection structure through iterator implementation
• Failing to provide consistent iteration semantics across different aggregate types","¿Cuándo usarías el patrón Visitor?","• Una estructura de objetos contiene muchas clases con diferentes interfaces y deseas realizar operaciones que dependen de sus clases concretas
• Muchas operaciones distintas y no relacionadas deben realizarse sobre objetos en una estructura y quieres evitar contaminar sus clases
• Las clases que definen la estructura de objetos raramente cambian, pero frecuentemente quieres definir nuevas operaciones sobre la estructura","anti-pattern iterator behavioral","Behavioral","70"
"What is the intent of the Visitor pattern?","Represent an operation to be performed on elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.","¿Cuáles son los participantes clave en el patrón Visitor?","• Visitor: Declara operación Visit para cada clase de ConcreteElement en la estructura de objetos
• ConcreteVisitor: Implementa cada operación declarada por Visitor, proporciona el contexto y almacena estado local
• Element: Define operación Accept que toma un visitor como argumento
• ConcreteElement: Implementa operación Accept que invoca operación Visit del visitor correspondiente a su clase
• ObjectStructure: Puede enumerar sus elementos, puede proporcionar interfaz de alto nivel para permitir al visitor visitar sus elementos","intent visitor behavioral","Behavioral","75"
"When would you use the Visitor pattern?","• Object structure contains many classes with differing interfaces, and you want to perform operations that depend on concrete classes
• Many distinct and unrelated operations need to be performed on objects in structure
• Classes defining object structure rarely change, but you want to define new operations
• Algorithm needs to access objects without exposing internal structure","¿Cuáles son los beneficios y desventajas del patrón Visitor?","Beneficios:
• Facilita añadir nuevas operaciones - simplemente añade un nuevo visitor
• Un visitor reúne operaciones relacionadas y separa las no relacionadas
• Visitor puede acumular estado mientras recorre la estructura
• Permite romper encapsulación para acceder al estado interno de elementos

Desventajas:
• Dificulta añadir nuevas clases ConcreteElement - requiere cambiar interfaz Visitor y todos sus visitantes concretos
• Puede romper encapsulación de elementos
• Visitor puede necesitar atravesar estructuras complejas, aumentando el acoplamiento","use-case visitor behavioral","Behavioral","75"
"What are the key participants in the Visitor pattern?","• Visitor: Declares Visit operation for each ConcreteElement class
• ConcreteVisitor: Implements each Visit operation to perform algorithm fragment for corresponding element class
• Element: Defines Accept operation that takes visitor as argument
• ConcreteElement: Implements Accept to call appropriate visitor's Visit method for its class
• ObjectStructure: Can enumerate elements and provide interface for visitor to visit elements","¿Qué patrones están relacionados con el patrón Visitor?","• Composite: Los visitors pueden usarse para aplicar una operación sobre una estructura Composite
• Interpreter: Visitor puede aplicarse para realizar interpretación
• Iterator: Visitor puede usar Iterator para recorrer la estructura de objetos","key-concepts visitor behavioral","Behavioral","75"
"What are the benefits and drawbacks of the Visitor pattern?","Benefits:
• Makes adding new operations easy - just add new visitor
• Gathers related operations and separates unrelated ones
• Visitor can accumulate state as it traverses structure
• Can work across class hierarchies without common parent

Drawbacks:
• Adding new ConcreteElement classes is hard - requires updating all visitors
• Breaking encapsulation - visitor may need access to element's private state
• Dependency between visitor and elements increases coupling","¿Cuáles son las consideraciones clave de implementación para el patrón Visitor?","• Doble despacho: Element llama Accept con visitor, que llama de vuelta al método Visit específico del tipo del elemento
• Visitor puede ser responsable de recorrer la estructura o la estructura puede proporcionar un iterador
• Cada ConcreteElement llama a la operación Visit con su tipo (VisitCharacter, VisitRow, etc.)
• CheckMe puede devolver resultado booleano a través de estado del visitor
• Visitor acumula resultados en variables de instancia a medida que recorre
• Element::Accept puede implementarse simplemente como: void Element::Accept(Visitor& v) { v.VisitElement(this); }","benefits-drawbacks visitor behavioral","Behavioral","75"
"What patterns are related to the Visitor pattern?","• Composite: Visitors can be used to apply operation over Composite structure
• Interpreter: Visitor may be used to do interpretation","void Character::Accept(Visitor& v) {
  v.VisitCharacter(this);
}

void Rectangle::Accept(Visitor& v) {
  v.VisitRectangle(this);
}

void Row::Accept(Visitor& v) {
  v.VisitRow(this);
}","Patrón: Visitor
Elementos clave: Cada ConcreteElement implementa Accept() que llama a la operación Visit específica de su tipo, habilitando doble despacho donde la operación depende tanto del tipo de visitor como del tipo de elemento","related-patterns visitor behavioral","Behavioral","75"
"What are key implementation considerations for the Visitor pattern?","• Accept operation calls visitor's VisitConcreteElement(this) method
• Visitor can accumulate state (e.g., SpellingCheckingVisitor accumulates characters and checks words)
• Visitor interface has VisitX method for each element type X
• Element passes itself to visitor enabling double-dispatch mechanism","class SpellingCheckingVisitor : public Visitor {
public:
  SpellingCheckingVisitor();
  
  virtual void VisitCharacter(Character*);
  virtual void VisitRow(Row*);
  virtual void VisitImage(Image*);
  // ... otros elementos
  
  list<char*>& GetMisspellings();
private:
  char _currentWord[MAX_WORD_SIZE];
  list<char*> _misspellings;
};","Patrón: Visitor
Elementos clave: ConcreteVisitor implementa operaciones Visit para cada tipo de elemento, acumula resultados (palabras mal escritas) en estado, proporciona método para recuperar resultados después del recorrido","implementation visitor behavioral","Behavioral","75"
"void SpellingChecker::CheckCharacter(Character* c) {
  const char ch = c->GetCharCode();
  if (isalpha(ch)) {
    // append to _currentWord
  } else {
    if (IsMisspelled(_currentWord)) {
      _misspellings.Append(strdup(_currentWord));
    }
    _currentWord[0] = '\0';
  }
}","Pattern: Visitor
Key elements: Visitor accumulates state (_currentWord, _misspellings) and performs analysis on Character elements, demonstrating how visitors can maintain context across multiple element visits","void SpellingCheckingVisitor::VisitCharacter(Character* c) {
  const char ch = c->GetCharCode();
  
  if (isalpha(ch)) {
    // añadir a palabra actual
  } else {
    // encontrado no-letra, revisar palabra actual
    if (IsMisspelled(_currentWord)) {
      _misspellings.Append(strdup(_currentWord));
    }
    _currentWord[0] = '\0';
  }
}","Patrón: Visitor
Elementos clave: VisitCharacter acumula caracteres en palabra, verifica ortografía cuando encuentra límite de palabra, almacena errores ortográficos en lista, mantiene estado a través de múltiples visitas de elementos","code-example visitor behavioral cpp","Behavioral","75"
"What are real-world examples of the Visitor pattern?","• Spell checking and hyphenation in document editors
• Compiler AST traversal for type checking and code generation
• XML/HTML document processing and transformation
• Scene graph traversal in graphics applications","¿Cuáles son ejemplos del mundo real del patrón Visitor?","• Compiladores que recorren árboles de sintaxis abstracta (verificación de tipos, optimización, generación de código)
• Verificación ortográfica en editores de texto
• Operaciones de formato e impresión en estructuras de documentos
• Herramientas de análisis de código que realizan múltiples análisis sobre el mismo AST","real-world visitor behavioral","Behavioral","75"
"What are common misuses of the Visitor pattern?","• Using it when the element class hierarchy changes frequently
• Breaking encapsulation by giving visitors excessive access to element internals
• Creating visitors that are too tightly coupled to element implementation details
• Not considering simpler alternatives when only one or two operations are needed","¿Cuál es la intención del patrón Abstract Factory?","Proporcionar una interfaz para crear familias de objetos relacionados o dependientes sin especificar sus clases concretas.","anti-pattern visitor behavioral","Behavioral","75"
"What is the intent of the Abstract Factory pattern?","Provide an interface for creating families of related or dependent objects without specifying their concrete classes.","¿Cuándo usarías el patrón Abstract Factory?","• Un sistema debe ser independiente de cómo se crean, componen y representan sus productos
• Un sistema debe configurarse con una de múltiples familias de productos
• Una familia de objetos de producto relacionados está diseñada para usarse juntos, y necesitas hacer cumplir esta restricción
• Quieres proporcionar una biblioteca de clases de productos y solo quieres revelar sus interfaces, no sus implementaciones","intent abstract-factory creational","Creational","87"
"When would you use the Abstract Factory pattern?","• System should be independent of how its products are created, composed, and represented
• System should be configured with one of multiple families of products
• Family of related product objects is designed to be used together and you need to enforce this constraint
• You want to provide class library of products and reveal just their interfaces, not implementations","¿Cuáles son los participantes clave en el patrón Abstract Factory?","• AbstractFactory: Declara una interfaz para operaciones que crean objetos de producto abstractos
• ConcreteFactory: Implementa las operaciones para crear objetos de producto concretos
• AbstractProduct: Declara una interfaz para un tipo de objeto de producto
• ConcreteProduct: Define un objeto de producto a ser creado por la fábrica concreta correspondiente; implementa la interfaz AbstractProduct
• Client: Usa solo interfaces declaradas por clases AbstractFactory y AbstractProduct","use-case abstract-factory creational","Creational","87"
"What are the key participants in the Abstract Factory pattern?","• AbstractFactory: Declares interface for operations that create abstract product objects
• ConcreteFactory: Implements operations to create concrete product objects
• AbstractProduct: Declares interface for a type of product object
• ConcreteProduct: Defines product object to be created by corresponding concrete factory, implements AbstractProduct interface
• Client: Uses only interfaces declared by AbstractFactory and AbstractProduct classes","¿Cuáles son los beneficios y desventajas del patrón Abstract Factory?","Beneficios:
• Aísla clases concretas - los clientes manipulan instancias a través de sus interfaces abstractas
• Facilita el intercambio de familias de productos - la clase de una fábrica concreta aparece solo una vez en una aplicación
• Promueve consistencia entre productos - objetos de producto diseñados para trabajar juntos

Desventajas:
• Dificulta el soporte de nuevos tipos de productos - requiere extender la interfaz de fábrica, lo que implica cambiar AbstractFactory y todas sus subclases","key-concepts abstract-factory creational","Creational","87"
"What are the benefits and drawbacks of the Abstract Factory pattern?","Benefits:
• Isolates concrete classes from clients
• Makes exchanging product families easy
• Promotes consistency among products
• Supports different look-and-feel standards

Drawbacks:
• Supporting new kinds of products is difficult
• Abstract factory interface must be extended to create new products, requiring changes to AbstractFactory and all subclasses","¿Qué patrones están relacionados con el patrón Abstract Factory?","• Factory Method: AbstractFactory a menudo se implementa con factory methods (pero también puede implementarse usando Prototype)
• Singleton: Una fábrica concreta a menudo es un singleton
• Prototype: AbstractFactory puede usar Prototype para crear objetos de producto","benefits-drawbacks abstract-factory creational","Creational","87"
"What patterns are related to the Abstract Factory pattern?","• Factory Method: Abstract Factory classes often implemented with Factory Methods
• Prototype: Concrete factory can be implemented using Prototype
• Singleton: Concrete factory is often a Singleton","¿Cuáles son las consideraciones clave de implementación para el patrón Abstract Factory?","• Las fábricas como singletons - una aplicación típicamente necesita solo una instancia de ConcreteFactory por familia de productos
• Crear los productos - AbstractFactory solo declara interfaz para crear productos, ConcreteFactory debe especificar el producto concreto
• Dos enfoques comunes: (1) Factory Method - requiere nueva subclase de fábrica concreta para cada familia, (2) Prototype - fábrica se inicializa con instancia prototipo, crea productos clonando prototipos
• Definir fábricas extensibles - añadir parámetro a operaciones de creación que especifica el tipo de objeto a crear
• Ventaja: no necesita cambiar interfaz de fábrica al añadir nuevos productos
• Desventaja: todos los productos deben devolver el mismo tipo base, pierde seguridad de tipos","related-patterns abstract-factory creational","Creational","87"
"What are key implementation considerations for the Abstract Factory pattern?","• Factories are often singletons
• Creating products - usually use Factory Method pattern
• Can use Prototype to eliminate need for new ConcreteFactory class
• Define extensible factories using parameters to specify products
• Prototype-based: factory stores prototypes and clones them
• Class-based (Smalltalk): factory stores classes and instantiates them","class WidgetFactory {
public:
  virtual ScrollBar* CreateScrollBar() = 0;
  virtual Window* CreateWindow() = 0;
};

class MotifWidgetFactory : public WidgetFactory {
public:
  ScrollBar* CreateScrollBar() { return new MotifScrollBar; }
  Window* CreateWindow() { return new MotifWindow; }
};","Patrón: Abstract Factory
Elementos clave: AbstractFactory declara métodos de creación para cada tipo de producto, ConcreteFactory implementa estos métodos devolviendo productos concretos de la misma familia (Motif)","implementation abstract-factory creational","Creational","87"
"Maze* MazeGame::CreateMaze(MazeFactory& factory) {
  Maze* aMaze = factory.MakeMaze();
  Room* r1 = factory.MakeRoom(1);
  Room* r2 = factory.MakeRoom(2);
  Door* aDoor = factory.MakeDoor(r1, r2);
  // ...
}","Pattern: Abstract Factory
Key elements: Client creates maze using factory interface (MakeMaze, MakeRoom, MakeDoor) without knowing concrete classes, allowing different maze styles (enchanted, bombed) by swapping factory","¿Cuáles son ejemplos del mundo real del patrón Abstract Factory?","• Kits de widgets de interfaz de usuario (Motif, Windows, Mac)
• Temas/skins de aplicaciones
• Soporte multiplataforma para componentes UI
• Familias de productos en frameworks de juegos","code-example abstract-factory creational cpp","Creational","87"
"What are real-world examples of the Abstract Factory pattern?","• UI toolkit widgets for different look-and-feel standards (Motif, Windows, Mac)
• Database access layers supporting multiple database vendors
• Cross-platform UI frameworks","¿Cuál es la intención del patrón Builder?","Separar la construcción de un objeto complejo de su representación para que el mismo proceso de construcción pueda crear diferentes representaciones.","real-world abstract-factory creational","Creational","87"
"What are common misuses of the Abstract Factory pattern?","• Using it when product families don't vary or only one implementation exists
• Creating factory hierarchies that are too complex for the problem domain
• Not properly enforcing that products from same family are used together
• Adding too many product types to factory interface, making it unwieldy","¿Cuándo usarías el patrón Builder?","• El algoritmo para crear un objeto complejo debe ser independiente de las partes que componen el objeto y cómo se ensamblan
• El proceso de construcción debe permitir diferentes representaciones para el objeto que se construye
• Necesitas construir objetos compuestos o agregados con diferentes implementaciones internas","anti-pattern abstract-factory creational","Creational","87"
"What is the intent of the Builder pattern?","Separate the construction of a complex object from its representation so that the same construction process can create different representations.","¿Cuáles son los participantes clave en el patrón Builder?","• Builder: Especifica una interfaz abstracta para crear partes de un objeto Product
• ConcreteBuilder: Construye y ensambla partes del producto implementando la interfaz Builder; define y mantiene la representación que crea; proporciona interfaz para recuperar el producto
• Director: Construye un objeto usando la interfaz Builder
• Product: Representa el objeto complejo bajo construcción; ConcreteBuilder construye la representación interna del producto y define el proceso por el cual se ensambla","intent builder creational","Creational","97"
"When would you use the Builder pattern?","• Algorithm for creating complex object should be independent of parts that make up object and how they're assembled
• Construction process must allow different representations for object that's constructed","¿Cuáles son los beneficios y desventajas del patrón Builder?","Beneficios:
• Permite variar la representación interna de un producto
• Aísla el código para construcción y representación
• Da control más fino sobre el proceso de construcción - construye el objeto paso a paso
• Puede reutilizar el mismo proceso de construcción para crear diferentes representaciones

Desventajas:
• Requiere crear un ConcreteBuilder específico para cada tipo diferente de producto
• Las clases Builder deben ser mutables
• Puede complicar el código si el objeto de construcción es simple","use-case builder creational","Creational","97"
"What are the key participants in the Builder pattern?","• Builder: Specifies abstract interface for creating parts of Product object
• ConcreteBuilder: Constructs and assembles parts of product by implementing Builder interface, defines and keeps track of representation it creates, provides interface for retrieving product
• Director: Constructs object using Builder interface
• Product: Represents complex object under construction, includes classes defining constituent parts and interfaces for assembling parts into final result","¿Qué patrones están relacionados con el patrón Builder?","• Abstract Factory: Similar a Builder en que puede construir objetos complejos. La diferencia principal es que Builder se centra en construir un objeto complejo paso a paso, mientras Abstract Factory se centra en familias de objetos de producto
• Composite: Lo que el builder a menudo construye es un composite","key-concepts builder creational","Creational","97"
"What are the benefits and drawbacks of the Builder pattern?","Benefits:
• Lets you vary product's internal representation
• Isolates code for construction and representation
• Gives finer control over construction process than other creational patterns

Drawbacks:
• Requires creating ConcreteBuilder for each type of product
• Builder classes can be complex if products are significantly different","¿Cuáles son las consideraciones clave de implementación para el patrón Builder?","• Interfaz de ensamblaje y construcción - builders construyen sus productos en pasos; por lo tanto, la interfaz de la clase Builder debe ser lo suficientemente general para permitir la construcción de productos para todos los tipos de builders concretos
• Sin clase abstracta para productos - productos construidos por builders concretos difieren tanto en representación que hay poco que ganar de una clase padre común
• Métodos vacíos como predeterminados en Builder - permite a los clientes anular solo las operaciones en las que están interesados
• Director puede tomar Builder como argumento del constructor o tener un método para establecer el Builder","benefits-drawbacks builder creational","Creational","97"
"What patterns are related to the Builder pattern?","• Abstract Factory: Similar but Builder focuses on constructing complex object step by step while Abstract Factory emphasizes families of product objects
• Composite: What the builder often builds","class TextConverter {
public:
  virtual void ConvertCharacter(char) { }
  virtual void ConvertParagraph() { }
};

class TeXConverter : public TextConverter {
public:
  void ConvertCharacter(char c) {
    // implementación específica de TeX
  }
  TeXText* GetTeXText() { return _texText; }
private:
  TeXText* _texText;
};","Patrón: Builder
Elementos clave: Builder (TextConverter) define interfaz para construir partes, ConcreteBuilder (TeXConverter) implementa operaciones de construcción, proporciona método para recuperar producto construido","related-patterns builder creational","Creational","97"
"What are key implementation considerations for the Builder pattern?","• Builder interface must be general enough to construct products for all kinds of concrete builders
• Products produced by builders often differ greatly, so little to gain from common parent class
• Build methods intentionally not pure virtual in C++ - defined as empty methods so clients override only operations they're interested in
• Example operations: BuildMaze(), BuildRoom(int), BuildDoor(int, int)","¿Cuáles son ejemplos del mundo real del patrón Builder?","• Convertidores de formato de documentos (RTF a ASCII, HTML, TeX)
• Constructores de consultas SQL
• Constructores de objetos de configuración complejos
• Generadores de formularios o interfaces de usuario","implementation builder creational","Creational","97"
"Maze* MazeGame::CreateMaze(MazeBuilder& builder) {
  builder.BuildMaze();
  builder.BuildRoom(1);
  builder.BuildRoom(2);
  builder.BuildDoor(1, 2);
  return builder.GetMaze();
}","Pattern: Builder
Key elements: Director uses builder interface to construct maze step by step (BuildMaze, BuildRoom, BuildDoor), allowing different builders to create different maze representations from same construction process","¿Cuál es la intención del patrón Factory Method?","Definir una interfaz para crear un objeto, pero dejar que las subclases decidan qué clase instanciar. Factory Method permite que una clase difiera la instanciación a subclases.","code-example builder creational cpp","Creational","97"
"What are real-world examples of the Builder pattern?","• RTF document converters
• Parser builders (Smalltalk-80 Parser and ProgramNodeBuilder)
• Network service configuration (Adaptive Communications Environment)
• UI form builders","¿Cuándo usarías el patrón Factory Method?","• Una clase no puede anticipar la clase de objetos que debe crear
• Una clase quiere que sus subclases especifiquen los objetos que crea
• Las clases delegan responsabilidad a una de varias subclases auxiliares, y quieres localizar el conocimiento de qué subclase auxiliar es el delegado","real-world builder creational","Creational","97"
"What are common misuses of the Builder pattern?","• Using it for simple objects where a constructor or factory method would suffice
• Creating builders that are too tightly coupled to specific product implementations
• Not providing default implementations for optional build steps
• Confusing it with Abstract Factory when product families (not construction steps) are the main concern","¿Cuáles son los participantes clave en el patrón Factory Method?","• Product: Define la interfaz de objetos que el factory method crea
• ConcreteProduct: Implementa la interfaz Product
• Creator: Declara el factory method que devuelve un objeto de tipo Product; puede definir implementación predeterminada que devuelve un objeto ConcreteProduct predeterminado; puede llamar al factory method para crear un objeto Product
• ConcreteCreator: Sobrescribe el factory method para devolver una instancia de ConcreteProduct","anti-pattern builder creational","Creational","97"
"Compare Abstract Factory vs Builder","Similarities:
• Both are creational patterns
• Both create complex objects
• Both abstract object creation from clients

Differences:
• Intent: Abstract Factory creates families of related objects, Builder constructs complex object step by step
• Focus: Abstract Factory emphasizes product families, Builder emphasizes construction process
• Return: Abstract Factory returns product immediately, Builder constructs product gradually

When to use each:
• Abstract Factory: When you need families of related objects
• Builder: When construction process is complex with many steps","¿Cuáles son los beneficios y desventajas del patrón Factory Method?","Beneficios:
• Elimina la necesidad de vincular clases específicas de la aplicación en tu código - el código solo trata con la interfaz Product
• Proporciona ganchos para subclases - crear objetos dentro de una clase con factory method siempre es más flexible que crear directamente
• Conecta jerarquías de clases paralelas

Desventajas:
• Puede requerir crear subclases solo para crear objetos de producto particulares
• Los clientes podrían tener que subclasificar la clase Creator solo para crear un objeto ConcreteProduct particular","comparison abstract-factory builder","Comparison","87"
"What is the intent of the Factory Method pattern?","Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.","¿Qué patrones están relacionados con el patrón Factory Method?","• Abstract Factory: A menudo se implementa con factory methods
• Template Method: Factory methods usualmente se llaman dentro de template methods
• Prototype: No requiere subclasificar Creator, pero a menudo requiere operación Initialize en Product; Factory Method no requiere tal inicialización","intent factory-method creational","Creational","106"
"When would you use the Factory Method pattern?","• Class can't anticipate the class of objects it must create
• Class wants its subclasses to specify the objects it creates
• Classes delegate responsibility to one of several helper subclasses, and you want to localize knowledge of which helper subclass is delegate","¿Cuáles son las consideraciones clave de implementación para el patrón Factory Method?","• Dos variedades principales: (1) Creator es clase abstracta y no proporciona implementación para factory method, (2) Creator es clase concreta y proporciona implementación predeterminada para factory method
• Factory methods parametrizados - factory method toma parámetro que identifica el tipo de objeto a crear
• Factory method puede usar plantillas para evitar subclasificación
• Convenciones de nomenclatura: usar nombres como ""CreateProduct"" o ""NewProduct"" para factory methods","use-case factory-method creational","Creational","106"
"What are the key participants in the Factory Method pattern?","• Product: Defines interface of objects the factory method creates
• ConcreteProduct: Implements Product interface
• Creator: Declares factory method returning object of type Product, may define default implementation, may call factory method to create Product object
• ConcreteCreator: Overrides factory method to return instance of ConcreteProduct","class Document {
public:
  Document();
  virtual void Open();
  virtual void Close();
  // ... otros
  
  virtual void Save();
  
protected:
  virtual Page* CreatePage() = 0;
};","Patrón: Factory Method
Elementos clave: Creator (Document) declara factory method abstracto CreatePage() que las subclases sobrescriben para devolver subclases específicas de Product (Page)","key-concepts factory-method creational","Creational","106"
"What are the benefits and drawbacks of the Factory Method pattern?","Benefits:
• Eliminates need to bind application-specific classes into code
• Provides hooks for subclasses - creating objects inside class with factory method is more flexible than creating directly
• Connects parallel class hierarchies (e.g., Figure-Manipulator hierarchies)

Drawbacks:
• Clients might have to subclass Creator just to create particular ConcreteProduct
• Can cause proliferation of subclasses","void Document::Save() {
  Page* page = CreatePage();
  // guardar página en disco
}

class MyDocument : public Document {
protected:
  Page* CreatePage() {
    return new MyPage;
  }
};","Patrón: Factory Method
Elementos clave: Creator usa factory method (CreatePage) en sus operaciones, ConcreteCreator (MyDocument) sobrescribe factory method para devolver ConcreteProduct específico (MyPage)","benefits-drawbacks factory-method creational","Creational","106"
"What patterns are related to the Factory Method pattern?","• Abstract Factory: Often implemented with factory methods
• Template Methods: Factory methods usually called within template methods
• Prototype: Prototypes don't require subclassing Creator but often require Initialize operation","¿Cuáles son ejemplos del mundo real del patrón Factory Method?","• Frameworks de aplicaciones (Application, Document)
• Creadores de controles UI (Button, Checkbox creados por WidgetFactory)
• Frameworks de persistencia (creación de objetos de almacenamiento)
• Creación de objetos de conexión en capas de acceso a datos","related-patterns factory-method creational","Creational","106"
"What are key implementation considerations for the Factory Method pattern?","• Two main varieties: (1) Creator is abstract with no implementation, (2) Creator is concrete with default implementation
• Parameterized factory methods can create multiple kinds of products based on parameter
• Language-specific: C++ factory methods are virtual functions, Smalltalk uses class methods
• Use lazy initialization to avoid calling factory methods in constructor
• Naming conventions: use DoMakeClass() pattern (e.g., MacApp framework)
• Templates can avoid subclassing in C++","¿Cuál es la intención del patrón Prototype?","Especificar los tipos de objetos a crear usando una instancia prototípica, y crear nuevos objetos copiando este prototipo.","implementation factory-method creational","Creational","106"
"class MazeGame {
public:
  Maze* CreateMaze();
  virtual Maze* MakeMaze() const { return new Maze; }
  virtual Room* MakeRoom(int n) const { return new Room(n); }
  virtual Wall* MakeWall() const { return new Wall; }
  virtual Door* MakeDoor(Room* r1, Room* r2) const { return new Door(r1, r2); }
};","Pattern: Factory Method
Key elements: Creator class with factory methods (MakeMaze, MakeRoom, MakeWall, MakeDoor) that subclasses can override to change product types without modifying construction logic in CreateMaze","¿Cuándo usarías el patrón Prototype?","• Cuando las clases a instanciar se especifican en tiempo de ejecución
• Para evitar construir una jerarquía de clases de fábricas paralela a la jerarquía de clases de productos
• Cuando las instancias de una clase pueden tener solo unas pocas combinaciones diferentes de estado
• Cuando la creación de objetos es costosa","code-example factory-method creational cpp","Creational","106"
"What are real-world examples of the Factory Method pattern?","• Document creation in application frameworks (MacApp, ET++)
• Figure manipulation tools in drawing editors (Unidraw)
• View controllers in Smalltalk-80 MVC framework
• Parser classes in compiler frameworks
• Remote object proxies (Orbix ORB system)","¿Cuáles son los participantes clave en el patrón Prototype?","• Prototype: Declara una interfaz para clonarse a sí mismo
• ConcretePrototype: Implementa una operación para clonarse a sí mismo
• Client: Crea un nuevo objeto pidiendo a un prototipo que se clone a sí mismo","real-world factory-method creational","Creational","106"
"What are common misuses of the Factory Method pattern?","• Creating unnecessary subclasses when a simple parameter to constructor would suffice
• Overusing it for simple object creation that doesn't need flexibility
• Not providing sensible default implementation in Creator class
• Confusing it with Simple Factory (which is not a design pattern)","¿Cuáles son los beneficios y desventajas del patrón Prototype?","Beneficios:
• Oculta las clases de producto concreto del cliente
• Puede añadir y eliminar productos en tiempo de ejecución
• Especificar nuevos objetos variando valores (por ejemplo, composición de objetos)
• Especificar nuevos objetos variando estructura (crear objetos a partir de partes y subpartes)
• Reduce el número de subclases - clona en lugar de pedir a factory method que cree

Desventajas:
• Cada subclase debe implementar operación Clone
• Implementar Clone puede ser difícil si las clases ya existen o incluyen objetos que no soportan copia
• Clonación profunda vs superficial puede ser compleja","anti-pattern factory-method creational","Creational","106"
"What is the intent of the Prototype pattern?","Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.","¿Qué patrones están relacionados con el patrón Prototype?","• Abstract Factory: Puede usar Prototype para crear familias de productos
• Composite: Prototype a menudo útil con Composite
• Decorator: Prototype útil con Decorator","intent prototype creational","Creational","115"
"When would you use the Prototype pattern?","• Classes to instantiate are specified at run-time (e.g., by dynamic loading)
• To avoid building class hierarchy of factories that parallels product class hierarchy
• When instances of class can have one of only a few different combinations of state (install prototypes and clone rather than instantiate manually)","¿Cuáles son las consideraciones clave de implementación para el patrón Prototype?","• Usar un gestor de prototipos - cuando los prototipos del sistema se crean y destruyen dinámicamente, mantener un registro de prototipos disponibles
• Operaciones Clone vs Copy - Clone es como un constructor y puede necesitar inicializar estados internos después de la copia
• Clonación profunda vs superficial - Clone debe decidir si clonar toda la estructura (profunda) o compartir parte de ella (superficial)
• Inicializar clones - algunos clientes querrán inicializar estado interno después de clonar; considerar pasar parámetros a Clone o añadir operación Initialize
• En C++, proporcionar operación Clone virtual en clase base, usar copy constructor para implementación","use-case prototype creational","Creational","115"
"What are the key participants in the Prototype pattern?","• Prototype: Declares interface for cloning itself
• ConcretePrototype: Implements operation for cloning itself
• Client: Creates new object by asking prototype to clone itself","class Graphic {
public:
  virtual Graphic* Clone() = 0;
};

class Staff : public Graphic {
public:
  Graphic* Clone() {
    return new Staff(*this);
  }
};","Patrón: Prototype
Elementos clave: Prototype declara método Clone abstracto, ConcretePrototype implementa Clone típicamente usando copy constructor para crear una copia de sí mismo","key-concepts prototype creational","Creational","115"
"What are the benefits and drawbacks of the Prototype pattern?","Benefits:
• Adding and removing products at run-time
• Specifying new objects by varying values
• Specifying new objects by varying structure
• Reduced subclassing - lets you clone prototype instead of asking factory method
• Configuring application with classes dynamically

Drawbacks:
• Each subclass of Prototype must implement Clone operation which may be difficult
• Implementing Clone is difficult when internals include objects that don't support copying or have circular references","¿Cuáles son ejemplos del mundo real del patrón Prototype?","• Editor de partituras musicales (clonar notas musicales, pentagramas)
• Editores gráficos (clonar formas, símbolos)
• Sistemas CAD (clonar componentes)
• Juegos (clonar enemigos, objetos con configuraciones complejas)","benefits-drawbacks prototype creational","Creational","115"
"What patterns are related to the Prototype pattern?","• Abstract Factory: Competing patterns but can be used together - Abstract Factory might store prototypes to clone
• Composite: Designs using Composite often benefit from Prototype
• Decorator: Designs using Decorator often benefit from Prototype","¿Cuál es la intención del patrón Singleton?","Asegurar que una clase tenga solo una instancia y proporcionar un punto de acceso global a ella.","related-patterns prototype creational","Creational","115"
"What are key implementation considerations for the Prototype pattern?","• Use prototype manager (registry) when number of prototypes isn't fixed
• Implementing Clone operation - shallow copy vs deep copy decision
• Shallow copy is simple and often sufficient (Smalltalk default)
• Deep copy needed when clone and original must be independent
• Can use Save/Load to implement Clone (save to memory buffer, load back)
• Initializing clones - may need Initialize operation to set internal state after cloning
• Prototype manager is associative store that returns prototype matching given key","¿Cuándo usarías el patrón Singleton?","• Debe haber exactamente una instancia de una clase, y debe ser accesible a los clientes desde un punto de acceso conocido
• Cuando la instancia única debe ser extensible mediante subclasificación, y los clientes deben poder usar una instancia extendida sin modificar su código","implementation prototype creational","Creational","115"
"class MazePrototypeFactory : public MazeFactory {
public:
  MazePrototypeFactory(Maze*, Wall*, Room*, Door*);
  virtual Wall* MakeWall() const { return _prototypeWall->Clone(); }
  virtual Door* MakeDoor(Room* r1, Room* r2) const {
    Door* door = _prototypeDoor->Clone();
    door->Initialize(r1, r2);
    return door;
  }
};","Pattern: Prototype
Key elements: Factory initialized with prototypes which are cloned to create products (MakeWall clones _prototypeWall), with Initialize method to set state after cloning","¿Cuáles son los participantes clave en el patrón Singleton?","• Singleton: Define operación Instance que permite a los clientes acceder a su instancia única (método de clase en Smalltalk, función miembro estática en C++), puede ser responsable de crear su propia instancia única","code-example prototype creational cpp","Creational","115"
"What are real-world examples of the Prototype pattern?","• Sketchpad system (Ivan Sutherland)
• ThingLab reusable object library
• Etgdb debugger front-end with DebuggerAdaptor prototypes
• Mode Composer interaction technique library
• Unidraw drawing framework","¿Cuáles son los beneficios y desventajas del patrón Singleton?","Beneficios:
• Acceso controlado a la instancia única
• Espacio de nombres reducido - evita contaminar el espacio de nombres con variables globales
• Permite refinamiento de operaciones y representación - la clase Singleton puede ser subclasificada
• Permite número variable de instancias - fácil de cambiar para permitir más de una
• Más flexible que operaciones de clase - las funciones miembro estáticas no pueden ser sobrescritas polimórficamente

Desventajas:
• Puede ser difícil de probar
• Crea dependencias ocultas
• Puede violar el Principio de Responsabilidad Única
• Puede causar problemas en entornos multihilo","real-world prototype creational","Creational","115"
"What are common misuses of the Prototype pattern?","• Using shallow copy when deep copy is needed, causing shared state bugs
• Not properly implementing Clone for objects with circular references
• Forgetting to provide Initialize method for setting state after cloning
• Using it when simple constructors with parameters would be clearer
• Not handling resource ownership properly during cloning","¿Qué patrones están relacionados con el patrón Singleton?","• Abstract Factory: Puede ser implementado usando Singleton
• Builder: Puede ser implementado usando Singleton
• Prototype: Puede ser implementado usando Singleton","anti-pattern prototype creational","Creational","115"
"What is the intent of the Singleton pattern?","Ensure a class only has one instance, and provide a global point of access to it.","¿Cuáles son las consideraciones clave de implementación para el patrón Singleton?","• Ocultar operación que crea instancia detrás de operación de clase (Instance) que garantiza solo una instancia
• Instance usa inicialización perezosa - el valor no se crea hasta el primer acceso
• El constructor es protegido para prevenir instanciación directa
• Variable miembro estática _instance almacena puntero a instancia única
• Instance puede asignar puntero a subclase, habilitando singletons de subclases
• No se puede usar inicialización de objeto estático debido a: (1) no hay garantía de instancia única, (2) información insuficiente en tiempo de init estático, (3) orden indefinido de constructores a través de unidades de traducción
• Subclasificación: usar variables de entorno, registro de singletons, o selección en tiempo de enlace
• Enfoque de registro: las clases Singleton se registran por nombre, Instance busca por nombre","intent singleton creational","Creational","124"
"When would you use the Singleton pattern?","• There must be exactly one instance of a class, and it must be accessible to clients from well-known access point
• When sole instance should be extensible by subclassing, and clients should be able to use extended instance without modifying code","class Singleton {
public:
  static Singleton* Instance();
protected:
  Singleton();
private:
  static Singleton* _instance;
};

Singleton* Singleton::Instance() {
  if (_instance == 0) {
    _instance = new Singleton;
  }
  return _instance;
}","Patrón: Singleton
Elementos clave: Método Instance() estático con inicialización perezosa, constructor protegido para prevenir instanciación directa, variable _instance estática para almacenar instancia única","use-case singleton creational","Creational","124"
"What are the key participants in the Singleton pattern?","• Singleton: Defines Instance operation that lets clients access unique instance (class method in Smalltalk, static member function in C++), may be responsible for creating its own unique instance","¿Cuáles son ejemplos del mundo real del patrón Singleton?","• ChangeSet current en Smalltalk-80
• Metaclases en Smalltalk (clase de una clase)
• Session y WidgetKit en el toolkit InterViews
• Gestores de configuración de aplicaciones
• Sistemas de registro (logging)","key-concepts singleton creational","Creational","124"
"What are the benefits and drawbacks of the Singleton pattern?","Benefits:
• Controlled access to sole instance
• Reduced name space - avoids polluting name space with global variables
• Permits refinement of operations and representation - Singleton class may be subclassed
• Permits variable number of instances - easy to change to allow more than one
• More flexible than class operations - static member functions can't be overridden polymorphically

Drawbacks:
• Can be difficult to test
• Creates hidden dependencies
• May violate Single Responsibility Principle
• Can cause issues in multithreaded environments","Compara Factory Method vs Prototype","Similitudes:
• Ambos son patrones creacionales
• Ambos difieren la creación de objetos
• Ambos proporcionan flexibilidad en la creación de objetos

Diferencias:
• Mecanismo: Factory Method usa herencia/subclasificación, Prototype usa clonación
• Subclasificación: Factory Method requiere subclasificar Creator, Prototype evita subclasificación
• Configuración: Factory Method es en tiempo de compilación, Prototype puede ser en tiempo de ejecución
• Inicialización: Prototype a menudo requiere operación Initialize después de clonar

Cuándo usar cada uno:
• Factory Method: Cuando quieres usar herencia para variar productos
• Prototype: Cuando quieres evitar subclasificación y configurar en tiempo de ejecución","benefits-drawbacks singleton creational","Creational","124"
"What patterns are related to the Singleton pattern?","• Abstract Factory: Can be implemented using Singleton
• Builder: Can be implemented using Singleton
• Prototype: Can be implemented using Singleton","¿Qué patrones usan el concepto 'Encapsulación de Variación'?","Identificar aspectos que varían y separarlos de lo que permanece igual. Command encapsula solicitudes, Strategy encapsula algoritmos, Abstract Factory encapsula familias de widgets, Bridge encapsula implementaciones de ventanas.

Patrones: Command, Strategy, Abstract Factory, Bridge, State","related-patterns singleton creational","Creational","124"
"What are key implementation considerations for the Singleton pattern?","• Hide operation that creates instance behind class operation (Instance) that guarantees only one instance
• Instance uses lazy initialization - value isn't created until first accessed
• Constructor is protected to prevent direct instantiation
• Static member variable _instance stores pointer to unique instance
• Instance can assign pointer to subclass, enabling subclass singletons
• Can't use static object initialization due to: (1) no guarantee of single instance, (2) insufficient info at static init time, (3) undefined order of constructors across translation units
• Subclassing: use environment variables, registry of singletons, or link-time selection
• Registry approach: Singleton classes register by name, Instance looks up by name","¿Qué patrones usan el concepto 'Composición sobre Herencia'?","Favorecer la composición de objetos sobre la herencia de clases para lograr flexibilidad. Nueva funcionalidad se añade componiendo objetos de nuevas maneras en lugar de definir nuevas subclases. Reduce la explosión de clases y habilita configuración en tiempo de ejecución.

Patrones: Composite, Decorator, Strategy, Bridge","implementation singleton creational","Creational","124"
"class Singleton {
public:
  static Singleton* Instance();
protected:
  Singleton();
private:
  static Singleton* _instance;
};

Singleton* Singleton::Instance() {
  if (_instance == 0) {
    _instance = new Singleton;
  }
  return _instance;
}","Pattern: Singleton
Key elements: Static Instance() method with lazy initialization, protected constructor to prevent direct instantiation, static _instance variable to store sole instance","¿Qué patrones usan el concepto 'Programar a Interfaz, no a Implementación'?","Los clientes permanecen inconscientes de los tipos y clases específicos de objetos que usan. Declarar variables como instancias de clases abstractas y comprometerse solo con interfaces definidas por clases abstractas.

Patrones: Abstract Factory, Strategy, Bridge, Composite, Command","code-example singleton creational cpp","Creational","124"
"What are real-world examples of the Singleton pattern?","• ChangeSet current in Smalltalk-80
• Metaclasses in Smalltalk (class of a class)
• Session and WidgetKit in InterViews toolkit
• Application configuration managers
• Logging systems","¿Qué patrones usan el concepto 'Delegación'?","Hacer la composición tan poderosa como la herencia haciendo que el objeto receptor delegue operaciones a su delegado. Decorator delega a componente, Strategy context delega a objeto strategy, Bridge abstraction delega a implementor.

Patrones: Decorator, Strategy, Bridge, Command","real-world singleton creational","Creational","124"
"Compare Factory Method vs Prototype","Similarities:
• Both are creational patterns
• Both defer object creation
• Both provide flexibility in object creation

Differences:
• Mechanism: Factory Method uses inheritance/subclassing, Prototype uses cloning
• Subclassing: Factory Method requires subclassing Creator, Prototype avoids subclassing
• Configuration: Factory Method is compile-time, Prototype can be run-time
• Initialization: Prototype often requires Initialize operation after cloning

When to use each:
• Factory Method: When you want to use inheritance to vary products
• Prototype: When you want to avoid subclassing and configure at run-time","¿Qué patrones usan el concepto 'Separación de Preocupaciones'?","Separar diferentes aspectos de un diseño en partes independientes. Bridge separa abstracción de implementación, Strategy separa algoritmo de contexto, Visitor separa algoritmo de estructura de objetos, Builder separa construcción de representación.

Patrones: Bridge, Strategy, Abstract Factory, Visitor, Builder","comparison factory-method prototype","Comparison","106"
"Which patterns use the concept 'Encapsulation of Variation'?","Identify aspects that vary and separate them from what stays the same. Command encapsulates requests, Strategy encapsulates algorithms, Abstract Factory encapsulates widget families, Bridge encapsulates window implementations.

Patterns: Command, Strategy, Abstract Factory, Bridge, State","¿Qué patrones usan el concepto 'Inicialización Perezosa'?","Diferir la creación de objetos hasta que sean realmente necesarios. La operación Instance de Singleton crea instancia solo en el primer acceso. Evita creación innecesaria de objetos y resuelve problemas de orden de inicialización.

Patrones: Singleton, Prototype","cross-cutting encapsulation-of-variation","Cross-Cutting","66"
"Which patterns use the concept 'Composition over Inheritance'?","Favor object composition over class inheritance to achieve flexibility. New functionality added by composing objects in new ways rather than defining new subclasses. Reduces class explosion and enables run-time configuration.

Patterns: Composite, Decorator, Strategy, Bridge","¿Qué patrones usan el concepto 'Doble Despacho'?","La operación depende tanto del tipo del receptor como del argumento. Element llama a Accept con visitor, que llama de vuelta al método Visit específico del tipo del elemento. Permite que la operación se determine por ambos tipos de elemento y visitor sin pruebas de tipo.

Patrones: Visitor","cross-cutting composition-over-inheritance","Cross-Cutting","66"
"Which patterns use the concept 'Program to Interface, not Implementation'?","Clients remain unaware of specific types and classes of objects they use. Declare variables as instances of abstract classes and commit only to interfaces defined by abstract classes.

Patterns: Abstract Factory, Strategy, Bridge, Composite, Command","¿Qué patrones usan el concepto 'Flexibilidad de Composición de Objetos'?","Los patrones creacionales cambian el énfasis de codificar comportamientos fijos hacia definir comportamientos fundamentales componibles en complejos. Crear objetos con comportamientos particulares requiere más que simplemente instanciar una clase.

Patrones: Abstract Factory, Builder, Prototype, Factory Method","cross-cutting program-to-interface","Cross-Cutting","66"
"What is the intent of the Adapter pattern?","Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.","¿Cuál es la intención del patrón Adapter?","Convertir la interfaz de una clase en otra interfaz que los clientes esperan. Adapter permite que clases trabajen juntas que de otra manera no podrían debido a interfaces incompatibles.","intent adapter structural","Structural","139"
"When would you use the Adapter pattern?","- You want to use an existing class, and its interface does not match the one you need
- You want to create a reusable class that cooperates with unrelated or unforeseen classes, that is, classes that don't necessarily have compatible interfaces
- You need to use several existing subclasses, but it's impractical to adapt their interface by subclassing every one. An object adapter can adapt the interface of its parent class","¿Cuándo usarías el patrón Adapter?","- Quieres usar una clase existente, y su interfaz no coincide con la que necesitas
- Quieres crear una clase reutilizable que coopere con clases no relacionadas o imprevistas, es decir, clases que no necesariamente tienen interfaces compatibles
- Necesitas usar varias subclases existentes, pero es impráctico adaptar su interfaz creando subclases de cada una. Un adaptador de objeto puede adaptar la interfaz de su clase padre","use-case adapter structural","Structural","139"
"What are the key participants in the Adapter pattern?","- Target: Defines the domain-specific interface that Client uses
- Client: Collaborates with objects conforming to the Target interface
- Adaptee: Defines an existing interface that needs adapting
- Adapter: Adapts the interface of Adaptee to the Target interface","¿Cuáles son los participantes clave en el patrón Adapter?","- Target: Define la interfaz específica del dominio que usa el Cliente
- Client: Colabora con objetos que cumplen con la interfaz Target
- Adaptee: Define una interfaz existente que necesita adaptación
- Adapter: Adapta la interfaz del Adaptee a la interfaz Target","key-concepts adapter structural","Structural","139"
"What are the benefits and drawbacks of the Adapter pattern?","Benefits:
- Class adapter: Lets Adapter override some of Adaptee's behavior. Introduces only one object, no additional pointer indirection
- Object adapter: Lets a single Adapter work with many Adaptees. Can add functionality to all Adaptees at once

Drawbacks:
- Class adapter: Requires multiple inheritance, which isn't available in all languages. Won't work when adapting a class and all its subclasses
- Object adapter: Makes it harder to override Adaptee behavior since it requires subclassing Adaptee","¿Cuáles son los beneficios y desventajas del patrón Adapter?","Beneficios:
- Adaptador de clase: Permite que Adapter sobrescriba parte del comportamiento del Adaptee. Introduce solo un objeto, sin indirección adicional de punteros
- Adaptador de objeto: Permite que un solo Adapter funcione con muchos Adaptees. Puede agregar funcionalidad a todos los Adaptees a la vez

Desventajas:
- Adaptador de clase: Requiere herencia múltiple, que no está disponible en todos los lenguajes. No funcionará al adaptar una clase y todas sus subclases
- Adaptador de objeto: Hace más difícil sobrescribir el comportamiento del Adaptee ya que requiere crear subclases del Adaptee","benefits-drawbacks adapter structural","Structural","139"
"What patterns are related to the Adapter pattern?","- Bridge: Has a structure similar to an object adapter, but separates interface from implementation. An adapter changes the interface of an existing object
- Decorator: Enhances another object without changing its interface, more transparent than adapter. Supports recursive composition
- Proxy: Defines a representative for another object and does not change its interface","¿Qué patrones están relacionados con el patrón Adapter?","- Bridge: Tiene una estructura similar a un adaptador de objeto, pero separa la interfaz de la implementación. Un adaptador cambia la interfaz de un objeto existente
- Decorator: Mejora otro objeto sin cambiar su interfaz, es más transparente que un adaptador. Soporta composición recursiva
- Proxy: Define un representante para otro objeto y no cambia su interfaz","related-patterns adapter structural","Structural","139"
"class TextShape : public Shape, private TextView {
public:
    TextShape();
    virtual void BoundingBox(Point& bottomLeft, Point& topRight) const;
    virtual bool IsEmpty() const;
};","Pattern: Adapter
Key elements: Class adapter using multiple inheritance - inherits interface publicly from Shape (Target) and implementation privately from TextView (Adaptee)","class TextShape : public Shape, private TextView {
public:
    TextShape();
    virtual void BoundingBox(Point& bottomLeft, Point& topRight) const;
    virtual bool IsEmpty() const;
};","Patrón: Adapter
Elementos clave: Adaptador de clase usando herencia múltiple - hereda la interfaz públicamente de Shape (Target) e implementación privadamente de TextView (Adaptee)","code-example adapter structural cpp","Structural","139"
"What are key implementation considerations for the Adapter pattern?","- How much adapting does Adapter do? Ranges from simple interface conversion to complete support of an entirely different set of operations
- Pluggable adapters: Building interface adaptation into a class minimizes assumptions other classes must make to use it
- Using two-way adapters to provide transparency: Allows adapted object to be used wherever Adaptee or Target is expected, using multiple inheritance","¿Cuáles son las consideraciones clave de implementación para el patrón Adapter?","- ¿Cuánta adaptación hace el Adapter? Varía desde simple conversión de interfaz hasta soporte completo de un conjunto totalmente diferente de operaciones
- Adaptadores enchufables: Incorporar adaptación de interfaz en una clase minimiza las suposiciones que otras clases deben hacer para usarla
- Usar adaptadores bidireccionales para proporcionar transparencia: Permite que el objeto adaptado se use donde se espera Adaptee o Target, usando herencia múltiple","implementation adapter structural","Structural","139"
"What is the intent of the Bridge pattern?","Decouple an abstraction from its implementation so that the two can vary independently.","¿Cuál es la intención del patrón Bridge?","Desacoplar una abstracción de su implementación de modo que ambas puedan variar independientemente.","intent bridge structural","Structural","151"
"When would you use the Bridge pattern?","- You want to avoid a permanent binding between an abstraction and its implementation
- Both the abstractions and their implementations should be extensible by subclassing
- Changes in the implementation of an abstraction should have no impact on clients
- You want to hide the implementation of an abstraction completely from clients
- You have a proliferation of classes
- You want to share an implementation among multiple objects and this fact should be hidden from the client","¿Cuándo usarías el patrón Bridge?","- Quieres evitar un vínculo permanente entre una abstracción y su implementación
- Tanto las abstracciones como sus implementaciones deben ser extensibles mediante subclases
- Los cambios en la implementación de una abstracción no deben tener impacto en los clientes
- Quieres ocultar completamente la implementación de una abstracción de los clientes
- Tienes una proliferación de clases
- Quieres compartir una implementación entre múltiples objetos y este hecho debe estar oculto del cliente","use-case bridge structural","Structural","151"
"What are the key participants in the Bridge pattern?","- Abstraction: Defines the abstraction's interface and maintains a reference to an object of type Implementor
- RefinedAbstraction: Extends the interface defined by Abstraction
- Implementor: Defines the interface for implementation classes. This interface doesn't have to correspond exactly to Abstraction's interface
- ConcreteImplementor: Implements the Implementor interface and defines its concrete implementation","¿Cuáles son los participantes clave en el patrón Bridge?","- Abstraction: Define la interfaz de la abstracción y mantiene una referencia a un objeto de tipo Implementor
- RefinedAbstraction: Extiende la interfaz definida por Abstraction
- Implementor: Define la interfaz para clases de implementación. Esta interfaz no tiene que corresponder exactamente a la interfaz de Abstraction
- ConcreteImplementor: Implementa la interfaz Implementor y define su implementación concreta","key-concepts bridge structural","Structural","151"
"What are the benefits and drawbacks of the Bridge pattern?","Benefits:
- Decoupling interface and implementation: Implementation not bound permanently to interface, can be configured at run-time
- Improved extensibility: Can extend Abstraction and Implementor hierarchies independently
- Hiding implementation details from clients

Drawbacks:
- Increased complexity: The pattern increases the number of classes in the design","¿Cuáles son los beneficios y desventajas del patrón Bridge?","Beneficios:
- Desacoplamiento de interfaz e implementación: La implementación no está vinculada permanentemente a la interfaz, se puede configurar en tiempo de ejecución
- Extensibilidad mejorada: Puedes extender las jerarquías de Abstraction e Implementor independientemente
- Ocultar detalles de implementación de los clientes

Desventajas:
- Mayor complejidad: El patrón aumenta el número de clases en el diseño","benefits-drawbacks bridge structural","Structural","151"
"What patterns are related to the Bridge pattern?","- Abstract Factory: Can create and configure a particular Bridge
- Adapter: Adapter makes unrelated classes work together, usually applied after design. Bridge is used up-front to let abstractions and implementations vary independently","¿Qué patrones están relacionados con el patrón Bridge?","- Abstract Factory: Puede crear y configurar un Bridge particular
- Adapter: Adapter hace que clases no relacionadas trabajen juntas, generalmente se aplica después del diseño. Bridge se usa desde el principio para permitir que abstracciones e implementaciones varíen independientemente","related-patterns bridge structural","Structural","151"
"void Window::DrawRect(const Point& p1, const Point& p2) {
    WindowImp* imp = GetWindowImp();
    imp->DeviceRect(p1.X(), p1.Y(), p2.X(), p2.Y());
}","Pattern: Bridge
Key elements: Window abstraction delegates to WindowImp implementor for platform-specific drawing operations, decoupling abstraction from implementation","void Window::DrawRect(const Point& p1, const Point& p2) {
    WindowImp* imp = GetWindowImp();
    imp->DeviceRect(p1.X(), p1.Y(), p2.X(), p2.Y());
}","Patrón: Bridge
Elementos clave: La abstracción Window delega al implementador WindowImp para operaciones de dibujo específicas de la plataforma, desacoplando la abstracción de la implementación","code-example bridge structural cpp","Structural","151"
"What are key implementation considerations for the Bridge pattern?","- Only one Implementor: Even with only one implementation, creating an abstract Implementor class isn't necessary (degenerate case)
- Creating the right Implementor object: Options include Abstraction instantiating one, delegating to factory, or choosing default initially
- Sharing implementors: Can use Counted Pointer idiom with reference counting when implementors can be shared","¿Cuáles son las consideraciones clave de implementación para el patrón Bridge?","- Solo un Implementor: Incluso con solo una implementación, crear una clase Implementor abstracta no es necesario (caso degenerado)
- Crear el objeto Implementor correcto: Las opciones incluyen que Abstraction instancie uno, delegar a una fábrica, o elegir uno predeterminado inicialmente
- Compartir implementadores: Se puede usar el idioma Counted Pointer con conteo de referencias cuando los implementadores pueden compartirse","implementation bridge structural","Structural","151"
"What is the intent of the Composite pattern?","Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.","¿Cuál es la intención del patrón Composite?","Componer objetos en estructuras de árbol para representar jerarquías parte-todo. Composite permite a los clientes tratar objetos individuales y composiciones de objetos de manera uniforme.","intent composite structural","Structural","163"
"When would you use the Composite pattern?","- You want to represent part-whole hierarchies of objects
- You want clients to be able to ignore the difference between compositions of objects and individual objects. Clients will treat all objects in the composite structure uniformly","¿Cuándo usarías el patrón Composite?","- Quieres representar jerarquías parte-todo de objetos
- Quieres que los clientes puedan ignorar la diferencia entre composiciones de objetos y objetos individuales. Los clientes tratarán todos los objetos en la estructura compuesta de manera uniforme","use-case composite structural","Structural","163"
"What are the key participants in the Composite pattern?","- Component: Declares the interface for objects in the composition and implements default behavior. Declares an interface for accessing and managing its child components
- Leaf: Represents leaf objects in the composition. A leaf has no children and defines behavior for primitive objects
- Composite: Defines behavior for components having children, stores child components, and implements child-related operations
- Client: Manipulates objects in the composition through the Component interface","¿Cuáles son los participantes clave en el patrón Composite?","- Component: Declara la interfaz para objetos en la composición. Implementa comportamiento predeterminado. Declara interfaz para acceder y gestionar sus componentes hijos
- Leaf: Representa objetos hoja en la composición. Una hoja no tiene hijos. Define comportamiento para objetos primitivos
- Composite: Define comportamiento para componentes que tienen hijos. Almacena componentes hijos. Implementa operaciones relacionadas con hijos en la interfaz Component
- Client: Manipula objetos en la composición a través de la interfaz Component","key-concepts composite structural","Structural","163"
"What are the benefits and drawbacks of the Composite pattern?","Benefits:
- Defines class hierarchies consisting of primitive objects and composite objects
- Makes the client simple: Clients can treat composite structures and individual objects uniformly
- Makes it easier to add new kinds of components: Newly defined Composite or Leaf subclasses work automatically with existing structures

Drawbacks:
- Can make your design overly general: Makes it harder to restrict the components of a composite. Must use run-time checks instead of type system","¿Cuáles son los beneficios y desventajas del patrón Composite?","Beneficios:
- Define jerarquías de clases consistiendo en objetos primitivos y objetos compuestos
- Hace al cliente simple - los clientes pueden tratar estructuras compuestas y objetos individuales de manera uniforme
- Facilita agregar nuevos tipos de componentes

Desventajas:
- Puede hacer tu diseño demasiado general - difícil restringir los componentes de un compuesto
- Puede requerir verificaciones en tiempo de ejecución en lugar de confiar en el sistema de tipos","benefits-drawbacks composite structural","Structural","163"
"What patterns are related to the Composite pattern?","- Chain of Responsibility: Component-parent link is often used for a Chain of Responsibility
- Decorator: Often used with Composite. When used together, they will usually have a common parent class
- Flyweight: Lets you share components, but they can no longer refer to their parents
- Iterator: Can be used to traverse composites
- Visitor: Localizes operations and behavior that would otherwise be distributed across Composite and Leaf classes","¿Qué patrones están relacionados con el patrón Composite?","- Chain of Responsibility: A menudo se aplica junto con Composite. Los componentes padre pueden actuar como sucesores
- Decorator: A menudo se usa con Composite. Cuando decoradores y compuestos se usan juntos, generalmente tendrán una clase padre común
- Flyweight: Permite compartir componentes, pero ya no pueden referirse a sus padres
- Iterator: Se puede usar para recorrer compuestos
- Visitor: Localiza operaciones y comportamiento que de otro modo estarían distribuidos entre clases Composite y Leaf","related-patterns composite structural","Structural","163"
"Currency CompositeEquipment::NetPrice() {
    Iterator<Equipment*>* i = CreateIterator();
    Currency total = 0;
    for (i->First(); !i->IsDone(); i->Next()) {
        total += i->CurrentItem()->NetPrice();
    }
    delete i;
    return total;
}","Pattern: Composite
Key elements: CompositeEquipment computes its total price by iterating over child Equipment objects and summing their NetPrice(), treating leaves and composites uniformly","class Equipment {
public:
    virtual Watt Power();
    virtual Currency NetPrice();
    virtual void Add(Equipment*);
    virtual Iterator<Equipment*>* CreateIterator();
};","Patrón: Composite
Elementos clave: Clase Component base que define operaciones tanto para hojas como para compuestos. Incluye operaciones de gestión de hijos (Add, CreateIterator) y operaciones de negocio (Power, NetPrice)","code-example composite structural cpp","Structural","163"
"What are key implementation considerations for the Composite pattern?","- Explicit parent references: Simplify traversal and management of composite structure
- Sharing components: Difficult because component can have no more than one parent. Flyweight pattern can help
- Maximizing the Component interface: Define as many common operations as possible for Composite and Leaf classes
- Declaring child management operations: Trade-off between safety (only in Composite) and transparency (in Component)
- Child ordering: Design child access and management interfaces carefully when ordering matters
- Caching to improve performance: Cache traversal or search information
- Who should delete components: Usually best to make Composite responsible","¿Cuáles son las consideraciones clave de implementación para el patrón Composite?","- Referencias explícitas al padre: Mantener referencias de componentes hijos a padres puede simplificar el recorrido y la gestión de la estructura compuesta
- Compartir componentes: Flyweight puede ayudar con el intercambio cuando se necesita (componentes sin punteros padre)
- Maximizar la interfaz Component: Hacer la interfaz Component lo más amplia posible permite que los clientes no sepan si están tratando con hojas o compuestos
- Declarar operaciones de gestión de hijos: ¿En Component o Composite? Tradeoff entre seguridad y transparencia
- Component debería implementar una lista de componentes hijos? Depende del equilibrio transparencia vs eficiencia de espacio
- Orden de los hijos: Si importante, diseñar interfaces de acceso y gestión de hijos cuidadosamente
- Caché para mejorar el rendimiento: Mantener información atravesada/calculada sobre hijos
- ¿Quién debería eliminar componentes? Mejor hacerlo en Composite con excepciones cuando es responsabilidad externa
- ¿Cuál es la mejor estructura de datos para almacenar componentes? Depende de eficiencia: listas enlazadas, árboles, arreglos, tablas hash","implementation composite structural","Structural","163"
"What is the intent of the Decorator pattern?","Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.","¿Cuál es la intención del patrón Decorator?","Adjuntar responsabilidades adicionales a un objeto dinámicamente. Los decoradores proporcionan una alternativa flexible a la creación de subclases para extender funcionalidad.","intent decorator structural","Structural","175"
"When would you use the Decorator pattern?","- To add responsibilities to individual objects dynamically and transparently, that is, without affecting other objects
- For responsibilities that can be withdrawn
- When extension by subclassing is impractical. Sometimes a large number of independent extensions are possible and would produce an explosion of subclasses to support every combination","¿Cuándo usarías el patrón Decorator?","- Para agregar responsabilidades a objetos individuales de manera dinámica y transparente, sin afectar a otros objetos
- Para responsabilidades que se pueden retirar
- Cuando la extensión mediante creación de subclases es imprácticable. A veces, un gran número de extensiones independientes es posible y produciría una explosión de subclases. O una definición de clase puede estar oculta o no disponible para la creación de subclases","use-case decorator structural","Structural","175"
"What are the key participants in the Decorator pattern?","- Component: Defines the interface for objects that can have responsibilities added to them dynamically
- ConcreteComponent: Defines an object to which additional responsibilities can be attached
- Decorator: Maintains a reference to a Component object and defines an interface that conforms to Component's interface
- ConcreteDecorator: Adds responsibilities to the component","¿Cuáles son los participantes clave en el patrón Decorator?","- Component: Define la interfaz para objetos que pueden tener responsabilidades agregadas dinámicamente
- ConcreteComponent: Define un objeto al que se pueden adjuntar responsabilidades adicionales
- Decorator: Mantiene una referencia a un objeto Component y define una interfaz que se ajusta a la interfaz de Component
- ConcreteDecorator: Agrega responsabilidades al componente","key-concepts decorator structural","Structural","175"
"What are the benefits and drawbacks of the Decorator pattern?","Benefits:
- More flexibility than static inheritance: Responsibilities can be added and removed at run-time
- Avoids feature-laden classes high up in the hierarchy: Pay-as-you-go approach to adding responsibilities
- A decorator and its component aren't identical: From object identity point of view, decorated component is not identical to the component itself

Drawbacks:
- Lots of little objects: Design results in systems composed of lots of little objects that all look alike, can be hard to learn and debug","¿Cuáles son los beneficios y desventajas del patrón Decorator?","Beneficios:
- Más flexibilidad que la herencia estática - se pueden agregar y eliminar responsabilidades en tiempo de ejecución
- Evita clases cargadas de características en lo alto de la jerarquía - puedes agregar funcionalidad incrementalmente
- Un decorador y su componente no son idénticos - un decorador actúa como un proxy transparente

Desventajas:
- Muchos objetos pequeños - un diseño que usa Decorator a menudo resulta en sistemas compuestos por muchos objetos pequeños similares
- Decorator cambia la piel del objeto, no las entrañas - para cambiar el comportamiento interno, considera Strategy","benefits-drawbacks decorator structural","Structural","175"
"What patterns are related to the Decorator pattern?","- Adapter: A decorator only changes an object's responsibilities, not its interface; an adapter gives an object a completely new interface
- Composite: A decorator can be viewed as a degenerate composite with only one component. However, decorator adds additional responsibilities—it isn't intended for object aggregation
- Strategy: A decorator lets you change the skin of an object; a strategy lets you change the guts","¿Qué patrones están relacionados con el patrón Decorator?","- Adapter: Un decorador es diferente de un adaptador: un decorador solo cambia las responsabilidades de un objeto, no su interfaz. Un adaptador dará a un objeto una interfaz completamente nueva
- Composite: Un decorador puede verse como un compuesto degenerado con un solo componente. Sin embargo, un decorador agrega responsabilidades adicionales - no está destinado a la agregación de objetos
- Strategy: Un decorador te permite cambiar la piel de un objeto; una estrategia te permite cambiar las entrañas. Estas son dos formas alternativas de cambiar un objeto","related-patterns decorator structural","Structural","175"
"void BorderDecorator::Draw() {
    Decorator::Draw();
    DrawBorder(_width);
}","Pattern: Decorator
Key elements: BorderDecorator first calls Decorator::Draw() to draw the component, then adds border drawing on top, dynamically adding visual responsibility","void BorderDecorator::Draw() {
    VisualComponent::Draw();
    DrawBorder(_width);
}","Patrón: Decorator
Elementos clave: BorderDecorator extiende el comportamiento de VisualComponent llamando primero al método Draw() del componente, luego agregando su propia funcionalidad de dibujo de borde","code-example decorator structural cpp","Structural","175"
"What are key implementation considerations for the Decorator pattern?","- Interface conformance: A decorator object's interface must conform to the interface of the component it decorates
- Omitting the abstract Decorator class: No need when only adding one responsibility
- Keeping Component classes lightweight: Focus on defining an interface, not on storing data. Defer data representation to subclasses
- Changing the skin vs. changing the guts: Decorator changes skin. Strategy pattern is good for changing the guts","¿Cuáles son las consideraciones clave de implementación para el patrón Decorator?","- Conformidad de interfaz: La interfaz del decorador debe ajustarse a la del componente que decora
- Omitir la clase abstracta Decorator: No necesitas definir una clase abstracta Decorator cuando solo necesitas agregar una responsabilidad
- Mantener las clases Component ligeras: Para asegurar la intercambiabilidad, el componente y decorador deben descender de una clase Component ligera que se enfoca en definir una interfaz, no almacenar datos
- Cambiar la piel de un objeto vs cambiar sus entrañas: Decorator cambia el exterior. Strategy es buena para cambiar las entrañas","implementation decorator structural","Structural","175"
"What is the intent of the Facade pattern?","Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.","¿Cuál es la intención del patrón Facade?","Proporcionar una interfaz unificada a un conjunto de interfaces en un subsistema. Facade define una interfaz de nivel superior que hace que el subsistema sea más fácil de usar.","intent facade structural","Structural","185"
"When would you use the Facade pattern?","- You want to provide a simple interface to a complex subsystem
- There are many dependencies between clients and the implementation classes of an abstraction. Introduce a facade to decouple the subsystem from clients and other subsystems
- You want to layer your subsystems. Use a facade to define an entry point to each subsystem level","¿Cuándo usarías el patrón Facade?","- Quieres proporcionar una interfaz simple a un subsistema complejo. Los subsistemas a menudo se vuelven más complejos a medida que evolucionan. La mayoría de los patrones, cuando se aplican, resultan en clases más pequeñas y más numerosas. Una fachada puede proporcionar una vista simple predeterminada que es suficiente para la mayoría de los clientes
- Hay muchas dependencias entre clientes y clases de implementación de una abstracción. Introduce una fachada para desacoplar el subsistema de los clientes y otros subsistemas
- Quieres estructurar tus subsistemas en capas. Usa una fachada para definir un punto de entrada a cada nivel de subsistema","use-case facade structural","Structural","185"
"What are the key participants in the Facade pattern?","- Facade: Knows which subsystem classes are responsible for a request and delegates client requests to appropriate subsystem objects
- Subsystem classes: Implement subsystem functionality, handle work assigned by the Facade object, and have no knowledge of the facade; that is, they keep no references to it","¿Cuáles son los participantes clave en el patrón Facade?","- Facade: Conoce qué clases de subsistema son responsables de una solicitud. Delega solicitudes de clientes a objetos de subsistema apropiados
- Subsystem classes: Implementan funcionalidad del subsistema. Manejan el trabajo asignado por el objeto Facade. No tienen conocimiento de la fachada; es decir, no mantienen referencias a ella","key-concepts facade structural","Structural","185"
"What are the benefits and drawbacks of the Facade pattern?","Benefits:
- Shields clients from subsystem components, reducing the number of objects clients deal with
- Promotes weak coupling between the subsystem and its clients
- Doesn't prevent applications from using subsystem classes if they need to

Drawbacks:
- The facade may become a god object coupled to all classes of an application if not designed carefully","¿Cuáles son los beneficios y desventajas del patrón Facade?","Beneficios:
- Protege a los clientes de componentes del subsistema, reduciendo el número de objetos con los que los clientes tratan
- Promueve acoplamiento débil entre el subsistema y sus clientes
- No impide que las aplicaciones usen clases de subsistema si lo necesitan - puedes elegir entre facilidad de uso y generalidad

Desventajas:
- Puede convertirse en un objeto divino acoplado a todas las clases de una aplicación si no se tiene cuidado","benefits-drawbacks facade structural","Structural","185"
"What patterns are related to the Facade pattern?","- Abstract Factory: Can be used with Facade to provide an interface for creating subsystem objects in a subsystem-independent way. Can also be used as alternative to hide platform-specific classes
- Mediator: Similar to Facade in abstracting functionality, but Mediator abstracts arbitrary communication between colleague objects. Colleagues are aware of mediator. Facade merely abstracts interface and subsystem classes don't know about it
- Singleton: Usually only one Facade object is required. Thus Facade objects are often Singletons","¿Qué patrones están relacionados con el patrón Facade?","- Abstract Factory: Puede usarse con Facade para proporcionar una interfaz para crear objetos de subsistema de manera independiente del subsistema
- Mediator: Es similar a Facade en que abstrae funcionalidad de clases existentes. Sin embargo, el propósito de Mediator es abstraer comunicación arbitraria entre objetos colegas. Centraliza funcionalidad que no pertenece a ningún colega. Los colegas conocen al mediador y se comunican con él. En contraste, una fachada simplemente abstrae la interfaz a objetos de subsistema
- Singleton: A menudo solo se necesita un objeto Facade, por lo que los objetos Facade suelen ser Singletons","related-patterns facade structural","Structural","185"
"void Compiler::Compile(istream& input, BytecodeStream& output) {
    Scanner scanner(input);
    ProgramNodeBuilder builder;
    Parser parser;
    parser.Parse(scanner, builder);
    RISCCodeGenerator generator(output);
    ProgramNode* parseTree = builder.GetRootNode();
    parseTree->Traverse(generator);
}","Pattern: Facade
Key elements: Compiler facade provides simple Compile() interface that coordinates Scanner, Parser, ProgramNodeBuilder, and CodeGenerator subsystem classes","class Compiler {
public:
    Compiler();
    virtual void Compile(istream&, BytecodeStream&);
};","Patrón: Facade
Elementos clave: La clase Compiler proporciona una interfaz simple de alto nivel (método Compile) que oculta la complejidad del subsistema del compilador que incluye Scanner, Parser, ProgramNodeBuilder, etc.","code-example facade structural cpp","Structural","185"
"What are key implementation considerations for the Facade pattern?","- Reducing client-subsystem coupling: Make Facade an abstract class with concrete subclasses for different implementations. Keeps clients from knowing which implementation is used
- Public versus private subsystem classes: Public interface consists of classes all clients can access; private interface is just for subsystem extenders","¿Cuáles son las consideraciones clave de implementación para el patrón Facade?","- Reducir acoplamiento cliente-subsistema: Hacer que Facade sea una clase abstracta con subclases concretas para diferentes implementaciones de un subsistema. Entonces los clientes se comunican con el subsistema a través de la interfaz definida por la clase Facade abstracta
- Clases de subsistema públicas vs privadas: Un subsistema es análogo a una clase: ambos tienen interfaces y ambos encapsulan algo. La interfaz pública de un subsistema consiste en clases a las que todos los clientes pueden acceder; la interfaz privada es solo para desarrolladores de subsistemas","implementation facade structural","Structural","185"
"What is the intent of the Flyweight pattern?","Use sharing to support large numbers of fine-grained objects efficiently.","¿Cuál es la intención del patrón Flyweight?","Usar compartición para soportar eficientemente grandes cantidades de objetos de grano fino.","intent flyweight structural","Structural","195"
"When would you use the Flyweight pattern?","- An application uses a large number of objects
- Storage costs are high because of the sheer quantity of objects
- Most object state can be made extrinsic
- Many groups of objects may be replaced by relatively few shared objects once extrinsic state is removed
- The application doesn't depend on object identity. Since flyweight objects may be shared, identity tests will return true for conceptually distinct objects","¿Cuándo usarías el patrón Flyweight?","La efectividad del patrón Flyweight depende mucho de cómo y dónde se usa. Aplica el patrón Flyweight cuando se cumplan TODAS las siguientes condiciones:
- Una aplicación usa un gran número de objetos
- Los costos de almacenamiento son altos debido a la gran cantidad de objetos
- La mayoría del estado del objeto se puede hacer extrínseco
- Muchos grupos de objetos pueden ser reemplazados por relativamente pocos objetos compartidos una vez que se elimine el estado extrínseco
- La aplicación no depende de la identidad del objeto","use-case flyweight structural","Structural","195"
"What are the key participants in the Flyweight pattern?","- Flyweight: Declares an interface through which flyweights can receive and act on extrinsic state
- ConcreteFlyweight: Implements the Flyweight interface and adds storage for intrinsic state, if any. Must be sharable
- UnsharedConcreteFlyweight: Not all Flyweight subclasses need to be shared. Interface enables sharing but doesn't enforce it
- FlyweightFactory: Creates and manages flyweight objects and ensures that flyweights are shared properly
- Client: Maintains a reference to flyweight(s) and computes or stores the extrinsic state of flyweight(s)","¿Cuáles son los participantes clave en el patrón Flyweight?","- Flyweight: Declara una interfaz a través de la cual los flyweights pueden recibir y actuar sobre estado extrínseco
- ConcreteFlyweight: Implementa la interfaz Flyweight y agrega almacenamiento para estado intrínseco. Un objeto ConcreteFlyweight debe ser compartible. Cualquier estado que almacene debe ser intrínseco
- UnsharedConcreteFlyweight: No todos los objetos Flyweight necesitan ser compartidos. La interfaz Flyweight permite compartir pero no lo impone
- FlyweightFactory: Crea y gestiona objetos flyweight. Asegura que los flyweights se compartan apropiadamente
- Client: Mantiene una referencia a flyweight(s). Calcula o almacena el estado extrínseco de flyweight(s)","key-concepts flyweight structural","Structural","195"
"What are the benefits and drawbacks of the Flyweight pattern?","Benefits:
- Storage savings increase as more flyweights are shared
- Storage savings increase with the amount of shared state
- Greatest savings occur when objects use substantial quantities of both intrinsic and extrinsic state, and extrinsic state can be computed rather than stored

Drawbacks:
- Flyweights may introduce run-time costs associated with transferring, finding, and/or computing extrinsic state, especially if it was formerly stored as intrinsic state","¿Cuáles son los beneficios y desventajas del patrón Flyweight?","Beneficios:
- Ahorros de almacenamiento - función de: reducción en el número total de instancias, cantidad de estado intrínseco por objeto, si el estado extrínseco se calcula o almacena

Desventajas:
- Los flyweights pueden introducir costos de tiempo de ejecución asociados con transferir, encontrar y/o calcular estado extrínseco
- El código se vuelve más complejo","benefits-drawbacks flyweight structural","Structural","195"
"What patterns are related to the Flyweight pattern?","- Composite: Flyweight pattern is often combined with Composite to represent a hierarchical structure as a graph with shared leaf nodes
- State and Strategy: State and Strategy objects are often best implemented as flyweights","¿Qué patrones están relacionados con el patrón Flyweight?","- Composite: A menudo se combina con Composite para implementar una estructura de gráfico jerárquico logística como un grafo acíclico dirigido con nodos hoja compartidos
- State y Strategy: Los objetos de estrategia a menudo son buenos flyweights
- Flyweight explica cuándo y cómo se pueden compartir objetos State","related-patterns flyweight structural","Structural","195"
"Character* GlyphFactory::CreateCharacter(char c) {
    if (!_character[c]) {
        _character[c] = new Character(c);
    }
    return _character[c];
}","Pattern: Flyweight
Key elements: GlyphFactory ensures Character flyweights are shared - returns existing instance if available, creates new one only if needed, managing shared objects","class Glyph {
public:
    virtual void Draw(Window*, GlyphContext&);
    virtual void SetFont(Font*, GlyphContext&);
    virtual Font* GetFont(GlyphContext&);
};","Patrón: Flyweight
Elementos clave: Los objetos Glyph son flyweights compartidos. GlyphContext almacena estado extrínseco (fuente, posición). Los métodos Draw y SetFont toman GlyphContext como parámetro para acceder al estado extrínseco","code-example flyweight structural cpp","Structural","195"
"What are key implementation considerations for the Flyweight pattern?","- Removing extrinsic state: Pattern's applicability is determined by how easy it is to identify extrinsic state and remove it from shared objects
- Managing shared objects: FlyweightFactory lets clients locate flyweights, often uses associative store. Sharing implies reference counting or garbage collection
- Intrinsic state: Character codes are intrinsic. Other information like font, size may be extrinsic depending on document structure","¿Cuáles son las consideraciones clave de implementación para el patrón Flyweight?","- Eliminar estado extrínseco: El patrón se aplica mejor cuando los objetos usan sustancial estado tanto intrínseco como extrínseco, y el estado extrínseco se puede calcular en lugar de almacenar
- Gestionar objetos compartidos: Dado que los objetos son compartidos, los clientes no deben instanciarlos directamente. FlyweightFactory permite a los clientes localizar un flyweight particular. A menudo usa una estructura de datos asociativa para permitir búsqueda de flyweights
- FlyweightFactory puede usar Singleton para hacer la fábrica accesible globalmente
- Los objetos compartidos deben ser inmutables o manejar cuidadosamente la mutabilidad para prevenir efectos secundarios no deseados","implementation flyweight structural","Structural","195"
"What is the intent of the Proxy pattern?","Provide a surrogate or placeholder for another object to control access to it.","¿Cuál es la intención del patrón Proxy?","Proporcionar un sustituto o marcador de posición para otro objeto para controlar el acceso a él.","intent proxy structural","Structural","207"
"When would you use the Proxy pattern?","- A remote proxy provides a local representative for an object in a different address space
- A virtual proxy creates expensive objects on demand
- A protection proxy controls access to the original object. Protection proxies are useful when objects should have different access rights
- A smart reference is a replacement for a bare pointer that performs additional actions when an object is accessed","¿Cuándo usarías el patrón Proxy?","El patrón Proxy es aplicable siempre que haya necesidad de una referencia más versátil o sofisticada a un objeto que un simple puntero. Aquí hay varias situaciones comunes:
- Proxy remoto: Proporciona un representante local para un objeto en un espacio de direcciones diferente
- Proxy virtual: Crea objetos costosos bajo demanda
- Proxy de protección: Controla el acceso al objeto original. Útil cuando los objetos deben tener diferentes derechos de acceso
- Referencia inteligente: Es un reemplazo para un puntero desnudo que realiza acciones adicionales cuando se accede a un objeto (contar referencias, bloquear, verificar, cargar bajo demanda)","use-case proxy structural","Structural","207"
"What are the key participants in the Proxy pattern?","- Proxy: Maintains a reference that lets the proxy access the real subject. Provides an interface identical to Subject's so that a proxy can be substituted for the real subject. Controls access to the real subject
- Subject: Defines the common interface for RealSubject and Proxy so that a Proxy can be used anywhere a RealSubject is expected
- RealSubject: Defines the real object that the proxy represents","¿Cuáles son los participantes clave en el patrón Proxy?","- Proxy: Mantiene una referencia que permite al proxy acceder al sujeto real. Proporciona una interfaz idéntica a Subject para que el proxy pueda sustituir al sujeto real. Controla el acceso al sujeto real y puede ser responsable de crear y eliminar el sujeto
- Subject: Define la interfaz común para RealSubject y Proxy para que un Proxy pueda usarse donde sea que se espere un RealSubject
- RealSubject: Define el objeto real que el proxy representa","key-concepts proxy structural","Structural","207"
"What are the benefits and drawbacks of the Proxy pattern?","Benefits:
- A remote proxy can hide the fact that an object resides in a different address space
- A virtual proxy can perform optimizations such as creating an object on demand
- Both protection proxies and smart references allow additional housekeeping tasks when an object is accessed

Drawbacks:
- The proxy pattern can introduce a level of indirection that may impact performance
- Some proxy types may be language-specific (like copy-on-write)","¿Cuáles son los beneficios y desventajas del patrón Proxy?","Beneficios:
- Proxy remoto puede ocultar el hecho de que un objeto reside en un espacio de direcciones diferente
- Proxy virtual puede realizar optimizaciones como crear un objeto bajo demanda
- Proxies de protección y referencias inteligentes permiten tareas de mantenimiento adicionales cuando se accede a un objeto
- Copy-on-write: Retrasa la copia de un objeto hasta que un cliente realmente lo modifica (optimización relacionada con creación bajo demanda)

Desventajas:
- Introduce otro nivel de indirección que puede afectar el rendimiento
- Agrega complejidad al código","benefits-drawbacks proxy structural","Structural","207"
"What patterns are related to the Proxy pattern?","- Adapter: An adapter provides a different interface to the object it adapts. In contrast, a proxy provides the same interface as its subject
- Decorator: Although decorators can have similar implementations as proxies, decorators have a different purpose. A decorator adds one or more responsibilities to an object, whereas a proxy controls access to an object","¿Qué patrones están relacionados con el patrón Proxy?","- Adapter: Un adaptador proporciona una interfaz diferente al objeto que adapta. En contraste, un proxy proporciona la misma interfaz que su sujeto. Sin embargo, un proxy usado para control de acceso podría negarse a realizar una operación que el sujeto realizará
- Decorator: Aunque los decoradores pueden tener implementaciones similares a los proxies, los decoradores tienen un propósito diferente. Un decorador agrega una o más responsabilidades a un objeto, mientras que un proxy controla el acceso a un objeto","related-patterns proxy structural","Structural","207"
"void ImageProxy::Draw(const Point& at) {
    GetImage()->Draw(at);
}

Image* ImageProxy::GetImage() {
    if (_image == 0) {
        _image = new Image(_fileName);
    }
    return _image;
}","Pattern: Proxy
Key elements: ImageProxy delays loading the actual Image from file until Draw() is called, implementing virtual proxy for lazy initialization of expensive objects","class ImageProxy : public Graphic {
public:
    ImageProxy(const char* imageFile);
    virtual void Draw(const Point& at);
    virtual void GetExtent(Point& extent);
protected:
    Image* GetImage();
private:
    Image* _image;
    Extent _extent;
    char* _fileName;
};","Patrón: Proxy
Elementos clave: Proxy virtual - ImageProxy pospone la creación de la Image costosa hasta que realmente se necesita en Draw(). Mantiene información mínima (_extent, _fileName) hasta que el objeto real se carga","code-example proxy structural cpp","Structural","207"
"What are key implementation considerations for the Proxy pattern?","- Overloading the member access operator in C++: Makes it possible to mimic pointer dereferencing syntax seamlessly, but depends on knowing object's type at compile-time
- Using doesNotUnderstand in Smalltalk: Can be used to support automatic forwarding of requests
- Proxy doesn't always have to know the type of real subject: If Proxy can deal with subject solely through abstract interface, there's no need to make Proxy class for each RealSubject class","¿Cuáles son las consideraciones clave de implementación para el patrón Proxy?","- Sobrecarga de operadores en C++: Sobrecargar el operador -> permite que los proxies se comporten como punteros reales, accediendo transparentemente al objeto real
- Usar directivas 'using' en C++: Permite importar selectivamente nombres de clases en el ámbito del proxy
- Proxy no siempre necesita conocer el tipo del sujeto real: Si un proxy puede tratar con su sujeto solo a través de una interfaz abstracta, entonces no necesita conocer subclases concretas
- Copy-on-write: Implementación de referencias inteligentes que solo copia cuando se modifica","implementation proxy structural","Structural","207"
"What is the intent of the Chain of Responsibility pattern?","Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.","¿Cuál es la intención del patrón Chain of Responsibility?","Evitar acoplar el emisor de una solicitud a su receptor dando a más de un objeto la oportunidad de manejar la solicitud. Encadenar los objetos receptores y pasar la solicitud a lo largo de la cadena hasta que un objeto la maneje.","intent chain-of-responsibility behavioral","Behavioral","223"
"When would you use the Chain of Responsibility pattern?","- More than one object may handle a request, and the handler isn't known a priori. The handler should be ascertained automatically
- You want to issue a request to one of several objects without specifying the receiver explicitly
- The set of objects that can handle a request should be specified dynamically","¿Cuándo usarías el patrón Chain of Responsibility?","- Más de un objeto puede manejar una solicitud, y el manejador no se conoce a priori. El manejador debería determinarse automáticamente
- Quieres emitir una solicitud a uno de varios objetos sin especificar el receptor explícitamente
- El conjunto de objetos que puede manejar una solicitud debe especificarse dinámicamente","use-case chain-of-responsibility behavioral","Behavioral","223"
"What are the key participants in the Chain of Responsibility pattern?","- Handler: Defines an interface for handling requests and optionally implements the successor link
- ConcreteHandler: Handles requests it is responsible for. Can access its successor. If the ConcreteHandler can handle the request, it does so; otherwise it forwards the request to its successor
- Client: Initiates the request to a ConcreteHandler object on the chain","¿Cuáles son los participantes clave en el patrón Chain of Responsibility?","- Handler: Define una interfaz para manejar solicitudes. (opcional) Implementa el enlace del sucesor
- ConcreteHandler: Maneja las solicitudes de las que es responsable. Puede acceder a su sucesor. Si el ConcreteHandler puede manejar la solicitud, lo hace; de lo contrario, la reenvía a su sucesor
- Client: Inicia la solicitud a un objeto ConcreteHandler en la cadena","key-concepts chain-of-responsibility behavioral","Behavioral","223"
"What are the benefits and drawbacks of the Chain of Responsibility pattern?","Benefits:
- Reduced coupling: The pattern frees an object from knowing which other object handles a request. Both the receiver and the sender have no explicit knowledge of each other
- Added flexibility in assigning responsibilities to objects: You can add or change responsibilities for handling a request by adding to or otherwise changing the chain at run-time

Drawbacks:
- Receipt isn't guaranteed: Since a request has no explicit receiver, there's no guarantee it'll be handled—the request can fall off the end of the chain without ever being handled","¿Cuáles son los beneficios y desventajas del patrón Chain of Responsibility?","Beneficios:
- Acoplamiento reducido: El patrón libera a un objeto de tener que saber qué otro objeto maneja una solicitud
- Flexibilidad añadida en asignar responsabilidades a objetos: Puedes añadir o cambiar responsabilidades para manejar una solicitud cambiando la cadena en tiempo de ejecución

Desventajas:
- Recepción no garantizada: Dado que una solicitud no tiene un receptor explícito, no hay garantía de que se maneje - la solicitud puede caer al final de la cadena sin ser manejada
- Puede ser difícil observar las características en tiempo de ejecución y depurar","benefits-drawbacks chain-of-responsibility behavioral","Behavioral","223"
"What patterns are related to the Chain of Responsibility pattern?","- Composite: Chain of Responsibility is often applied in conjunction with Composite. There, a component's parent can act as its successor","¿Qué patrones están relacionados con el patrón Chain of Responsibility?","- Chain of Responsibility a menudo se aplica junto con Composite. Allí, el padre de un componente puede actuar como su sucesor","related-patterns chain-of-responsibility behavioral","Behavioral","223"
"void Button::HandleHelp() {
    if (HasHelp()) {
        // offer help on the button
    } else {
        HelpHandler::HandleHelp();
    }
}","Pattern: Chain of Responsibility
Key elements: Button checks if it has help for itself. If so, provides it; otherwise forwards the request to its successor in the chain via HelpHandler::HandleHelp()","void HelpHandler::HandleHelp() {
    if (_successor != 0) {
        _successor->HandleHelp();
    }
}","Patrón: Chain of Responsibility
Elementos clave: Implementación predeterminada de HandleHelp reenvía la solicitud al sucesor. Las subclases sobrescriben esto para proporcionar ayuda específica o pasar la solicitud si no pueden manejarla","code-example chain-of-responsibility behavioral cpp","Behavioral","223"
"What are key implementation considerations for the Chain of Responsibility pattern?","- Implementing the successor chain: Can define new links (usually in Handler) or use existing links like parent references
- Connecting successors: Handler usually maintains successor and defines the interface
- Representing requests: Can be hard-coded operation invocation (simple and safe), request code as parameter (supports open-ended set), or separate request objects","¿Cuáles son las consideraciones clave de implementación para el patrón Chain of Responsibility?","- Implementar la cadena de sucesores: Dos opciones: (a) Definir nuevos enlaces (generalmente en Handler pero ConcreteHandlers también podrían hacerlo), (b) Usar enlaces existentes (por ejemplo, enlaces padre en Composite)
- Conectar sucesores: Si no hay referencias predefinidas, tendrás que mantenerlas tú mismo. Handler podría definir una interfaz para acceder a un sucesor y cambiar el sucesor si se permite en tiempo de ejecución
- Representar solicitudes: Las opciones varían desde codificar fuertemente la operación (por ejemplo, HandleHelp) hasta usar un solo manejador con un código de solicitud. Este último es más flexible pero requiere un esquema de empaquetado y desempaquetado conveniente para parámetros","implementation chain-of-responsibility behavioral","Behavioral","223"
"Which patterns use the concept 'Encapsulation of Variation'?","Identify the aspects of your application that vary and separate them from what stays the same.

Patterns: Bridge (separates abstraction from implementation), Decorator (separates core functionality from optional enhancements), Flyweight (separates intrinsic from extrinsic state), Proxy (separates actual object from its surrogate), Adapter (separates incompatible interfaces)","Comparar Adapter vs Bridge","Similitudes:
- Ambos promueven flexibilidad desacoplando una interfaz de una implementación
- Ambos implican reenviar solicitudes desde una interfaz a otra

Diferencias:
- Adapter: Hace que dos interfaces existentes trabajen juntas (después del diseño). Se enfoca en la incompatibilidad de interfaces
- Bridge: Separa interfaz de implementación desde el principio (durante el diseño). Permite que varíen independientemente
- Adapter: Generalmente se aplica después de que el software está diseñado
- Bridge: Se usa desde el principio en el diseño
- Adapter: Principalmente cambia interfaz
- Bridge: Permite que tanto la abstracción como la implementación cambien sin afectarse mutuamente

Cuándo usar cada uno:
- Adapter: Cuando necesitas hacer que interfaces incompatibles trabajen juntas
- Bridge: Cuando quieres evitar un enlace permanente entre abstracción e implementación","cross-cutting encapsulation-of-variation","Cross-Cutting","137"
"Which patterns use the concept 'Composition over Inheritance'?","Favor object composition over class inheritance. Instead of inheriting behavior, objects compose their behavior from other objects.

Patterns: Composite, Decorator, Bridge, Adapter","Comparar Composite vs Decorator","Similitudes:
- Ambos tienen estructuras de clase similares basadas en composición recursiva
- Ambos implican ensamblar objetos en estructuras de árbol

Diferencias:
- Composite: Representa jerarquías parte-todo. Se enfoca en agrupar objetos primitivos y compuestos uniformemente
- Decorator: Agrega responsabilidades a objetos. Se enfoca en extender funcionalidad sin crear subclases
- Composite: Diseñado para estructurar objetos en árboles. Puede tener múltiples hijos
- Decorator: Diseñado para agregar responsabilidades dinámicamente. Típicamente tiene un solo componente hijo
- Composite: Los componentes conocen sus hijos. Se enfoca en relaciones estructurales
- Decorator: Los decoradores no saben sobre otros decoradores en la cadena. Se enfoca en extensión de responsabilidades

Cuándo usar cada uno:
- Composite: Cuando necesitas tratar objetos individuales y composiciones uniformemente
- Decorator: Cuando necesitas agregar responsabilidades a objetos individuales dinámicamente","cross-cutting composition-over-inheritance","Cross-Cutting","137"
"Which patterns use the concept 'Program to Interface not Implementation'?","Program to an interface, not an implementation. All structural patterns define abstract interfaces that hide implementation details. Clients interact through abstract interfaces, making the system more flexible and reusable.

Patterns: Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy","Comparar Decorator vs Proxy","Similitudes:
- Ambos tienen implementaciones similares - envuelven otro objeto
- Ambos reenvían solicitudes al objeto envuelto

Diferencias:
- Decorator: Agrega responsabilidades a un objeto. Se enfoca en extender funcionalidad
- Proxy: Controla el acceso a un objeto. Se enfoca en gestionar cuándo/cómo se accede al objeto
- Decorator: Los objetos pueden agregarse dinámicamente en tiempo de ejecución. Soporta composición recursiva de decoradores
- Proxy: Generalmente establecido en tiempo de construcción
- Decorator: El componente conoce a sus decoradores en cierta medida
- Proxy: El sujeto no es consciente de su proxy
- Decorator: Cambia lo que hace el objeto (agrega comportamiento)
- Proxy: Controla cómo se accede al objeto (carga diferida, permisos, etc.)

Cuándo usar cada uno:
- Decorator: Cuando necesitas agregar funcionalidad sin crear subclases
- Proxy: Cuando necesitas controlar el acceso a un objeto o gestionar su ciclo de vida","cross-cutting program-to-interface","Cross-Cutting","137"
"Which patterns use the concept 'Loose Coupling'?","Strive for loosely coupled designs between objects that interact.

Patterns: Facade (reduces coupling between clients and subsystems), Bridge (decouples abstraction from implementation), Chain of Responsibility (decouples senders from receivers), Proxy (controls access without tight coupling)","Comparar Facade vs Mediator","Similitudes:
- Ambos abstraen funcionalidad de clases existentes
- Ambos pueden simplificar interacciones complejas

Diferencias:
- Facade: Abstrae la interfaz a objetos de subsistema. Unidireccional, las clases del subsistema no conocen la fachada
- Mediator: Abstrae comunicación arbitraria entre objetos colegas. Bidireccional, los colegas conocen y se comunican con el mediador
- Facade: No agrega nueva funcionalidad
- Mediator: Centraliza funcionalidad que no pertenece a ningún colega

Cuándo usar cada uno:
- Facade: Cuando se proporciona una interfaz más simple a un subsistema
- Mediator: Cuando se centralizan comunicaciones complejas entre objetos","cross-cutting loose-coupling","Cross-Cutting","137"
"Which patterns use the concept 'Single Responsibility Principle'?","A class should have only one reason to change.

Patterns: Decorator (adds single responsibilities dynamically), Facade (provides a single, simplified interface), Proxy (controls access as a single responsibility)","¿Cuáles son usos incorrectos comunes del patrón Adapter?","- Usar adaptador cuando deberías rediseñar la interfaz desde el principio
- Sobreusar adaptadores bidireccionales que agregan complejidad
- Crear adaptadores para cada pequeña incompatibilidad de interfaz en lugar de estandarizar interfaces
- Usar adaptador de clase con herencia múltiple cuando el adaptador de objeto sería más limpio
- Olvidar que los adaptadores agregan un nivel de indirección que puede impactar el rendimiento","cross-cutting single-responsibility","Cross-Cutting","137"
"Which patterns use the concept 'Transparency'?","Making interfaces uniform so clients can treat objects polymorphically.

Patterns: Composite (makes individual objects and compositions uniform), Decorator (makes decorated and undecorated objects interchangeable), Flyweight (shared and unshared objects have same interface)","¿Cuáles son usos incorrectos comunes del patrón Composite?","- Hacer el diseño demasiado general cuando necesitas restringir tipos de componentes
- No usar verificaciones en tiempo de ejecución para hacer cumplir restricciones de composición cuando el sistema de tipos no puede ayudar
- Almacenar punteros de hijos en la clase Component base para todos los nodos, desperdiciando memoria en nodos hoja
- No considerar el patrón Flyweight cuando el uso de memoria de las referencias padre se vuelve excesivo
- Implementar operaciones de gestión de hijos en Component cuando la seguridad es más importante que la transparencia","cross-cutting transparency","Cross-Cutting","137"
"Which patterns use the concept 'Recursive Composition'?","Building complex structures from simpler ones through composition.

Patterns: Composite (exemplifies this with part-whole hierarchies), Decorator (supports recursive wrapping of objects)","¿Cuáles son usos incorrectos comunes del patrón Decorator?","- Crear demasiados objetos decoradores pequeños que hacen el sistema difícil de entender y depurar
- Depender de la identidad del objeto cuando se usan decoradores (el objeto decorado no es idéntico al componente)
- No mantener la interfaz Component ligera, haciendo el patrón más difícil de usar
- Usar decoradores cuando el patrón Strategy sería mejor para cambiar el comportamiento interno
- Olvidar que los decoradores cambian la piel pero no las entrañas de los objetos","cross-cutting recursive-composition","Cross-Cutting","137"
"Which patterns use the concept 'Forwarding/Delegation'?","One object forwarding requests to another object.

Patterns: Proxy (forwards to RealSubject), Decorator (forwards to wrapped Component), Adapter (forwards to Adaptee), Bridge (forwards from Abstraction to Implementor), Chain of Responsibility (forwards along chain)","¿Cuáles son usos incorrectos comunes del patrón Flyweight?","- Usar flyweight cuando la mayor parte del estado del objeto no puede hacerse extrínseco
- No considerar los costos en tiempo de ejecución de transferir, encontrar o calcular estado extrínseco
- Usar flyweight cuando la aplicación depende de la identidad del objeto
- No usar FlyweightFactory, permitiendo que los clientes creen flyweights duplicados
- Olvidar el conteo de referencias o la recolección de basura para objetos compartidos","cross-cutting delegation","Cross-Cutting","137"
"Which patterns use the concept 'Lazy Initialization'?","Deferring object creation until needed.

Patterns: Proxy (virtual proxy creates expensive objects on demand), Flyweight (shares objects to reduce memory usage)","¿Cuáles son usos incorrectos comunes del patrón Chain of Responsibility?","- No asegurar que al menos un manejador pueda manejar la solicitud (la recepción no está garantizada)
- Crear cadenas que son demasiado largas, impactando el rendimiento
- No configurar la cadena apropiadamente, causando que las solicitudes caigan al final
- Usar cadena cuando necesitas manejo garantizado y deberías usar Command u otro patrón en su lugar
- Hacer difícil observar y entender las características en tiempo de ejecución de la cadena","cross-cutting lazy-initialization","Cross-Cutting","137"
"Which patterns use the concept 'Indirection'?","Introducing an intermediate layer to solve problems. All structural patterns introduce some level of indirection.

Patterns: Adapter (converts interfaces), Proxy (provides a surrogate), Decorator (adds responsibilities), Bridge (separates interface from implementation), Facade (provides simplified interface), Flyweight (manages shared objects)","¿Cuáles son ejemplos del mundo real del patrón Adapter?","- InterViews UI toolkit: La clase Composition adapta hijos Component simples a padres Component más complejos
- Unidraw drawing editor framework: GraphicBlock adapta un Graphic a la interfaz Block orientada al diseño
- ET++: Clase adaptadora TextShape para reutilizar clases de edición de texto
- ObjectWorks/Smalltalk: PluggableAdaptor adapta objetos a la interfaz ValueModel","cross-cutting indirection","Cross-Cutting","137"
"Compare Adapter vs Bridge","Similarities:
- Both have similar structure with one object delegating to another
- Both involve interface abstraction

Differences:
- Adapter: Changes the interface of an existing object, usually applied after design
- Bridge: Separates interface from implementation, used up-front in design to let both vary independently

When to use each:
- Adapter: When you need to make incompatible interfaces work together
- Bridge: When you want abstraction and implementation to vary independently from the start","¿Cuáles son ejemplos del mundo real del patrón Bridge?","- libg++ class library: Abstracción Window con implementación XWindow para el Sistema X Window
- InterViews UI toolkit: Abstracción Glyph con diferentes implementaciones concretas para diferentes estándares de apariencia (Motif, Presentation Manager, OpenLook)
- ET++: Diseño Window/WindowPort para independencia de plataforma","comparison adapter bridge","Comparison","139"
"Compare Decorator vs Adapter","Similarities:
- Both wrap an existing object
- Both can modify behavior

Differences:
- Decorator: Only changes object's responsibilities, not its interface. More transparent to the application
- Adapter: Gives an object a completely new interface
- Decorator: Supports recursive composition
- Adapter: Does not support recursion

When to use each:
- Decorator: When adding responsibilities while keeping the same interface
- Adapter: When converting one interface to another","¿Cuáles son ejemplos del mundo real del patrón Composite?","- InterViews toolkit: Clase base Glyph para componentes visuales. Los Glyphs pueden contener otros glyphs
- RTL Smalltalk compiler framework: Los árboles de análisis de programas son estructuras compuestas
- Aplicaciones de gestión de cartera financiera: Activos individuales y agregados de activos tratados uniformemente
- Smalltalk Model/View/Controller: La clase View era un Composite
- Casi todos los toolkits de UI: VObjects de ET++, Styles y Graphics de InterViews","comparison decorator adapter","Comparison","175"
"Compare Decorator vs Composite","Similarities:
- Both have similar recursive structure
- Often used together, usually with common parent class
- Both can contain other components

Differences:
- Decorator: Degenerate composite with only one component. Adds additional responsibilities
- Composite: Can have many children. Intended for object aggregation

When to use each:
- Decorator: When dynamically adding responsibilities to individual objects
- Composite: When representing part-whole hierarchies and treating objects uniformly","¿Cuáles son ejemplos del mundo real del patrón Decorator?","- InterViews UI toolkit: Las subclases decoradoras MonoGlyph Border, Scroller agregan bordes y desplazamiento a componentes glyph
- ET++ application framework: Clases VBorder y VScroller para desplazamiento y bordes
- Smalltalk-80 Streams: Decoradores Stream para compresión, cifrado, filtrado
- InterViews: DebuggingGlyph imprime información de depuración antes/después de reenviar
- ParcPlace Smalltalk: PassivityWrapper habilita/deshabilita interacciones de usuario","comparison decorator composite","Comparison","175"
"Compare Decorator vs Strategy","Similarities:
- Both allow changing object behavior
- Both provide alternatives to subclassing

Differences:
- Decorator: Changes the skin of an object (external behavior)
- Strategy: Changes the guts of an object (internal algorithm)
- Decorator: Wraps the object
- Strategy: Object contains strategy

When to use each:
- Decorator: When adding external responsibilities or behaviors
- Strategy: When changing internal algorithms or behaviors","¿Cuáles son ejemplos del mundo real del patrón Facade?","- ET++ application framework: Clases fachada de nivel superior simplifican tareas comunes en el subsistema
- Choices operating system: FileSystemFacade proporciona una interfaz de alto nivel para operaciones del sistema de archivos
- ObjectWorks/Smalltalk: El sistema Compiler usa la fachada Compiler
- ET++: Fachada ProgrammingEnvironment para herramientas de navegación integradas","comparison decorator strategy","Comparison","175"
"Compare Proxy vs Decorator","Similarities:
- Both have similar implementations (wrap another object)
- Both forward requests to wrapped object

Differences:
- Proxy: Controls access to an object
- Decorator: Adds one or more responsibilities to an object
- Proxy: Usually manages lifecycle of subject
- Decorator: Client manages component creation

When to use each:
- Proxy: When controlling access, lazy loading, or managing remote objects
- Decorator: When dynamically adding responsibilities","¿Cuáles son ejemplos del mundo real del patrón Flyweight?","- InterViews 3.0 Doc editor: Usa objetos glyph como flyweights para caracteres - 180,000 caracteres requirieron solo 480 objetos de caracteres
- ET++: Usa flyweights para independencia de apariencia - Los objetos Layout son flyweights que definen el diseño y comportamiento de dibujo de widgets
- Editores de documentos: Objetos de caracteres compartidos con estado de formato extrínseco
- Implementaciones de cadenas: Muchas comparten almacenamiento de caracteres mediante copy-on-write","comparison proxy decorator","Comparison","207"
"Compare Proxy vs Adapter","Similarities:
- Both wrap another object
- Both can modify how clients interact with object

Differences:
- Proxy: Provides the same interface as its subject
- Adapter: Provides a different interface to the object it adapts
- Proxy: Usually doesn't change interface
- Adapter: Explicitly converts between interfaces

When to use each:
- Proxy: When controlling access while maintaining interface
- Adapter: When making incompatible interfaces work together","¿Cuáles son ejemplos del mundo real del patrón Proxy?","- CORBA, Java RMI: Proxies remotos para sistemas de objetos distribuidos
- Smalltalk-80 ObjectProxy: Proporciona una réplica exacta de la interfaz del objeto remoto
- NEXTSTEP: La clase NXProxy forma la base del sistema de objetos distribuidos. Proporciona representantes locales para objetos que pueden estar distribuidos
- McCullough and Schmucker: Proxy de adquisición perezosa convierte identificador de objeto en referencia de objeto real
- ET++: Las clases de bloques de construcción de texto usan proxy virtual","comparison proxy adapter","Comparison","207"
"Compare Facade vs Mediator","Similarities:
- Both abstract functionality of existing classes
- Both can simplify complex interactions

Differences:
- Facade: Abstracts interface to subsystem objects. Unidirectional, subsystem classes don't know about facade
- Mediator: Abstracts arbitrary communication between colleague objects. Bidirectional, colleagues are aware of and communicate with mediator
- Facade: Doesn't add new functionality
- Mediator: Centralizes functionality that doesn't belong in any one colleague

When to use each:
- Facade: When providing simpler interface to subsystem
- Mediator: When centralizing complex communications between objects","¿Cuáles son ejemplos del mundo real del patrón Chain of Responsibility?","- ET++ application framework: Chain of responsibility para ayuda sensible al contexto
- Unidraw framework: Cadena para manejar eventos de interfaz de usuario
- MacApp y Borland ObjectWindows: Cadenas de manejo de eventos","comparison facade mediator","Comparison","185"
"What is the intent of the Chain of Responsibility pattern?","Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.","¿Cuál es el propósito del patrón Chain of Responsibility?","Evitar el acoplamiento del emisor de una solicitud con su receptor dando a más de un objeto la oportunidad de manejar la solicitud. Encadenar los objetos receptores y pasar la solicitud a lo largo de la cadena hasta que un objeto la maneje.","intent chain-of-responsibility behavioral","Behavioral","223"
"When would you use the Chain of Responsibility pattern?","• More than one object may handle a request, and the handler isn't known a priori
• You want to issue a request to one of several objects without specifying the receiver explicitly
• The set of objects that can handle a request should be specified dynamically","¿Cuándo usarías el patrón Chain of Responsibility?","• Más de un objeto puede manejar una solicitud, y el manejador no se conoce a priori
• Quieres emitir una solicitud a uno de varios objetos sin especificar el receptor explícitamente
• El conjunto de objetos que pueden manejar una solicitud debe especificarse dinámicamente","use-case chain-of-responsibility behavioral","Behavioral","223"
"What are the key participants in the Chain of Responsibility pattern?","• Handler: Defines an interface for handling requests and optionally implements the successor link
• ConcreteHandler: Handles requests it is responsible for; can access its successor; if it can handle the request, it does so; otherwise it forwards the request to its successor
• Client: Initiates the request to a ConcreteHandler object on the chain","¿Cuáles son los participantes clave en el patrón Chain of Responsibility?","• Handler: Define una interfaz para manejar solicitudes y opcionalmente implementa el enlace al sucesor
• ConcreteHandler: Maneja las solicitudes de las que es responsable; puede acceder a su sucesor; si puede manejar la solicitud, lo hace; de lo contrario, reenvía la solicitud a su sucesor
• Client: Inicia la solicitud a un objeto ConcreteHandler en la cadena","key-concepts chain-of-responsibility behavioral","Behavioral","223"
"What are the benefits and drawbacks of the Chain of Responsibility pattern?","Benefits:
• Reduced coupling - frees an object from knowing which other object handles a request
• Added flexibility in assigning responsibilities to objects

Drawbacks:
• Receipt isn't guaranteed - a request can fall off the end of the chain without being handled
• Can be hard to observe the runtime characteristics and debug","¿Cuáles son los beneficios y desventajas del patrón Chain of Responsibility?","Beneficios:
• Acoplamiento reducido - libera a un objeto de saber qué otro objeto maneja una solicitud
• Mayor flexibilidad al asignar responsabilidades a objetos

Desventajas:
• No se garantiza la recepción - una solicitud puede caerse del final de la cadena sin ser manejada
• Puede ser difícil observar las características en tiempo de ejecución y depurar","benefits-drawbacks chain-of-responsibility behavioral","Behavioral","223"
"What patterns are related to the Chain of Responsibility pattern?","• Composite: Often used together with Chain of Responsibility to allow components to act as handlers in a chain","¿Qué patrones están relacionados con el patrón Chain of Responsibility?","• Composite: A menudo se usa junto con Chain of Responsibility para permitir que los componentes actúen como manejadores en una cadena","related-patterns chain-of-responsibility behavioral","Behavioral","223"
"What are key implementation considerations for the Chain of Responsibility pattern?","• Implementing the successor chain - can be defined in Handler or by ConcreteHandlers
• Representing requests - can range from hard-coded operation invocations to a separate request object
• Automatic forwarding in Smalltalk - can use doesNotUnderstand mechanism","¿Cuáles son las consideraciones clave de implementación para el patrón Chain of Responsibility?","• Implementar la cadena de sucesores - puede definirse en Handler o por ConcreteHandlers
• Representar solicitudes - puede variar desde invocaciones de operaciones codificadas hasta un objeto de solicitud separado
• Reenvío automático en Smalltalk - puede usar el mecanismo doesNotUnderstand","implementation chain-of-responsibility behavioral","Behavioral","223"
"What are real-world examples of the Chain of Responsibility pattern?","• ET++ uses Chain of Responsibility to handle graphical update
• Unidraw framework uses it for dispatching commands
• Context-sensitive help facilities in GUIs
• Event bubbling in DOM (browser event handling)","¿Cuáles son ejemplos del mundo real del patrón Chain of Responsibility?","• ET++ usa Chain of Responsibility para manejar actualizaciones gráficas
• El framework Unidraw lo usa para despachar comandos
• Facilidades de ayuda contextual en GUIs
• Propagación de eventos en DOM (manejo de eventos del navegador)","real-world chain-of-responsibility behavioral","Behavioral","223"
"What is the intent of the Command pattern?","Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.","¿Cuál es el propósito del patrón Command?","Encapsular una solicitud como un objeto, permitiendo así parametrizar clientes con diferentes solicitudes, poner en cola o registrar solicitudes, y soportar operaciones reversibles.","intent command behavioral","Behavioral","233"
"When would you use the Command pattern?","• Parameterize objects by an action to perform (alternative to callbacks)
• Specify, queue, and execute requests at different times
• Support undo - Command's Execute operation can store state for reversing its effects
• Support logging changes so they can be reapplied in case of a system crash
• Structure a system around high-level operations built on primitives operations","¿Cuándo usarías el patrón Command?","• Parametrizar objetos por una acción a realizar (alternativa a callbacks)
• Especificar, poner en cola y ejecutar solicitudes en diferentes momentos
• Soportar deshacer - la operación Execute de Command puede almacenar estado para revertir sus efectos
• Soportar registro de cambios para que puedan reaplicarse en caso de fallo del sistema
• Estructurar un sistema alrededor de operaciones de alto nivel construidas sobre operaciones primitivas","use-case command behavioral","Behavioral","233"
"What are the key participants in the Command pattern?","• Command: Declares an interface for executing an operation
• ConcreteCommand: Defines a binding between a Receiver object and an action; implements Execute by invoking the corresponding operations on Receiver
• Client: Creates a ConcreteCommand object and sets its receiver
• Invoker: Asks the command to carry out the request
• Receiver: Knows how to perform the operations associated with carrying out a request","¿Cuáles son los participantes clave en el patrón Command?","• Command: Declara una interfaz para ejecutar una operación
• ConcreteCommand: Define un vínculo entre un objeto Receiver y una acción; implementa Execute invocando las operaciones correspondientes en Receiver
• Client: Crea un objeto ConcreteCommand y establece su receptor
• Invoker: Le pide al comando que lleve a cabo la solicitud
• Receiver: Sabe cómo realizar las operaciones asociadas con llevar a cabo una solicitud","key-concepts command behavioral","Behavioral","233"
"What are the benefits and drawbacks of the Command pattern?","Benefits:
• Command decouples the object that invokes the operation from the one that knows how to perform it
• Commands are first-class objects - they can be manipulated and extended like any other object
• You can assemble commands into a composite command
• It's easy to add new Commands because you don't have to change existing classes

Drawbacks:
• Can result in lots of trivial command subclasses","¿Cuáles son los beneficios y desventajas del patrón Command?","Beneficios:
• Command desacopla el objeto que invoca la operación del que sabe cómo realizarla
• Los comandos son objetos de primera clase - pueden manipularse y extenderse como cualquier otro objeto
• Puedes ensamblar comandos en un comando compuesto
• Es fácil agregar nuevos Commands porque no tienes que cambiar clases existentes

Desventajas:
• Puede resultar en muchas subclases de comando triviales","benefits-drawbacks command behavioral","Behavioral","233"
"What patterns are related to the Command pattern?","• Composite: Can be used to implement MacroCommands
• Memento: Can keep state the command requires to undo its effect
• Prototype: A command that must be copied before being placed on the history list acts as a Prototype","¿Qué patrones están relacionados con el patrón Command?","• Composite: Puede usarse para implementar MacroCommands
• Memento: Puede mantener el estado que el comando requiere para deshacer su efecto
• Prototype: Un comando que debe copiarse antes de colocarse en la lista de historial actúa como un Prototype","related-patterns command behavioral","Behavioral","233"
"What are key implementation considerations for the Command pattern?","• How intelligent should a command be - can range from merely defining a binding between receiver and actions to implementing everything itself
• Supporting undo and redo - requires storing additional state (history list, Memento pattern)
• Avoiding error accumulation in the undo process - use Memento to give Command access to receiver state
• Using C++ templates - can avoid creating Command subclasses for simple commands","¿Cuáles son las consideraciones clave de implementación para el patrón Command?","• Qué tan inteligente debe ser un comando - puede variar desde simplemente definir un vínculo entre receptor y acciones hasta implementar todo por sí mismo
• Soportar deshacer y rehacer - requiere almacenar estado adicional (lista de historial, patrón Memento)
• Evitar acumulación de errores en el proceso de deshacer - usar Memento para dar acceso a Command al estado del receptor
• Usar plantillas de C++ - puede evitar crear subclases de Command para comandos simples","implementation command behavioral","Behavioral","233"
"What are real-world examples of the Command pattern?","• ET++ MenuItems - each is a Command subclass instance
• InterViews command-based text editor with undo/redo
• Unidraw framework - commands support undo/redo and unlimited-level undo
• MacApp and Bedrock frameworks use Command pattern
• GUI button actions and menu items
• Transaction-based systems","¿Cuáles son ejemplos del mundo real del patrón Command?","• MenuItems de ET++ - cada uno es una instancia de subclase de Command
• Editor de texto basado en comandos de InterViews con deshacer/rehacer
• Framework Unidraw - los comandos soportan deshacer/rehacer y deshacer de nivel ilimitado
• Los frameworks MacApp y Bedrock usan el patrón Command
• Acciones de botones GUI e ítems de menú
• Sistemas basados en transacciones","real-world command behavioral","Behavioral","233"
"What is the intent of the Interpreter pattern?","Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.","¿Cuál es el propósito del patrón Interpreter?","Dado un lenguaje, definir una representación para su gramática junto con un intérprete que use la representación para interpretar oraciones en el lenguaje.","intent interpreter behavioral","Behavioral","243"
"When would you use the Interpreter pattern?","• The grammar is simple - for complex grammars, the class hierarchy becomes large and unmanageable
• Efficiency is not a critical concern - the most efficient interpreters are usually not implemented by interpreting parse trees directly","¿Cuándo usarías el patrón Interpreter?","• Cuando hay un lenguaje a interpretar y puedes representar declaraciones en el lenguaje como árboles sintácticos abstractos
• La gramática es simple - para gramáticas complejas, la jerarquía de clases se vuelve inmanejable
• La eficiencia no es una preocupación crítica","use-case interpreter behavioral","Behavioral","243"
"What are the key participants in the Interpreter pattern?","• AbstractExpression: Declares an abstract Interpret operation common to all nodes in the abstract syntax tree
• TerminalExpression: Implements an Interpret operation associated with terminal symbols in the grammar
• NonterminalExpression: One such class is required for every rule in the grammar; maintains instance variables of type AbstractExpression for each symbol; implements Interpret by calling Interpret on each subexpression
• Context: Contains information that's global to the interpreter
• Client: Builds (or is given) an abstract syntax tree representing a particular sentence in the language; invokes the Interpret operation","¿Cuáles son los participantes clave en el patrón Interpreter?","• AbstractExpression: Declara una operación Interpret abstracta común a todos los nodos en el árbol sintáctico abstracto
• TerminalExpression: Implementa una operación Interpret asociada con símbolos terminales en la gramática
• NonterminalExpression: Se necesita una clase para cada regla en la gramática; mantiene variables de instancia de tipo AbstractExpression
• Context: Contiene información global para el intérprete
• Client: Construye el árbol sintáctico abstracto e invoca la operación Interpret","key-concepts interpreter behavioral","Behavioral","243"
"What are the benefits and drawbacks of the Interpreter pattern?","Benefits:
• It's easy to change and extend the grammar - can use inheritance to change or extend the grammar
• Implementing the grammar is easy - classes defining nodes in the abstract syntax tree have similar implementations

Drawbacks:
• Complex grammars are hard to maintain - the Interpreter pattern defines at least one class for every rule in the grammar, making it hard to manage","¿Cuáles son los beneficios y desventajas del patrón Interpreter?","Beneficios:
• Es fácil cambiar y extender la gramática
• Implementar la gramática es fácil - las clases que definen nodos en el árbol sintáctico abstracto tienen implementaciones similares
• Agregar nuevas formas de interpretar expresiones es fácil

Desventajas:
• Gramáticas complejas son difíciles de mantener - la jerarquía de clases se vuelve grande e inmanejable
• Puede ser menos eficiente que otras técnicas de análisis","benefits-drawbacks interpreter behavioral","Behavioral","243"
"What patterns are related to the Interpreter pattern?","• Composite: The abstract syntax tree is an instance of the Composite pattern
• Flyweight: Shows how to share terminal symbols within the abstract syntax tree
• Iterator: The interpreter can use an Iterator to traverse the structure
• Visitor: Can be used to maintain the behavior in each node in one class","¿Qué patrones están relacionados con el patrón Interpreter?","• Composite: El árbol sintáctico abstracto es una instancia del patrón Composite
• Flyweight: Muestra cómo compartir símbolos terminales dentro del árbol sintáctico abstracto
• Iterator: El intérprete puede usar un Iterator para recorrer la estructura
• Visitor: Puede usarse para mantener el comportamiento en cada nodo en el árbol sintáctico abstracto en una clase","related-patterns interpreter behavioral","Behavioral","243"
"What are key implementation considerations for the Interpreter pattern?","• Creating the abstract syntax tree - the Interpreter pattern doesn't explain how to create it (can use parser)
• Defining the Interpret operation - don't have to define it in the expression classes if many different interpretations are needed
• Sharing terminal symbols with the Flyweight pattern - when grammar has many terminals, Flyweight can reduce storage","¿Cuáles son las consideraciones clave de implementación para el patrón Interpreter?","• Crear el árbol sintáctico abstracto - el patrón Interpreter no explica cómo crear un árbol sintáctico abstracto (considera usar un analizador)
• Definir la operación Interpret - no tienes que definir la operación Interpret en la clase de expresión; puede usar Visitor en su lugar
• Compartir símbolos terminales con Flyweight - especialmente útil cuando una oración contiene muchas instancias de un símbolo terminal","implementation interpreter behavioral","Behavioral","243"
"What are real-world examples of the Interpreter pattern?","• Compiler front-ends often use Interpreter pattern for parsing and evaluating expressions
• Regular expression matchers
• SQL query interpreters
• Mathematical expression evaluators","¿Cuáles son ejemplos del mundo real del patrón Interpreter?","• Compiladores e intérpretes de lenguajes de programación
• Evaluadores de expresiones regulares
• Evaluadores de expresiones SQL
• Procesadores de lenguajes de consulta
• Analizadores de fórmulas matemáticas","real-world interpreter behavioral","Behavioral","243"
"What is the intent of the Iterator pattern?","Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.","¿Cuál es el propósito del patrón Iterator?","Proporcionar una forma de acceder a los elementos de un objeto agregado secuencialmente sin exponer su representación subyacente.","intent iterator behavioral","Behavioral","257"
"When would you use the Iterator pattern?","• To access an aggregate object's contents without exposing its internal representation
• To support multiple traversals of aggregate objects
• To provide a uniform interface for traversing different aggregate structures (polymorphic iteration)","¿Cuándo usarías el patrón Iterator?","• Para acceder al contenido de un objeto agregado sin exponer su representación interna
• Para soportar múltiples recorridos de objetos agregados
• Para proporcionar una interfaz uniforme para recorrer diferentes estructuras agregadas (es decir, para soportar iteración polimórfica)","use-case iterator behavioral","Behavioral","257"
"What are the key participants in the Iterator pattern?","• Iterator: Defines an interface for accessing and traversing elements
• ConcreteIterator: Implements the Iterator interface; keeps track of the current position in the traversal
• Aggregate: Defines an interface for creating an Iterator object
• ConcreteAggregate: Implements the Iterator creation interface to return an instance of the proper ConcreteIterator","¿Cuáles son los participantes clave en el patrón Iterator?","• Iterator: Define una interfaz para acceder y recorrer elementos
• ConcreteIterator: Implementa la interfaz Iterator; lleva registro de la posición actual en el recorrido del agregado
• Aggregate: Define una interfaz para crear un objeto Iterator
• ConcreteAggregate: Implementa la interfaz de creación de Iterator para devolver una instancia del ConcreteIterator apropiado","key-concepts iterator behavioral","Behavioral","257"
"What are the benefits and drawbacks of the Iterator pattern?","Benefits:
• It supports variations in the traversal of an aggregate
• Iterators simplify the Aggregate interface
• More than one traversal can be pending on an aggregate

Drawbacks:
• Adding new traversal operations may require changing the iterator interface","¿Cuáles son los beneficios y desventajas del patrón Iterator?","Beneficios:
• Soporta variaciones en el recorrido de un agregado
• Los iteradores simplifican la interfaz Aggregate
• Puede haber más de un recorrido pendiente en un agregado

Desventajas:
• Puede requerir acceso privilegiado a la estructura interna del agregado
• Agregar nuevas operaciones de recorrido requiere extender la interfaz Iterator","benefits-drawbacks iterator behavioral","Behavioral","257"
"What patterns are related to the Iterator pattern?","• Composite: Iterators are often applied to recursive structures such as Composites
• Factory Method: Polymorphic iterators rely on factory methods to instantiate the appropriate Iterator subclass
• Memento: Can be used in conjunction with the Iterator pattern for capturing iteration state","¿Qué patrones están relacionados con el patrón Iterator?","• Composite: Los iteradores a menudo se aplican a estructuras recursivas como Composite
• Factory Method: Los iteradores polimórficos dependen de métodos de fábrica para instanciar la subclase de iterador apropiada
• Memento: Puede usarse junto con el patrón Iterator para capturar el estado de una iteración","related-patterns iterator behavioral","Behavioral","257"
"What are key implementation considerations for the Iterator pattern?","• Who controls the iteration - external iterator (client) vs internal iterator (iterator itself)
• Who defines the traversal algorithm - iterator or aggregate
• How robust is the iterator - is it safe to modify the aggregate during traversal
• Additional Iterator operations - Previous, SkipTo, etc.
• Using polymorphic iterators in C++ - require dynamic allocation and deallocation
• Iterators may have privileged access - can be made friends of their aggregate
• Iterators for composites - external vs internal iterators for complex structures
• Null iterators - degenerate iterator that's always done with traversal","¿Cuáles son las consideraciones clave de implementación para el patrón Iterator?","• ¿Quién controla la iteración? - Iterador externo (cliente controla) vs. iterador interno (iterador controla)
• ¿Quién define el algoritmo de recorrido? - el iterador o el agregado
• Qué tan robusto es el iterador - ¿es seguro modificar el agregado durante el recorrido?
• Operaciones de iterador adicionales - pueden ser útiles operaciones como Previous, SkipTo
• Usar iteradores polimórficos en C++ - requiere que el iterador se asigne dinámicamente
• Iteradores con privilegios - el iterador puede necesitar acceso privilegiado al agregado","implementation iterator behavioral","Behavioral","257"
"What are real-world examples of the Iterator pattern?","• Booch components - provide fixed set of iterators for each collection
• ET++ iterators work only on Composite structures and are tied to specific aggregate classes
• InterViews - polymorphic Cursor-based iterator for traversing object structures
• ObjectWindows library uses TListIterator for LISP-style access
• Java Collections Framework Iterator
• Python's iterator protocol
• C++ STL iterators","¿Cuáles son ejemplos del mundo real del patrón Iterator?","• Biblioteca de plantillas estándar de C++ (STL) - extenso uso de iteradores
• Enumeradores de Java
• Iteradores de colecciones de Python
• Enumerables de .NET
• Cursores de base de datos","real-world iterator behavioral","Behavioral","257"
"What is the intent of the Mediator pattern?","Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.","¿Cuál es el propósito del patrón Mediator?","Definir un objeto que encapsule cómo interactúa un conjunto de objetos. Mediator promueve el acoplamiento débil al evitar que los objetos se refieran entre sí explícitamente, y te permite variar su interacción independientemente.","intent mediator behavioral","Behavioral","273"
"When would you use the Mediator pattern?","• A set of objects communicate in well-defined but complex ways
• Reusing an object is difficult because it refers to and communicates with many other objects
• A behavior distributed between several classes should be customizable without a lot of subclassing","¿Cuándo usarías el patrón Mediator?","• Un conjunto de objetos se comunica de formas bien definidas pero complejas, resultando en interdependencias no estructuradas y difíciles de entender
• Reutilizar un objeto es difícil porque se refiere y se comunica con muchos otros objetos
• Un comportamiento que está distribuido entre varias clases debe ser personalizable sin mucha creación de subclases","use-case mediator behavioral","Behavioral","273"
"What are the key participants in the Mediator pattern?","• Mediator: Defines an interface for communicating with Colleague objects
• ConcreteMediator: Implements cooperative behavior by coordinating Colleague objects; knows and maintains its colleagues
• Colleague classes: Each Colleague class knows its Mediator object; each colleague communicates with its mediator whenever it would have otherwise communicated with another colleague","¿Cuáles son los participantes clave en el patrón Mediator?","• Mediator: Define una interfaz para comunicarse con objetos Colleague
• ConcreteMediator: Implementa el comportamiento cooperativo coordinando objetos Colleague; conoce y mantiene a sus colegas
• Colleague classes: Cada clase Colleague conoce su objeto Mediator; cada colega se comunica con su mediador cuando de otro modo se habría comunicado con otro colega","key-concepts mediator behavioral","Behavioral","273"
"What are the benefits and drawbacks of the Mediator pattern?","Benefits:
• It limits subclassing - localizes behavior that would otherwise be distributed
• It decouples colleagues - promotes loose coupling between colleagues
• It simplifies object protocols - replaces many-to-many interactions with one-to-many
• It abstracts how objects cooperate - can vary interaction independently
• It centralizes control - trades complexity of interaction for complexity in the mediator

Drawbacks:
• The mediator can become monolithic and hard to maintain","¿Cuáles son los beneficios y desventajas del patrón Mediator?","Beneficios:
• Limita la creación de subclases - el Mediator localiza el comportamiento que de otro modo estaría distribuido entre varios objetos
• Desacopla colegas - promueve el acoplamiento débil entre colegas
• Simplifica los protocolos de objetos - reemplaza las interacciones muchos-a-muchos con interacciones uno-a-muchos
• Abstrae cómo cooperan los objetos - centralizando el control

Desventajas:
• Puede centralizar el control - el mediador mismo puede volverse un monolito complejo","benefits-drawbacks mediator behavioral","Behavioral","273"
"What patterns are related to the Mediator pattern?","• Facade: Differs from Mediator in that it abstracts a subsystem to provide a simpler interface (unidirectional vs bidirectional)
• Observer: Colleagues can communicate with the mediator using the Observer pattern","¿Qué patrones están relacionados con el patrón Mediator?","• Facade: Abstrae un subsistema para proporcionar una interfaz más conveniente, pero es unidireccional mientras Mediator es bidireccional
• Observer: Los colegas pueden comunicarse con el mediador usando el patrón Observer","related-patterns mediator behavioral","Behavioral","273"
"What are key implementation considerations for the Mediator pattern?","• Omitting the abstract Mediator class - when colleagues work with only one mediator
• Colleague-Mediator communication - can use Observer pattern for communication between colleagues and mediator","¿Cuáles son las consideraciones clave de implementación para el patrón Mediator?","• Omitir la clase abstracta Mediator - no hay necesidad cuando los colegas trabajan con un solo mediador
• Comunicación Colleague-Mediator - puede implementarse usando el patrón Observer para que el mediador actúe como Observer","implementation mediator behavioral","Behavioral","273"
"What are real-world examples of the Mediator pattern?","• ET++ - ChangeManager mediates consistency between UI elements and application data
• Smalltalk/V - application framework uses mediator-like approach
• Dialog boxes coordinating widget interactions
• Air traffic control systems
• Chat room servers coordinating messages between users","¿Cuáles son ejemplos del mundo real del patrón Mediator?","• Sistemas de diálogo GUI - widgets se comunican a través de un director de diálogo
• Torre de control de aeropuerto - coordina despegues y aterrizajes
• Salas de chat - mediador maneja mensajes entre usuarios
• Sistemas de automatización del hogar - hub central coordina dispositivos
• Controladores de juegos multijugador","real-world mediator behavioral","Behavioral","273"
"What is the intent of the Memento pattern?","Without violating encapsulation, capture and externalize an object's internal state so that the object can be restored to this state later.","¿Cuál es el propósito del patrón Memento?","Sin violar la encapsulación, capturar y externalizar el estado interno de un objeto para que el objeto pueda restaurarse a este estado posteriormente.","intent memento behavioral","Behavioral","283"
"When would you use the Memento pattern?","• A snapshot of an object's state must be saved so it can be restored later
• A direct interface to obtaining the state would expose implementation details and break the object's encapsulation","¿Cuándo usarías el patrón Memento?","• Una instantánea del estado de un objeto (o una porción de él) debe guardarse para que pueda restaurarse a ese estado posteriormente
• Una interfaz directa para obtener el estado expondría detalles de implementación y rompería la encapsulación del objeto","use-case memento behavioral","Behavioral","283"
"What are the key participants in the Memento pattern?","• Memento: Stores internal state of the Originator object; protects against access by objects other than the originator
• Originator: Creates a memento containing a snapshot of its current internal state; uses the memento to restore its internal state
• Caretaker: Is responsible for the memento's safekeeping; never operates on or examines the contents of a memento","¿Cuáles son los participantes clave en el patrón Memento?","• Memento: Almacena el estado interno del objeto Originator; protege contra acceso de objetos distintos al originator
• Originator: Crea un memento que contiene una instantánea de su estado interno actual; usa el memento para restaurar su estado interno
• Caretaker: Es responsable de salvaguardar el memento; nunca opera o examina el contenido de un memento","key-concepts memento behavioral","Behavioral","283"
"What are the benefits and drawbacks of the Memento pattern?","Benefits:
• Preserving encapsulation boundaries - avoids exposing internal state
• It simplifies Originator - keeping versions of internal state would burden the Originator

Drawbacks:
• Using mementos might be expensive - copying large amounts of state can be costly
• Defining narrow and wide interfaces - may be difficult in some languages to ensure only the originator can access the memento's state
• Hidden costs in caring for mementos - caretaker must track memento lifetime but doesn't know how much state is in the memento","¿Cuáles son los beneficios y desventajas del patrón Memento?","Beneficios:
• Preserva los límites de encapsulación - evita exponer información que solo un Originator debería manejar
• Simplifica Originator - mantener versiones del estado interno del Originator podría transferir complejidad al Caretaker

Desventajas:
• Usar mementos podría ser costoso - si el Originator debe copiar grandes cantidades de información o si los clientes crean y devuelven mementos al originator con frecuencia
• Definir interfaces estrechas y amplias puede ser difícil en algunos lenguajes
• Costos ocultos en cuidar mementos - un caretaker es responsable de eliminar los mementos que cuida","benefits-drawbacks memento behavioral","Behavioral","283"
"What patterns are related to the Memento pattern?","• Command: Commands can use mementos to maintain state for undoable operations
• Iterator: Mementos can be used for iteration state","¿Qué patrones están relacionados con el patrón Memento?","• Command: Los comandos pueden usar mementos para mantener el estado para operaciones deshacer
• Iterator: Los mementos pueden usarse para iteración como se describió anteriormente","related-patterns memento behavioral","Behavioral","283"
"What are key implementation considerations for the Memento pattern?","• Language support - Memento has two interfaces: wide (only Originator) and narrow (other objects). C++ friend mechanism can enforce this
• Storing incremental changes - if mementos are created frequently, storing only incremental changes can reduce storage costs","¿Cuáles son las consideraciones clave de implementación para el patrón Memento?","• Preservación de la encapsulación - usar interfaces 'amplias' y 'estrechas' con amigos en C++ u otras técnicas específicas del lenguaje
• Almacenar diferencias incrementales - si los mementos se crean frecuentemente, almacenar solo cambios incrementales","implementation memento behavioral","Behavioral","283"
"What are real-world examples of the Memento pattern?","• Unidraw drawing editor framework - uses Command and Memento patterns for unlimited-level undo/redo
• Text editor undo/redo mechanisms
• Database transaction rollback
• Game save states","¿Cuáles son ejemplos del mundo real del patrón Memento?","• Editor Qoca de restricciones usa Memento para soportar deshacer/rehacer
• Sistemas de deshacer/rehacer en editores de texto
• Características de guardar juegos
• Funcionalidad de volver atrás del navegador
• Mecanismos de rollback de transacciones de bases de datos","real-world memento behavioral","Behavioral","283"
"What is the intent of the Observer pattern?","Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.","¿Cuál es el propósito del patrón Observer?","Definir una dependencia de uno a muchos entre objetos de modo que cuando un objeto cambie de estado, todos sus dependientes sean notificados y actualizados automáticamente.","intent observer behavioral","Behavioral","293"
"When would you use the Observer pattern?","• When an abstraction has two aspects, one dependent on the other - encapsulating these in separate objects lets you vary and reuse them independently
• When a change to one object requires changing others, and you don't know how many objects need to be changed
• When an object should be able to notify other objects without making assumptions about who these objects are","¿Cuándo usarías el patrón Observer?","• Cuando una abstracción tiene dos aspectos, uno dependiente del otro. Encapsular estos aspectos en objetos separados te permite variarlos y reutilizarlos independientemente
• Cuando un cambio a un objeto requiere cambiar otros, y no sabes cuántos objetos necesitan cambiarse
• Cuando un objeto debe ser capaz de notificar a otros objetos sin hacer suposiciones sobre quiénes son estos objetos","use-case observer behavioral","Behavioral","293"
"What are the key participants in the Observer pattern?","• Subject: Knows its observers; provides an interface for attaching and detaching Observer objects
• Observer: Defines an updating interface for objects that should be notified of changes in a subject
• ConcreteSubject: Stores state of interest to ConcreteObserver objects; sends a notification to its observers when its state changes
• ConcreteObserver: Maintains a reference to a ConcreteSubject object; stores state that should stay consistent with the subject's; implements the Observer updating interface","¿Cuáles son los participantes clave en el patrón Observer?","• Subject: Conoce a sus observadores; cualquier número de objetos Observer pueden observar un subject; proporciona una interfaz para adjuntar y desconectar objetos Observer
• Observer: Define una interfaz de actualización para objetos que deben ser notificados de cambios en un subject
• ConcreteSubject: Almacena el estado de interés para los objetos ConcreteObserver; envía una notificación a sus observadores cuando su estado cambia
• ConcreteObserver: Mantiene una referencia a un objeto ConcreteSubject; almacena el estado que debe permanecer consistente con el del subject; implementa la interfaz de actualización de Observer","key-concepts observer behavioral","Behavioral","293"
"What are the benefits and drawbacks of the Observer pattern?","Benefits:
• Abstract coupling between Subject and Observer - subject doesn't know concrete class of observers
• Support for broadcast communication - notification is broadcast automatically

Drawbacks:
• Unexpected updates - a seemingly harmless operation can cause a cascade of updates
• Update overhead - observers don't know about each other and can't assess the cost of updates","¿Cuáles son los beneficios y desventajas del patrón Observer?","Beneficios:
• Acoplamiento abstracto entre Subject y Observer - el subject no conoce las clases concretas de sus observadores
• Soporte para comunicación de difusión - la notificación se envía automáticamente a todos los objetos interesados

Desventajas:
• Actualizaciones inesperadas - los observadores no tienen conocimiento de la presencia de otros y pueden estar ciegos al costo de cambiar el subject
• Puede provocar cascadas de actualizaciones - un pequeño cambio puede desencadenar múltiples actualizaciones","benefits-drawbacks observer behavioral","Behavioral","293"
"What patterns are related to the Observer pattern?","• Mediator: ChangeManager acts as mediator between subjects and observers
• Singleton: ChangeManager may use Singleton to make it unique and globally accessible","¿Qué patrones están relacionados con el patrón Observer?","• Mediator: Al encapsular semántica compleja de actualización, el ChangeManager actúa como mediador entre subjects y observers
• Singleton: El ChangeManager puede usar el patrón Singleton para hacerlo único y accesible globalmente","related-patterns observer behavioral","Behavioral","293"
"What are key implementation considerations for the Observer pattern?","• Mapping subjects to their observers - can use hash table or store directly in subject
• Observing more than one subject - observer may need to know which subject sent the notification
• Who triggers the update - subject or clients (trade-off between frequency and consistency)
• Dangling references to deleted subjects - subject should notify observers when it's deleted
• Making sure Subject state is self-consistent before notification - use template methods
• Avoiding observer-specific update protocols - push model vs pull model
• Specifying modifications of interest explicitly - extend subject's registration to include events of interest
• Encapsulating complex update semantics - ChangeManager to minimize work required to make observers consistent","¿Cuáles son las consideraciones clave de implementación para el patrón Observer?","• Mapeo de subjects a observers - puede usar tabla hash para mapeo, o almacenar referencias en subjects directamente
• Observar más de un subject - puede ser útil extender la interfaz de actualización para que el observer sepa qué subject envió la notificación
• Quién desencadena la actualización - hacer que los clients llamen a Notify después de cambiar el estado del subject, o hacer que el subject notifique automáticamente
• Referencias colgantes a subjects eliminados - asegurarse de que los observers liberen sus referencias cuando se elimina un subject
• Asegurar consistencia del estado del Subject antes de la notificación - usar plantilla de método en la clase Subject
• Evitar protocolos de actualización específicos del observador - modelos push y pull
• Especificar modificaciones de interés explícitamente - extender la interfaz de registro del subject para permitir aspectos de interés
• Encapsular semántica compleja de actualización - usar un objeto ChangeManager cuando la relación entre subjects y observers sea particularmente compleja","implementation observer behavioral","Behavioral","293"
"What are real-world examples of the Observer pattern?","• Smalltalk Model/View/Controller - Observer pattern defines dependencies between model and views
• ET++ - ChangeManager mediates complex dependencies between subjects and observers
• InterViews uses Observer pattern for maintaining consistency
• Event handling systems (DOM events, button clicks)
• MVC frameworks
• Reactive programming (RxJS, React state management)
• Pub/Sub systems","¿Cuáles son ejemplos del mundo real del patrón Observer?","• Smalltalk Model/View/Controller (MVC) - usa Observer
• Framework de aplicaciones ET++ - incluye clases para observer
• Vistas de hojas de cálculo - se actualizan cuando cambian los datos
• Suscripciones de redes sociales y feeds
• Sistemas de notificación de eventos
• Arquitectura reactiva de UI","real-world observer behavioral","Behavioral","293"
"What is the intent of the State pattern?","Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.","¿Cuál es el propósito del patrón State?","Permitir que un objeto altere su comportamiento cuando su estado interno cambia. El objeto parecerá cambiar su clase.","intent state behavioral","Behavioral","305"
"When would you use the State pattern?","• An object's behavior depends on its state, and it must change its behavior at run-time depending on that state
• Operations have large, multipart conditional statements that depend on the object's state","¿Cuándo usarías el patrón State?","• El comportamiento de un objeto depende de su estado, y debe cambiar su comportamiento en tiempo de ejecución dependiendo de ese estado
• Las operaciones tienen declaraciones condicionales grandes de múltiples ramas que dependen del estado del objeto. Este estado usualmente se representa por una o más constantes enumeradas","use-case state behavioral","Behavioral","305"
"What are the key participants in the State pattern?","• Context: Defines the interface of interest to clients; maintains an instance of a ConcreteState subclass that defines the current state
• State: Defines an interface for encapsulating the behavior associated with a particular state of the Context
• ConcreteState subclasses: Each subclass implements a behavior associated with a state of the Context","¿Cuáles son los participantes clave en el patrón State?","• Context: Define la interfaz de interés para los clientes; mantiene una instancia de una subclase ConcreteState que define el estado actual
• State: Define una interfaz para encapsular el comportamiento asociado con un estado particular del Context
• ConcreteState subclasses: Cada subclase implementa un comportamiento asociado con un estado del Context","key-concepts state behavioral","Behavioral","305"
"What are the benefits and drawbacks of the State pattern?","Benefits:
• It localizes state-specific behavior and partitions behavior for different states
• It makes state transitions explicit - separate objects for different states makes transitions more explicit
• State objects can be shared - if State objects have no instance variables, contexts can share them

Drawbacks:
• Increases the number of classes - may be less compact than a single class but distributes responsibility","¿Cuáles son los beneficios y desventajas del patrón State?","Beneficios:
• Localiza el comportamiento específico del estado y particiona el comportamiento para diferentes estados
• Hace que las transiciones de estado sean explícitas
• Los objetos State pueden compartirse si no tienen variables de instancia

Desventajas:
• Aumenta el número de clases - cada estado requiere al menos una clase
• Puede hacer que el diseño sea menos compacto que un único enfoque monolítico","benefits-drawbacks state behavioral","Behavioral","305"
"What patterns are related to the State pattern?","• Flyweight: Explains when and how State objects can be shared
• Singleton: State objects are often Singletons","¿Qué patrones están relacionados con el patrón State?","• Flyweight: Explica cuándo y cómo pueden compartirse objetos State
• Singleton: Los objetos State a menudo son Singletons","related-patterns state behavioral","Behavioral","305"
"What are key implementation considerations for the State pattern?","• Who defines the state transitions - can be defined in Context or in State subclasses (more flexible but introduces dependencies)
• A table-based alternative - use tables to map inputs to state transitions (less explicit, harder to add actions)
• Creating and destroying State objects - create in advance vs on demand
• Using dynamic inheritance - changing behavior by changing object's class at runtime (not supported in most OO languages)","¿Cuáles son las consideraciones clave de implementación para el patrón State?","• Quién define las transiciones de estado - puede hacerse en la clase Context o en las subclases State individuales
• Un enfoque basado en tabla - puede proporcionar una manera concisa de mapear entradas a transiciones de estado pero es menos explícito
• Crear y destruir objetos State - es mejor cuando los cambios de estado son dinámicos y no se conocen a priori; caso contrario, créalos solo una vez","implementation state behavioral","Behavioral","305"
"What are real-world examples of the State pattern?","• HotDraw drawing editor framework - uses State pattern for tools
• IBM's distributed systems use State pattern for connection management
• TCP connection states (Established, Listening, Closed)
• Workflow engines
• Vending machines","¿Cuáles son ejemplos del mundo real del patrón State?","• El sistema de dibujo de Unidraw usa State para alternar entre diferentes herramientas
• Conexiones de red TCP - diferentes comportamientos en estados establecido, escuchando, cerrado
• Máquinas expendedoras - comportamiento diferente basado en estado actual
• Flujos de autenticación de usuarios
• Estados de reproducción de medios (reproduciendo, pausado, detenido)","real-world state behavioral","Behavioral","305"
"What is the intent of the Strategy pattern?","Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.","¿Cuál es el propósito del patrón Strategy?","Definir una familia de algoritmos, encapsular cada uno, y hacerlos intercambiables. Strategy permite que el algoritmo varíe independientemente de los clientes que lo usan.","intent strategy behavioral","Behavioral","315"
"When would you use the Strategy pattern?","• Many related classes differ only in their behavior - Strategies provide a way to configure a class with one of many behaviors
• You need different variants of an algorithm
• An algorithm uses data that clients shouldn't know about
• A class defines many behaviors that appear as multiple conditional statements","¿Cuándo usarías el patrón Strategy?","• Muchas clases relacionadas difieren solo en su comportamiento. Las estrategias proporcionan una forma de configurar una clase con uno de muchos comportamientos
• Necesitas diferentes variantes de un algoritmo
• Un algoritmo usa datos que los clientes no deberían conocer. Usa el patrón Strategy para evitar exponer estructuras de datos complejas, específicas del algoritmo
• Una clase define muchos comportamientos, y estos aparecen como múltiples declaraciones condicionales en sus operaciones","use-case strategy behavioral","Behavioral","315"
"What are the key participants in the Strategy pattern?","• Strategy: Declares an interface common to all supported algorithms
• ConcreteStrategy: Implements the algorithm using the Strategy interface
• Context: Is configured with a ConcreteStrategy object; maintains a reference to a Strategy object; may define an interface that lets Strategy access its data","¿Cuáles son los participantes clave en el patrón Strategy?","• Strategy: Declara una interfaz común a todos los algoritmos soportados. Context usa esta interfaz para llamar al algoritmo definido por una ConcreteStrategy
• ConcreteStrategy: Implementa el algoritmo usando la interfaz Strategy
• Context: Se configura con un objeto ConcreteStrategy; mantiene una referencia a un objeto Strategy; puede definir una interfaz que permita a Strategy acceder a sus datos","key-concepts strategy behavioral","Behavioral","315"
"What are the benefits and drawbacks of the Strategy pattern?","Benefits:
• Families of related algorithms - hierarchies of Strategy classes define a family of algorithms for contexts to reuse
• An alternative to subclassing - encapsulating the algorithm in separate Strategy classes lets you vary the algorithm independently
• Strategies eliminate conditional statements - when different behaviors are lumped into one class, it's hard to avoid conditionals
• A choice of implementations - Strategies can provide different implementations of the same behavior

Drawbacks:
• Clients must be aware of different Strategies - clients must understand how Strategies differ
• Communication overhead between Strategy and Context - some ConcreteStrategies won't use all information passed to them
• Increased number of objects - Strategies increase the number of objects in an application (can reduce with Flyweight)","¿Cuáles son los beneficios y desventajas del patrón Strategy?","Beneficios:
• Familias de algoritmos relacionados - las jerarquías de clases Strategy definen una familia de algoritmos o comportamientos para que los contexts reutilicen
• Una alternativa a la creación de subclases - la herencia puede mezclar el algoritmo con el context, haciendo más difícil entender, mantener y extender el context
• Las estrategias eliminan declaraciones condicionales
• Una elección de implementaciones - las estrategias pueden proporcionar diferentes implementaciones del mismo comportamiento

Desventajas:
• Los clientes deben conocer diferentes estrategias
• Sobrecarga de comunicación entre Strategy y Context
• Aumento del número de objetos","benefits-drawbacks strategy behavioral","Behavioral","315"
"What patterns are related to the Strategy pattern?","• Flyweight: Strategy objects often make good flyweights","¿Qué patrones están relacionados con el patrón Strategy?","• Flyweight: Los objetos Strategy a menudo hacen buenos flyweights","related-patterns strategy behavioral","Behavioral","315"
"What are key implementation considerations for the Strategy pattern?","• Defining Strategy and Context interfaces - Strategy and Context interfaces must give ConcreteStrategy efficient access to data, and vice versa
• Strategies as template parameters - in C++ templates can configure a class with a strategy at compile time
• Making Strategy objects optional - Context checks for null Strategy and provides default behavior","¿Cuáles son las consideraciones clave de implementación para el patrón Strategy?","• Definir las interfaces Strategy y Context - Strategy y Context deben dar a ConcreteStrategy acceso eficiente a los datos, y viceversa
• Estrategias como parámetros de plantilla - en C++ las plantillas pueden configurar una clase con una estrategia en tiempo de compilación
• Hacer que los objetos Strategy sean opcionales - Context verifica si hay una Strategy nula y proporciona comportamiento predeterminado","implementation strategy behavioral","Behavioral","315"
"What are real-world examples of the Strategy pattern?","• ET++ SwapsManager uses different storage strategies for text buffers
• RTL Smalltalk compiler framework uses Strategy pattern for different code generation strategies
• Sorting algorithms (QuickSort, MergeSort, BubbleSort)
• Compression algorithms
• Payment processing strategies","¿Cuáles son ejemplos del mundo real del patrón Strategy?","• SwapsManager de ET++ usa diferentes estrategias de almacenamiento para búferes de texto
• El framework de compilador RTL Smalltalk usa el patrón Strategy para diferentes estrategias de generación de código
• Algoritmos de ordenamiento (QuickSort, MergeSort, BubbleSort)
• Algoritmos de compresión
• Estrategias de procesamiento de pagos","real-world strategy behavioral","Behavioral","315"
"Compare Strategy pattern vs State pattern","Similarities:
• Both use composition and delegation
• Both have similar structure with context and strategy/state objects

Differences:
• Intent: Strategy encapsulates interchangeable algorithms, State encapsulates state-specific behavior
• Control: Strategy clients choose the strategy, State changes automatically based on internal state
• Awareness: Strategy context is configured with a strategy, State context doesn't know about state transitions

When to use each:
• Strategy: When you need to select algorithm at runtime based on client choice
• State: When object behavior changes based on internal state transitions","Compara el patrón Strategy vs el patrón State","Similitudes:
• Ambos usan composición y delegación
• Ambos tienen estructura similar con objetos de contexto y estrategia/estado

Diferencias:
• Intención: Strategy encapsula algoritmos intercambiables, State encapsula comportamiento específico del estado
• Control: Los clientes de Strategy eligen la estrategia, State cambia automáticamente según el estado interno
• Consciencia: El contexto de Strategy se configura con una estrategia, el contexto de State no conoce las transiciones de estado

Cuándo usar cada uno:
• Strategy: Cuando necesitas seleccionar el algoritmo en tiempo de ejecución según la elección del cliente
• State: Cuando el comportamiento del objeto cambia según transiciones de estado internas","comparison strategy state","Comparison","315"
"Compare Mediator pattern vs Facade pattern","Similarities:
• Both provide a centralized interface to a subsystem
• Both simplify complex interactions

Differences:
• Communication: Mediator enables bidirectional communication between colleagues, Facade provides unidirectional interface to subsystem
• Awareness: Mediator colleagues know about the mediator, Facade clients don't necessarily know about subsystem components
• Purpose: Mediator decouples colleagues from each other, Facade simplifies a complex interface

When to use each:
• Mediator: When objects communicate in complex ways and you want to decouple them
• Facade: When you want to provide a simple interface to a complex subsystem","Compara el patrón Mediator vs el patrón Facade","Similitudes:
• Ambos proporcionan una interfaz centralizada a un subsistema
• Ambos simplifican interacciones complejas

Diferencias:
• Comunicación: Mediator habilita comunicación bidireccional entre colegas, Facade proporciona interfaz unidireccional al subsistema
• Consciencia: Los colegas de Mediator conocen al mediador, los clientes de Facade no necesariamente conocen los componentes del subsistema
• Propósito: Mediator desacopla colegas entre sí, Facade simplifica una interfaz compleja

Cuándo usar cada uno:
• Mediator: Cuando los objetos se comunican de formas complejas y quieres desacoplarlos
• Facade: Cuando quieres proporcionar una interfaz simple a un subsistema complejo","comparison mediator facade","Comparison","273"
"Compare Observer pattern vs Mediator pattern","Similarities:
• Both deal with object communication and coordination
• Both promote loose coupling

Differences:
• Structure: Observer has one-to-many relationship (Subject to Observers), Mediator has hub-and-spoke (Mediator coordinates Colleagues)
• Purpose: Observer focuses on notification of state changes, Mediator focuses on coordinating complex interactions
• Awareness: Observer subjects don't know observer types, Mediator knows all colleagues

When to use each:
• Observer: When you need automatic notification of state changes to multiple dependents
• Mediator: When you have complex interactions between multiple objects that need coordination","Compara el patrón Observer vs el patrón Mediator","Similitudes:
• Ambos tratan con comunicación y coordinación de objetos
• Ambos promueven acoplamiento débil

Diferencias:
• Estructura: Observer tiene relación uno-a-muchos (Subject a Observers), Mediator tiene modelo hub-and-spoke (Mediator coordina Colleagues)
• Propósito: Observer se enfoca en notificación de cambios de estado, Mediator se enfoca en coordinar interacciones complejas
• Consciencia: Los subjects de Observer no conocen los tipos de observer, Mediator conoce a todos los colegas

Cuándo usar cada uno:
• Observer: Cuando necesitas notificación automática de cambios de estado a múltiples dependientes
• Mediator: Cuando tienes interacciones complejas entre múltiples objetos que necesitan coordinación","comparison observer mediator","Comparison","293"
"Compare Command pattern vs Strategy pattern","Similarities:
• Both encapsulate behavior in objects
• Both use composition over inheritance

Differences:
• Intent: Command encapsulates requests as objects, Strategy encapsulates algorithms
• Timing: Command may be queued and executed later, Strategy is typically executed immediately
• State: Command may store state for undo/redo, Strategy is typically stateless
• Receiver: Command has a receiver that performs the action, Strategy implements the algorithm itself

When to use each:
• Command: When you need to parameterize objects with operations, support undo, or queue requests
• Strategy: When you need to select from a family of algorithms at runtime","Compara el patrón Command vs el patrón Strategy","Similitudes:
• Ambos encapsulan comportamiento en objetos
• Ambos usan composición sobre herencia

Diferencias:
• Intención: Command encapsula solicitudes como objetos, Strategy encapsula algoritmos
• Tiempo: Command puede ponerse en cola y ejecutarse más tarde, Strategy típicamente se ejecuta inmediatamente
• Estado: Command puede almacenar estado para deshacer/rehacer, Strategy típicamente no tiene estado
• Receptor: Command tiene un receptor que realiza la acción, Strategy implementa el algoritmo en sí mismo

Cuándo usar cada uno:
• Command: Cuando necesitas parametrizar objetos con operaciones, soportar deshacer, o poner solicitudes en cola
• Strategy: Cuando necesitas seleccionar de una familia de algoritmos en tiempo de ejecución","comparison command strategy","Comparison","233"
"Which patterns use the concept of Encapsulation of Variability?","This principle involves wrapping algorithms, requests, or state-specific behavior in separate objects, allowing them to vary independently from clients.

Patterns: Chain of Responsibility (encapsulates handler selection), Command (encapsulates requests), Strategy (encapsulates algorithms), State (encapsulates state-specific behavior), Interpreter (encapsulates grammar rules)","¿Qué patrones usan el concepto de Encapsulación de Variabilidad?","Este principio implica envolver algoritmos, solicitudes o comportamiento específico del estado en objetos separados, permitiéndoles variar independientemente de los clientes.

Patrones: Chain of Responsibility (encapsula selección de manejador), Command (encapsula solicitudes), Strategy (encapsula algoritmos), State (encapsula comportamiento específico del estado), Interpreter (encapsula reglas gramaticales)","cross-cutting encapsulation-of-variability","Cross-Cutting","223"
"Which patterns use the concept of Decoupling Senders and Receivers?","These patterns reduce dependencies between communicating objects by introducing intermediaries or indirection.

Patterns: Chain of Responsibility (sender doesn't know which handler processes request), Command (invoker doesn't know receiver), Mediator (colleagues don't know each other), Observer (subject doesn't know concrete observers)","¿Qué patrones usan el concepto de Desacoplamiento de Emisores y Receptores?","Estos patrones reducen dependencias entre objetos que se comunican introduciendo intermediarios o indirección.

Patrones: Chain of Responsibility (el emisor no sabe qué manejador procesa la solicitud), Command (el invocador no conoce al receptor), Mediator (los colegas no se conocen entre sí), Observer (el subject no conoce los observers concretos)","cross-cutting decoupling","Cross-Cutting","223"
"Which patterns use the concept of Delegation and Composition?","These patterns favor composition and delegation over inheritance, with objects delegating responsibilities to helper objects rather than inheriting behavior.

Patterns: Strategy (delegates algorithm to strategy object), State (delegates state-specific behavior to state object), Chain of Responsibility (delegates to successor), Command (delegates to receiver), Mediator (delegates coordination to mediator)","¿Qué patrones usan el concepto de Delegación y Composición?","Estos patrones favorecen la composición y delegación sobre la herencia, con objetos delegando responsabilidades a objetos auxiliares en lugar de heredar comportamiento.

Patrones: Strategy (delega algoritmo a objeto strategy), State (delega comportamiento específico del estado a objeto state), Chain of Responsibility (delega al sucesor), Command (delega al receptor), Mediator (delega coordinación al mediator)","cross-cutting delegation-composition","Cross-Cutting","223"
"Which patterns use the concept of Single Responsibility Principle?","These patterns extract specific responsibilities into separate objects, keeping classes focused on a single concern.

Patterns: Iterator (extracts traversal responsibility), Memento (extracts state capture responsibility), Strategy (extracts algorithm implementation), Command (extracts request execution)","¿Qué patrones usan el concepto de Principio de Responsabilidad Única?","Estos patrones extraen responsabilidades específicas en objetos separados, manteniendo las clases enfocadas en una sola preocupación.

Patrones: Iterator (extrae responsabilidad de recorrido), Memento (extrae responsabilidad de captura de estado), Strategy (extrae implementación de algoritmo), Command (extrae ejecución de solicitud)","cross-cutting single-responsibility","Cross-Cutting","257"
"Which patterns use the concept of Runtime Flexibility?","These patterns support changing behavior at runtime by swapping objects or reconfiguring relationships.

Patterns: Strategy (swap algorithms at runtime), State (change behavior based on state), Command (change commands at runtime), Chain of Responsibility (reconfigure chain dynamically)","¿Qué patrones usan el concepto de Flexibilidad en Tiempo de Ejecución?","Estos patrones soportan cambiar el comportamiento en tiempo de ejecución intercambiando objetos o reconfigurando relaciones.

Patrones: Strategy (intercambia algoritmos en tiempo de ejecución), State (cambia comportamiento según el estado), Command (cambia comandos en tiempo de ejecución), Chain of Responsibility (reconfigura cadena dinámicamente)","cross-cutting runtime-flexibility","Cross-Cutting","315"
"Which patterns use the concept of Communication Protocols?","These patterns establish protocols for how objects communicate, either through broadcast notifications, centralized coordination, or chain propagation.

Patterns: Observer (broadcast notifications to multiple observers), Mediator (centralized coordination of colleagues), Chain of Responsibility (propagation along chain until handled)","¿Qué patrones usan el concepto de Protocolos de Comunicación?","Estos patrones establecen protocolos para cómo se comunican los objetos, ya sea a través de notificaciones de difusión, coordinación centralizada o propagación en cadena.

Patrones: Observer (notificaciones de difusión a múltiples observers), Mediator (coordinación centralizada de colegas), Chain of Responsibility (propagación a lo largo de la cadena hasta ser manejada)","cross-cutting communication-protocols","Cross-Cutting","293"
"Which patterns use the concept of Preserving Encapsulation?","These patterns maintain object encapsulation while enabling specific operations that might otherwise violate it.

Patterns: Memento (preserves encapsulation while allowing state capture), Iterator (allows traversal without exposing internal structure), Mediator (hides colleague relationships)","¿Qué patrones usan el concepto de Preservación de Encapsulación?","Estos patrones mantienen la encapsulación de objetos mientras habilitan operaciones específicas que de otro modo podrían violarla.

Patrones: Memento (preserva encapsulación mientras permite captura de estado), Iterator (permite recorrido sin exponer estructura interna), Mediator (oculta relaciones entre colegas)","cross-cutting preserving-encapsulation","Cross-Cutting","283"
