"FrontEN","BackEN","FrontES","BackES","Tags","Category","Page"
"What is the intent of the Model-View-Controller (MVC) pattern?","MVC is a compound pattern that separates the presentation of data (view) from the data itself (model) and the logic that controls user interactions (controller), allowing for flexible and maintainable user interface design.","¿Cuál es el propósito del patrón Modelo-Vista-Controlador (MVC)?","MVC es un patrón compuesto que separa la presentación de datos (vista) de los datos en sí (modelo) y la lógica que controla las interacciones del usuario (controlador), permitiendo un diseño de interfaz de usuario flexible y mantenible.","intent mvc behavioral compound-pattern","Behavioral","504"
"When would you use the Model-View-Controller (MVC) pattern?","• When you need to decouple the data/logic from the user interface
• When you want to reuse the same model with different views
• When you want to change the behavior of the view without changing the view code itself
• When building GUI applications that need to respond to user input and model state changes
• When developing web applications (adapted as Model 2 pattern)","¿Cuándo utilizarías el patrón Modelo-Vista-Controlador (MVC)?","• Cuando necesitas desacoplar los datos/lógica de la interfaz de usuario
• Cuando quieres reutilizar el mismo modelo con diferentes vistas
• Cuando quieres cambiar el comportamiento de la vista sin cambiar el código de la vista
• Al construir aplicaciones GUI que necesitan responder a la entrada del usuario y cambios de estado del modelo
• Al desarrollar aplicaciones web (adaptado como patrón Modelo 2)","use-case mvc behavioral compound-pattern","Behavioral","504"
"What are the key participants in the Model-View-Controller (MVC) pattern?","**Model**: Contains all the data, state, and application logic. Provides an interface to manipulate and retrieve its state and sends notifications of state changes to observers.

**View**: Gives you a presentation of the model. Usually gets the state and data it needs to display directly from the model. Composed of GUI components using the Composite Pattern.

**Controller**: Takes user input and figures out what it means to the model. It is the behavior/strategy for the view and can be easily exchanged with another controller for different behavior.","¿Cuáles son los participantes clave en el patrón Modelo-Vista-Controlador (MVC)?","**Modelo**: Contiene todos los datos, estado y lógica de la aplicación. Proporciona una interfaz para manipular y recuperar su estado y envía notificaciones de cambios de estado a los observadores.

**Vista**: Te da una presentación del modelo. Usualmente obtiene el estado y los datos que necesita mostrar directamente del modelo. Está compuesta de componentes GUI usando el Patrón Composite.

**Controlador**: Toma la entrada del usuario y descifra qué significa para el modelo. Es el comportamiento/estrategia para la vista y puede ser fácilmente intercambiado con otro controlador para un comportamiento diferente.","key-concepts mvc behavioral compound-pattern","Behavioral","504"
"What are the benefits and drawbacks of the Model-View-Controller (MVC) pattern?","Benefits:
• Complete decoupling of model from view and controller
• Allows multiple views to use the same model
• Enables view reuse with different models through adapter pattern
• Separates interface behavior (controller) from presentation (view)
• Supports flexible and extensible designs that accommodate change
• In web applications (Model 2), separates production responsibilities between developers and designers

Drawbacks:
• Increased complexity due to multiple components
• Can be overkill for simple applications
• Controller code can become repetitive glue code
• Learning curve for developers new to the pattern","¿Cuáles son los beneficios y desventajas del patrón Modelo-Vista-Controlador (MVC)?","Beneficios:
• Desacoplamiento completo del modelo de la vista y el controlador
• Permite que múltiples vistas usen el mismo modelo
• Permite la reutilización de vistas con diferentes modelos a través del patrón adaptador
• Separa el comportamiento de la interfaz (controlador) de la presentación (vista)
• Soporta diseños flexibles y extensibles que se acomodan al cambio
• En aplicaciones web (Modelo 2), separa las responsabilidades de producción entre desarrolladores y diseñadores

Desventajas:
• Mayor complejidad debido a múltiples componentes
• Puede ser excesivo para aplicaciones simples
• El código del controlador puede convertirse en código repetitivo de pegamento
• Curva de aprendizaje para desarrolladores nuevos en el patrón","benefits-drawbacks mvc behavioral compound-pattern","Behavioral","504"
"What patterns are related to the Model-View-Controller (MVC) pattern?","**Observer**: Core pattern in MVC - model uses it to keep views and controllers updated on state changes

**Strategy**: View and controller implement this - controller is the strategy/behavior for the view

**Composite**: View uses this internally to manage nested GUI components (windows, panels, buttons)

**Adapter**: Can be used to adapt a new model to work with existing views and controllers","¿Qué patrones están relacionados con el patrón Modelo-Vista-Controlador (MVC)?","**Observer**: Patrón central en MVC - el modelo lo usa para mantener las vistas y controladores actualizados sobre cambios de estado

**Strategy**: La vista y el controlador lo implementan - el controlador es la estrategia/comportamiento para la vista

**Composite**: La vista lo usa internamente para gestionar componentes GUI anidados (ventanas, paneles, botones)

**Adapter**: Puede usarse para adaptar un nuevo modelo para trabajar con vistas y controladores existentes","related-patterns mvc behavioral compound-pattern","Behavioral","532"
"What are key implementation considerations for the Model-View-Controller (MVC) pattern?","• Model uses Observer Pattern to notify views and controllers of state changes
• View and Controller implement Strategy Pattern - controller provides behavior for the view
• View uses Composite Pattern internally for nested GUI components
• Controller can also be an observer of the model when model state affects UI controls
• In web applications, adapted as Model 2 with servlets as controllers and JSP as views
• View should never change the model directly - that's the controller's job
• View gets state directly from model, either by pulling it or receiving it via notifications","¿Cuáles son las consideraciones clave de implementación para el patrón Modelo-Vista-Controlador (MVC)?","• El modelo usa el Patrón Observer para notificar a las vistas y controladores de cambios de estado
• La vista y el controlador implementan el Patrón Strategy - el controlador proporciona comportamiento para la vista
• La vista usa el Patrón Composite internamente para componentes GUI anidados
• El controlador también puede ser un observador del modelo cuando el estado del modelo afecta los controles de la UI
• En aplicaciones web, adaptado como Modelo 2 con servlets como controladores y JSP como vistas
• La vista nunca debe cambiar el modelo directamente - ese es el trabajo del controlador
• La vista obtiene el estado directamente del modelo, ya sea extrayéndolo o recibiéndolo a través de notificaciones","implementation mvc behavioral compound-pattern","Behavioral","532"
"What are real-world examples of the Model-View-Controller (MVC) pattern?","• Swing GUI framework in Java
• iTunes and other MP3 player applications
• Web applications using servlet/JSP (Model 2)
• Cocoa framework on macOS
• Modern web frameworks like Spring MVC, ASP.NET MVC","¿Cuáles son ejemplos del mundo real del patrón Modelo-Vista-Controlador (MVC)?","• Framework GUI Swing en Java
• iTunes y otras aplicaciones reproductoras de MP3
• Aplicaciones web usando servlet/JSP (Modelo 2)
• Framework Cocoa en macOS
• Frameworks web modernos como Spring MVC, ASP.NET MVC","real-world mvc behavioral compound-pattern","Behavioral","504"
"In MVC, how do the user interactions flow through the three components?","1. User interacts with the **view**
2. View passes actions to the **controller**
3. Controller interprets user input and manipulates the **model** accordingly
4. Model notifies the view when its state changes (Observer Pattern)
5. View requests updated state from the model to refresh its display","En MVC, ¿cómo fluyen las interacciones del usuario a través de los tres componentes?","1. El usuario interactúa con la **vista**
2. La vista pasa las acciones al **controlador**
3. El controlador interpreta la entrada del usuario y manipula el **modelo** en consecuencia
4. El modelo notifica a la vista cuando su estado cambia (Patrón Observer)
5. La vista solicita estado actualizado del modelo para refrescar su visualización","key-concepts mvc behavioral compound-pattern interaction-flow","Behavioral","530"
"What is the intent of the Adapter Pattern?","Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.","¿Cuál es el propósito del Patrón Adapter?","Convertir la interfaz de una clase en otra interfaz que los clientes esperan. Adapter permite que clases trabajen juntas que de otro modo no podrían debido a interfaces incompatibles.","intent adapter-pattern structural","Structural","504"
"When would you use the Adapter Pattern?","• When you want to use an existing class but its interface doesn't match what you need
• When you need to create a reusable class that cooperates with unrelated classes with incompatible interfaces
• When adapting a model to work with existing MVC views and controllers","¿Cuándo utilizarías el Patrón Adapter?","• Cuando quieres usar una clase existente pero su interfaz no coincide con lo que necesitas
• Cuando necesitas crear una clase reutilizable que coopere con clases no relacionadas con interfaces incompatibles
• Al adaptar un modelo para trabajar con vistas y controladores MVC existentes","use-case adapter-pattern structural","Structural","504"
"What are the key participants in the Adapter Pattern?","**Target Interface**: The interface that the client expects and uses (e.g., Quackable)

**Adaptee**: The class that needs adapting (e.g., Goose with honk() method)

**Adapter**: Implements the target interface and wraps the adaptee, translating calls from the target interface to the adaptee's interface","¿Cuáles son los participantes clave en el Patrón Adapter?","**Interfaz Objetivo**: La interfaz que el cliente espera y usa (ej., Quackable)

**Adaptado**: La clase que necesita adaptación (ej., Goose con método honk())

**Adaptador**: Implementa la interfaz objetivo y envuelve el adaptado, traduciendo llamadas de la interfaz objetivo a la interfaz del adaptado","key-concepts adapter-pattern structural","Structural","504"
"What are the benefits and drawbacks of the Adapter Pattern?","Benefits:
• Allows incompatible interfaces to work together without modifying existing code
• Promotes reuse of existing classes
• Follows Open/Closed Principle - extends functionality without modification

Drawbacks:
• Increases overall complexity by adding another layer
• Sometimes many adaptations are required along an adapter chain","¿Cuáles son los beneficios y desventajas del Patrón Adapter?","Beneficios:
• Permite que interfaces incompatibles trabajen juntas sin modificar código existente
• Promueve la reutilización de clases existentes
• Sigue el Principio Abierto/Cerrado - extiende funcionalidad sin modificación

Desventajas:
• Aumenta la complejidad general al agregar otra capa
• A veces se requieren muchas adaptaciones a lo largo de una cadena de adaptadores","benefits-drawbacks adapter-pattern structural","Structural","504"
"```java
public class GooseAdapter implements Quackable {
  Goose goose;
  
  public GooseAdapter(Goose goose) {
    this.goose = goose;
  }
  
  public void quack() {
    goose.honk();
  }
}
```
What pattern does this code demonstrate?","Pattern: Adapter Pattern

Key elements: GooseAdapter wraps a Goose and implements Quackable interface. When quack() is called, it delegates to the goose's honk() method, allowing a Goose to be used anywhere a Quackable is expected.","```java
public class GooseAdapter implements Quackable {
  Goose goose;
  
  public GooseAdapter(Goose goose) {
    this.goose = goose;
  }
  
  public void quack() {
    goose.honk();
  }
}
```
¿Qué patrón demuestra este código?","Patrón: Adapter Pattern

Elementos clave: GooseAdapter envuelve un Goose e implementa la interfaz Quackable. Cuando se llama a quack(), delega al método honk() del ganso, permitiendo que un Goose sea usado donde se espera un Quackable.","code-example adapter-pattern structural java","Structural","504"
"Compare Adapter Pattern vs Decorator Pattern","Similarities:
• Both wrap objects
• Both implement the same interface as the object they wrap
• Both use composition

Differences:
• Adapter changes the interface of the wrapped object
• Decorator adds behavior while keeping the same interface

When to use each:
• Use Adapter when you need to make incompatible interfaces work together
• Use Decorator when you need to add responsibilities to objects dynamically","Compara Patrón Adapter vs Patrón Decorator","Similitudes:
• Ambos envuelven objetos
• Ambos implementan la misma interfaz que el objeto que envuelven
• Ambos usan composición

Diferencias:
• Adapter cambia la interfaz del objeto envuelto
• Decorator agrega comportamiento manteniendo la misma interfaz

Cuándo usar cada uno:
• Usa Adapter cuando necesitas hacer que interfaces incompatibles trabajen juntas
• Usa Decorator cuando necesitas agregar responsabilidades a objetos dinámicamente","comparison adapter-pattern decorator-pattern","Comparison","504"
"What is the intent of the Decorator Pattern?","Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.","¿Cuál es el propósito del Patrón Decorator?","Adjuntar responsabilidades adicionales a un objeto dinámicamente. Los decoradores proporcionan una alternativa flexible a la subclasificación para extender funcionalidad.","intent decorator-pattern structural","Structural","506"
"When would you use the Decorator Pattern?","• When you need to add responsibilities to individual objects dynamically and transparently
• When extension by subclassing is impractical or would result in too many subclasses
• When you want to add behavior that can be withdrawn
• When you need to ensure all objects get wrapped with certain behavior","¿Cuándo utilizarías el Patrón Decorator?","• Cuando necesitas agregar responsabilidades a objetos individuales dinámicamente y de forma transparente
• Cuando la extensión por subclasificación es impráctica o resultaría en demasiadas subclases
• Cuando quieres agregar comportamiento que puede ser retirado
• Cuando necesitas asegurar que todos los objetos se envuelvan con cierto comportamiento","use-case decorator-pattern structural","Structural","506"
"What are the key participants in the Decorator Pattern?","**Component Interface**: Interface that both concrete components and decorators implement (e.g., Quackable)

**Concrete Component**: The object being decorated (e.g., MallardDuck)

**Decorator**: Wraps a component, maintains a reference to it, and implements the same interface. Adds behavior before/after delegating to the wrapped component.","¿Cuáles son los participantes clave en el Patrón Decorator?","**Interfaz Componente**: Interfaz que implementan tanto componentes concretos como decoradores (ej., Quackable)

**Componente Concreto**: El objeto que se está decorando (ej., MallardDuck)

**Decorador**: Envuelve un componente, mantiene una referencia a él e implementa la misma interfaz. Agrega comportamiento antes/después de delegar al componente envuelto.","key-concepts decorator-pattern structural","Structural","506"
"What are the benefits and drawbacks of the Decorator Pattern?","Benefits:
• More flexible than static inheritance
• Adds behavior without modifying existing code
• Can add multiple decorators to an object
• Responsibilities can be added and removed at runtime
• Follows Open/Closed Principle

Drawbacks:
• Must ensure objects get wrapped or they won't have decorated behavior
• Can result in many small objects in the design
• Can be difficult to distinguish decorated object from undecorated
• Decorators can complicate client code","¿Cuáles son los beneficios y desventajas del Patrón Decorator?","Beneficios:
• Más flexible que la herencia estática
• Agrega comportamiento sin modificar código existente
• Puede agregar múltiples decoradores a un objeto
• Las responsabilidades pueden agregarse y removerse en tiempo de ejecución
• Sigue el Principio Abierto/Cerrado

Desventajas:
• Debe asegurar que los objetos se envuelvan o no tendrán comportamiento decorado
• Puede resultar en muchos objetos pequeños en el diseño
• Puede ser difícil distinguir objeto decorado de no decorado
• Los decoradores pueden complicar el código del cliente","benefits-drawbacks decorator-pattern structural","Structural","506"
"```java
public class QuackCounter implements Quackable {
  Quackable duck;
  static int numberOfQuacks;
  
  public void quack() {
    duck.quack();
    numberOfQuacks++;
  }
  
  public static int getQuacks() {
    return numberOfQuacks;
  }
}
```
What pattern does this code demonstrate?","Pattern: Decorator Pattern

Key elements: QuackCounter decorates any Quackable object, adding counting behavior. When quack() is called, it delegates to the wrapped duck then increments the count. Uses static variable to count all quacks across all decorated ducks.","```java
public class QuackCounter implements Quackable {
  Quackable duck;
  static int numberOfQuacks;
  
  public void quack() {
    duck.quack();
    numberOfQuacks++;
  }
  
  public static int getQuacks() {
    return numberOfQuacks;
  }
}
```
¿Qué patrón demuestra este código?","Patrón: Decorator Pattern

Elementos clave: QuackCounter decora cualquier objeto Quackable, agregando comportamiento de conteo. Cuando se llama a quack(), delega al pato envuelto y luego incrementa el conteo. Usa variable estática para contar todos los graznidos de todos los patos decorados.","code-example decorator-pattern structural java","Structural","506"
"What are key implementation considerations for the Decorator Pattern?","• Decorator must implement same interface as component it decorates
• Decorator holds reference to wrapped component
• Decorator delegates to wrapped component and adds additional behavior
• To ensure consistent decoration, use Abstract Factory pattern to create decorated objects
• Static variable in decorator can track aggregate behavior across all decorated objects","¿Cuáles son consideraciones clave de implementación para el Patrón Decorator?","• El decorador debe implementar la misma interfaz que el componente que decora
• El decorador mantiene referencia al componente envuelto
• El decorador delega al componente envuelto y agrega comportamiento adicional
• Para asegurar decoración consistente, usa el patrón Abstract Factory para crear objetos decorados
• Variable estática en decorador puede rastrear comportamiento agregado a través de todos los objetos decorados","implementation decorator-pattern structural","Structural","506"
"What is the intent of the Abstract Factory Pattern?","Provide an interface for creating families of related or dependent objects without specifying their concrete classes.","¿Cuál es el propósito del Patrón Abstract Factory?","Proporcionar una interfaz para crear familias de objetos relacionados o dependientes sin especificar sus clases concretas.","intent abstract-factory-pattern creational","Creational","508"
"When would you use the Abstract Factory Pattern?","• When you need to ensure objects are created consistently (e.g., all wrapped with decorators)
• When you want to create families of related objects
• When you want to provide a library of products and reveal only their interfaces, not implementations
• When system should be independent of how its products are created","¿Cuándo utilizarías el Patrón Abstract Factory?","• Cuando necesitas asegurar que los objetos se creen consistentemente (ej., todos envueltos con decoradores)
• Cuando quieres crear familias de objetos relacionados
• Cuando quieres proporcionar una biblioteca de productos y revelar solo sus interfaces, no implementaciones
• Cuando el sistema debe ser independiente de cómo se crean sus productos","use-case abstract-factory-pattern creational","Creational","508"
"What are the key participants in the Abstract Factory Pattern?","**Abstract Factory**: Declares interface for creating abstract product objects (e.g., AbstractDuckFactory)

**Concrete Factory**: Implements operations to create concrete product objects (e.g., DuckFactory, CountingDuckFactory)

**Product**: Objects created by the factory (e.g., various Quackable ducks)","¿Cuáles son los participantes clave en el Patrón Abstract Factory?","**Fábrica Abstracta**: Declara interfaz para crear objetos de producto abstractos (ej., AbstractDuckFactory)

**Fábrica Concreta**: Implementa operaciones para crear objetos de producto concretos (ej., DuckFactory, CountingDuckFactory)

**Producto**: Objetos creados por la fábrica (ej., varios patos Quackable)","key-concepts abstract-factory-pattern creational","Creational","508"
"What are the benefits and drawbacks of the Abstract Factory Pattern?","Benefits:
• Isolates concrete classes from client
• Makes exchanging product families easy
• Promotes consistency among products
• Ensures all objects are created with proper decoration or configuration

Drawbacks:
• Supporting new kinds of products is difficult - requires changing interface
• Can result in a lot of factory classes","¿Cuáles son los beneficios y desventajas del Patrón Abstract Factory?","Beneficios:
• Aísla clases concretas del cliente
• Hace fácil intercambiar familias de productos
• Promueve consistencia entre productos
• Asegura que todos los objetos se creen con decoración o configuración apropiada

Desventajas:
• Soportar nuevos tipos de productos es difícil - requiere cambiar la interfaz
• Puede resultar en muchas clases de fábrica","benefits-drawbacks abstract-factory-pattern creational","Creational","508"
"```java
public abstract class AbstractDuckFactory {
  public abstract Quackable createMallardDuck();
  public abstract Quackable createRedheadDuck();
}

public class CountingDuckFactory extends AbstractDuckFactory {
  public Quackable createMallardDuck() {
    return new QuackCounter(new MallardDuck());
  }
}
```
What pattern does this code demonstrate?","Pattern: Abstract Factory Pattern

Key elements: AbstractDuckFactory defines interface for creating duck families. CountingDuckFactory creates ducks wrapped in QuackCounter decorators, ensuring all quacks are counted.","```java
public abstract class AbstractDuckFactory {
  public abstract Quackable createMallardDuck();
  public abstract Quackable createRedheadDuck();
}

public class CountingDuckFactory extends AbstractDuckFactory {
  public Quackable createMallardDuck() {
    return new QuackCounter(new MallardDuck());
  }
}
```
¿Qué patrón demuestra este código?","Patrón: Abstract Factory Pattern

Elementos clave: AbstractDuckFactory define la interfaz para crear familias de patos. CountingDuckFactory crea patos envueltos en decoradores QuackCounter, asegurando que todos los graznidos sean contados.","code-example abstract-factory-pattern creational java","Creational","509"
"What are key implementation considerations for the Abstract Factory Pattern?","• Define abstract factory with methods for creating each product type
• Create concrete factories that implement product creation methods
• Client uses polymorphic factory - takes factory as parameter and uses it to create objects
• Can create decorated vs non-decorated product families","¿Cuáles son consideraciones clave de implementación para el Patrón Abstract Factory?","• Usa Abstract Factory para asegurar que todos los objetos se creen con decoración consistente
• La fábrica puede ser implementada como Singleton si solo necesitas una instancia
• Considera usar Factory Method dentro de las operaciones de creación de la fábrica
• El cliente trabaja solo con interfaces abstractas de fábrica y producto","implementation abstract-factory-pattern creational","Creational","508"
"What is the intent of the Composite Pattern?","Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.","¿Qué patrones están relacionados con el Patrón Abstract Factory?","**Factory Method**: Las fábricas abstractas a menudo se implementan con métodos de fábrica

**Singleton**: Las fábricas concretas a menudo son singletons

**Prototype**: Las fábricas pueden usar Prototype para crear productos

**Decorator**: Las fábricas pueden crear objetos predecorados","intent composite-pattern structural","Structural","513"
"When would you use the Composite Pattern?","• When you want to represent part-whole hierarchies of objects
• When you want clients to be able to ignore the difference between compositions and individual objects
• When you need to manage collections and sub-collections with the same interface
• When implementing GUI component hierarchies","¿Cuál es el propósito del Patrón Composite?","Componer objetos en estructuras de árbol para representar jerarquías parte-todo. Composite permite a los clientes tratar objetos individuales y composiciones de objetos de manera uniforme.","use-case composite-pattern structural","Structural","513"
"What are the key participants in the Composite Pattern?","**Component**: Interface for objects in the composition (e.g., Quackable)

**Leaf**: Individual objects with no children (e.g., MallardDuck, RedheadDuck)

**Composite**: Contains child components and implements component operations by delegating to children (e.g., Flock)","¿Cuándo utilizarías el Patrón Composite?","• Cuando quieres representar jerarquías parte-todo de objetos
• Cuando quieres que los clientes puedan ignorar la diferencia entre composiciones de objetos y objetos individuales
• Cuando la estructura puede tener cualquier nivel de complejidad y es dinámica
• En MVC, la vista usa Composite para gestionar componentes GUI anidados","key-concepts composite-pattern structural","Structural","513"
"What are the benefits and drawbacks of the Composite Pattern?","Benefits:
• Makes client code simple - treats composites and leaves uniformly
• Makes it easy to add new kinds of components
• Provides flexibility in structure

Drawbacks:
• Can make design overly general
• Can be difficult to restrict component types in composite","¿Cuáles son los participantes clave en el Patrón Composite?","**Componente**: Declara la interfaz para objetos en la composición

**Hoja**: Representa objetos hoja sin hijos

**Composite**: Define comportamiento para componentes con hijos, almacena componentes hijos (ej., Flock contiene objetos Quackable)","benefits-drawbacks composite-pattern structural","Structural","513"
"```java
public class Flock implements Quackable {
  ArrayList<Quackable> quackers = new ArrayList<>();
  
  public void add(Quackable quacker) {
    quackers.add(quacker);
  }
  
  public void quack() {
    Iterator<Quackable> iterator = quackers.iterator();
    while (iterator.hasNext()) {
      iterator.next().quack();
    }
  }
}
```
What pattern does this code demonstrate?","Pattern: Composite Pattern (also uses Iterator Pattern)

Key elements: Flock is a composite that holds Quackables. When quack() is called on the flock, it iterates through all quackers and calls quack() on each. Can contain both individual ducks and other flocks.","¿Cuáles son los beneficios y desventajas del Patrón Composite?","Beneficios:
• Hace que el cliente sea simple - puede tratar componentes individuales y composiciones uniformemente
• Facilita agregar nuevos tipos de componentes
• Sigue el Principio Abierto/Cerrado

Desventajas:
• Puede hacer que el diseño sea demasiado general
• Puede ser difícil restringir los componentes de un composite","code-example composite-pattern structural java","Structural","513"
"What are key implementation considerations for the Composite Pattern?","• Composite maintains collection of child components (ArrayList, etc.)
• Composite implements component interface, delegating operations to all children
• Often uses Iterator Pattern to traverse children
• Safety vs Transparency trade-off: keep add() method only in Composite (safer) or in Component interface (more transparent)
• Can add composites to composites for nested hierarchies","```java
public class Flock implements Quackable {
  ArrayList quackers = new ArrayList();
  
  public void add(Quackable quacker) {
    quackers.add(quacker);
  }
  
  public void quack() {
    Iterator iterator = quackers.iterator();
    while (iterator.hasNext()) {
      Quackable quacker = (Quackable)iterator.next();
      quacker.quack();
    }
  }
}
```
¿Qué patrón demuestra este código?","Patrón: Composite Pattern

Elementos clave: Flock es un composite que contiene múltiples objetos Quackable. Cuando se llama a quack(), itera a través de todos los Quackables contenidos y llama a quack() en cada uno. Trata objetos individuales y grupos uniformemente.","implementation composite-pattern structural","Structural","513"
"What is the safety versus transparency trade-off in the Composite Pattern?","**Transparency**: Put child management methods (like add()) in the Component interface. Makes leaves and composites indistinguishable but less safe - you can call add() on leaves where it doesn't make sense.

**Safety**: Keep child management methods only in Composite class. Safer because you can't call methods that don't make sense on leaves, but less transparent - client must know if it's dealing with a composite or leaf.","¿Cuáles son consideraciones clave de implementación para el Patrón Composite?","• Composite almacena componentes hijos en una colección (ej., ArrayList)
• El método del composite itera sobre hijos y delega operaciones a cada uno
• Usa Iterator para recorrer la colección de hijos
• Composite y hojas implementan la misma interfaz
• El composite puede contener tanto hojas como otros composites","key-concepts composite-pattern structural design-tradeoffs","Structural","515"
"What is the intent of the Iterator Pattern?","Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.","¿Qué patrones están relacionados con el Patrón Composite?","**Iterator**: Se usa para recorrer estructuras Composite

**Decorator**: A menudo usado con Composite - típicamente comparten una clase padre común

**Visitor**: Puede aplicar operaciones sobre estructura Composite","intent iterator-pattern behavioral","Behavioral","513"
"When would you use the Iterator Pattern?","• When you need to access an aggregate object's contents without exposing internal representation
• When you need to support multiple traversals of aggregate objects
• When you want to provide a uniform interface for traversing different aggregate structures","¿Cuándo utilizarías el Patrón Iterator?","• Cuando necesitas acceder al contenido de un objeto agregado sin exponer representación interna
• Cuando necesitas soportar múltiples travesías de objetos agregados
• Cuando quieres proporcionar una interfaz uniforme para recorrer diferentes estructuras agregadas","use-case iterator-pattern behavioral","Behavioral","513"
"What are the benefits and drawbacks of the Iterator Pattern?","Benefits:
• Supports variations in traversal of collections
• Simplifies the collection interface
• More than one traversal can be active on a collection

Drawbacks:
• Adds complexity for simple collections","¿Cuáles son los beneficios y desventajas del Patrón Iterator?","Beneficios:
• Soporta variaciones en el recorrido de colecciones
• Simplifica la interfaz de la colección
• Más de una travesía puede estar activa en una colección

Desventajas:
• Agrega complejidad para colecciones simples","benefits-drawbacks iterator-pattern behavioral","Behavioral","513"
"What patterns are related to the Iterator Pattern?","**Composite**: Often used together - Iterator traverses Composites

**Factory Method**: Polymorphic iterators rely on factory methods to instantiate appropriate iterator","¿Qué patrones están relacionados con el Patrón Iterator?","**Composite**: A menudo usado juntos - Iterator recorre Composites

**Factory Method**: Los iteradores polimórficos dependen de métodos de fábrica para instanciar el iterador apropiado","related-patterns iterator-pattern behavioral","Behavioral","513"
"What is the intent of the Observer Pattern?","Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.","¿Cuál es el propósito del Patrón Observer?","Definir una dependencia uno-a-muchos entre objetos de modo que cuando un objeto cambia de estado, todos sus dependientes sean notificados y actualizados automáticamente.","intent observer-pattern behavioral","Behavioral","516"
"When would you use the Observer Pattern?","• When abstraction has two aspects and one depends on the other
• When change to one object requires changing others, and you don't know how many objects need to be changed
• When an object should be able to notify other objects without knowing who they are
• Core pattern in MVC - model notifies views and controllers of state changes","¿Cuándo utilizarías el Patrón Observer?","• Cuando una abstracción tiene dos aspectos y uno depende del otro
• Cuando un cambio en un objeto requiere cambiar otros, y no sabes cuántos objetos necesitan ser cambiados
• Cuando un objeto debe poder notificar a otros objetos sin saber quiénes son
• Patrón central en MVC - el modelo notifica a las vistas y controladores de cambios de estado","use-case observer-pattern behavioral","Behavioral","516"
"What are the key participants in the Observer Pattern?","**Subject/Observable**: Maintains list of observers and provides methods to register/remove observers and notify them of changes

**Observer**: Interface for objects that should be notified of subject changes

**Concrete Subject**: Stores state and notifies observers when state changes

**Concrete Observer**: Maintains reference to subject and implements update method to keep state consistent","¿Cuáles son los participantes clave en el Patrón Observer?","**Sujeto/Observable**: Mantiene lista de observadores y proporciona métodos para registrar/remover observadores y notificarles de cambios

**Observador**: Interfaz para objetos que deben ser notificados de cambios del sujeto

**Sujeto Concreto**: Almacena estado y notifica a observadores cuando el estado cambia

**Observador Concreto**: Mantiene referencia al sujeto e implementa método de actualización para mantener estado consistente","key-concepts observer-pattern behavioral","Behavioral","516"
"What are the benefits and drawbacks of the Observer Pattern?","Benefits:
• Loose coupling between subject and observers
• Supports broadcast communication
• Can add observers at runtime without modifying subject

Drawbacks:
• Unexpected updates - observers don't know about each other
• Update overhead if many observers
• Memory leaks if observers not properly removed","¿Cuáles son los beneficios y desventajas del Patrón Observer?","Beneficios:
• Acoplamiento débil entre sujeto y observadores
• Soporta comunicación de difusión
• Puede agregar observadores en tiempo de ejecución sin modificar el sujeto

Desventajas:
• Actualizaciones inesperadas - los observadores no saben unos de otros
• Sobrecarga de actualización si hay muchos observadores
• Fugas de memoria si los observadores no se remueven apropiadamente","benefits-drawbacks observer-pattern behavioral","Behavioral","516"
"```java
public class Observable implements QuackObservable {
  ArrayList observers = new ArrayList();
  QuackObservable duck;
  
  public void registerObserver(Observer observer) {
    observers.add(observer);
  }
  
  public void notifyObservers() {
    Iterator iterator = observers.iterator();
    while (iterator.hasNext()) {
      Observer observer = (Observer)iterator.next();
      observer.update(duck);
    }
  }
}
```
What pattern does this code demonstrate?","Pattern: Observer Pattern

Key elements: Observable helper class encapsulates observer registration and notification. Quackable classes compose this helper and delegate observer methods to it, avoiding code duplication.","```java
public class Observable implements QuackObservable {
  ArrayList observers = new ArrayList();
  QuackObservable duck;
  
  public void registerObserver(Observer observer) {
    observers.add(observer);
  }
  
  public void notifyObservers() {
    Iterator iterator = observers.iterator();
    while (iterator.hasNext()) {
      Observer observer = (Observer)iterator.next();
      observer.update(duck);
    }
  }
}
```
¿Qué patrón demuestra este código?","Patrón: Observer Pattern

Elementos clave: La clase helper Observable encapsula el registro de observadores y la notificación. Las clases Quackable componen este helper y delegan métodos de observador a él, evitando duplicación de código.","code-example observer-pattern behavioral java","Behavioral","517"
"What are key implementation considerations for the Observer Pattern?","• Can encapsulate observer registration/notification in helper class (Observable) and compose it with subjects
• Push model: subject sends detailed state with notification
• Pull model: subject sends minimal notification, observers query for state
• Can have different observer types for different kinds of notifications (BeatObserver, BPMObserver)
• Use ArrayList to maintain observer list
• Use Iterator to notify all observers","¿Cuáles son consideraciones clave de implementación para el Patrón Observer?","• Puede encapsular registro/notificación de observadores en clase helper (Observable) y componerla con sujetos
• Modelo push: el sujeto envía estado detallado con la notificación
• Modelo pull: el sujeto envía notificación mínima, los observadores consultan por estado
• Puede tener diferentes tipos de observadores para diferentes tipos de notificaciones (BeatObserver, BPMObserver)
• Usa ArrayList para mantener lista de observadores
• Usa Iterator para notificar a todos los observadores","implementation observer-pattern behavioral","Behavioral","517"
"What is the intent of the Strategy Pattern?","Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.","¿Cuál es el propósito del Patrón Strategy?","Definir una familia de algoritmos, encapsular cada uno y hacerlos intercambiables. Strategy permite que el algoritmo varíe independientemente de los clientes que lo usan.","intent strategy-pattern behavioral","Behavioral","532"
"When would you use the Strategy Pattern?","• When you need different variants of an algorithm
• When you want to avoid exposing complex, algorithm-specific data structures
• When a class defines many behaviors as multiple conditional statements
• In MVC, the controller is the strategy for the view","¿Cuándo utilizarías el Patrón Strategy?","• Cuando necesitas diferentes variantes de un algoritmo
• Cuando quieres evitar exponer estructuras de datos complejas específicas del algoritmo
• Cuando una clase define muchos comportamientos como múltiples sentencias condicionales
• En MVC, el controlador es la estrategia para la vista","use-case strategy-pattern behavioral","Behavioral","532"
"What are the key participants in the Strategy Pattern?","**Strategy Interface**: Common interface for all supported algorithms

**Concrete Strategy**: Implements the algorithm using the Strategy interface

**Context**: Configured with a ConcreteStrategy object and maintains reference to Strategy","¿Cuáles son los participantes clave en el Patrón Strategy?","**Interfaz Strategy**: Interfaz común para todos los algoritmos soportados

**Strategy Concreta**: Implementa el algoritmo usando la interfaz Strategy

**Contexto**: Se configura con un objeto ConcreteStrategy y mantiene referencia a Strategy","key-concepts strategy-pattern behavioral","Behavioral","532"
"What are the benefits and drawbacks of the Strategy Pattern?","Benefits:
• Provides alternative to subclassing for behavior variation
• Eliminates conditional statements
• Provides choice of different implementations of same behavior
• Behaviors can be changed at runtime

Drawbacks:
• Clients must be aware of different strategies
• Increases number of objects
• Communication overhead between strategy and context","¿Cuáles son los beneficios y desventajas del Patrón Strategy?","Beneficios:
• Proporciona alternativa a la subclasificación para variación de comportamiento
• Elimina sentencias condicionales
• Proporciona elección de diferentes implementaciones del mismo comportamiento
• Los comportamientos pueden cambiarse en tiempo de ejecución

Desventajas:
• Los clientes deben estar conscientes de diferentes estrategias
• Aumenta el número de objetos
• Sobrecarga de comunicación entre estrategia y contexto","benefits-drawbacks strategy-pattern behavioral","Behavioral","532"
"How is the Strategy Pattern used in MVC?","• In MVC, view is configured with controller as its strategy
• Controller provides behavior for view - how to respond to user actions
• Can swap controllers to change view behavior without changing view code
• Strategy keeps view decoupled from model","¿Cómo se usa el Patrón Strategy en MVC?","• En MVC, la vista se configura con el controlador como su estrategia
• El controlador proporciona comportamiento para la vista - cómo responder a acciones del usuario
• Puede intercambiar controladores para cambiar el comportamiento de la vista sin cambiar el código de la vista
• Strategy mantiene la vista desacoplada del modelo","implementation strategy-pattern behavioral mvc","Behavioral","532"
"Compare Strategy Pattern vs State Pattern","Similarities:
• Similar structure - both use composition to delegate behavior
• Both allow behavior changes without modifying context class

Differences:
• Strategy: client chooses which strategy to use
• State: object behavior changes automatically based on internal state changes
• Strategy: algorithms are interchangeable and known to client
• State: states are encapsulated and client doesn't choose states directly

When to use each:
• Use Strategy when you want client to select behavior variant
• Use State when behavior should change automatically based on internal state","Compara Patrón Strategy vs Patrón State","Similitudes:
• Estructura similar - ambos usan composición para delegar comportamiento
• Ambos permiten cambios de comportamiento sin modificar la clase de contexto

Diferencias:
• Strategy: el cliente elige qué estrategia usar
• State: el comportamiento del objeto cambia automáticamente basado en cambios de estado interno
• Strategy: los algoritmos son intercambiables y conocidos por el cliente
• State: los estados están encapsulados y el cliente no elige estados directamente

Cuándo usar cada uno:
• Usa Strategy cuando quieres que el cliente seleccione variante de comportamiento
• Usa State cuando el comportamiento debe cambiar automáticamente basado en estado interno","comparison strategy-pattern state-pattern","Comparison","532"
"What is a Compound Pattern?","A compound pattern combines two or more patterns into a solution that solves a recurring or general problem. MVC is the most famous compound pattern, combining Observer (model notifies views), Strategy (controller is strategy for view), and Composite (view composed of nested components).","¿Qué es un Patrón Compuesto?","Un patrón compuesto combina dos o más patrones en una solución que resuelve un problema recurrente o general. MVC es el patrón compuesto más famoso, combinando Observer (el modelo notifica a las vistas), Strategy (el controlador es estrategia para la vista), y Composite (la vista compuesta de componentes anidados).","key-concepts compound-pattern mvc fundamentals","Fundamentals","522"
"How does Model 2 adapt MVC for web applications?","**Servlet as Controller**: Receives HTTP requests and processes user input, manipulating the model

**JSP as View**: Generates HTML presentation of model state using JavaBeans

**Model unchanged**: Still contains data and business logic

**Observer adaptation**: View receives notifications indirectly through controller when page is generated, rather than registering directly with model

**Separation of responsibilities**: Developers write servlets/model, web producers write JSP/HTML","¿Cómo adapta Modelo 2 el MVC para aplicaciones web?","**Servlet como Controlador**: Recibe solicitudes HTTP y procesa entrada del usuario, manipulando el modelo

**JSP como Vista**: Genera presentación HTML del estado del modelo usando JavaBeans

**Modelo sin cambios**: Todavía contiene datos y lógica de negocio

**Adaptación de Observer**: La vista recibe notificaciones indirectamente a través del controlador cuando se genera la página, en lugar de registrarse directamente con el modelo

**Separación de responsabilidades**: Los desarrolladores escriben servlets/modelo, los productores web escriben JSP/HTML","implementation mvc behavioral compound-pattern web","Behavioral","549"
"What patterns does MVC combine and how?","**Observer**: Model uses Observer to keep views and controllers updated on state changes. Views register with model and are notified when state changes.

**Strategy**: View and controller implement Strategy Pattern. Controller is the strategy/behavior for the view and can be easily swapped.

**Composite**: View uses Composite internally to manage nested GUI components (windows, panels, buttons, etc.).","¿Qué patrones combina MVC y cómo?","**Observer**: El modelo usa Observer para mantener las vistas y controladores actualizados sobre cambios de estado. Las vistas se registran con el modelo y son notificadas cuando el estado cambia.

**Strategy**: La vista y el controlador implementan el Patrón Strategy. El controlador es la estrategia/comportamiento para la vista y puede ser fácilmente intercambiado.

**Composite**: La vista usa Composite internamente para gestionar componentes GUI anidados (ventanas, paneles, botones, etc.).","key-concepts mvc behavioral compound-pattern pattern-composition","Behavioral","532"
"What are common misuses of the Model-View-Controller (MVC) pattern?","• Putting application logic in the controller instead of the model - controller should only translate user input to model actions
• View directly modifying the model - view should only read state, controller changes state
• Tight coupling between view and model - they should be decoupled through Observer
• Treating MVC as a silver bullet - it can be overkill for simple applications
• Not recognizing that patterns work together - trying to force exact ""textbook"" implementation","¿Cuáles son usos erróneos comunes del patrón Modelo-Vista-Controlador (MVC)?","• Poner lógica de aplicación en el controlador en lugar del modelo - el controlador solo debe traducir entrada del usuario a acciones del modelo
• La vista modificando directamente el modelo - la vista solo debe leer estado, el controlador cambia el estado
• Acoplamiento estrecho entre vista y modelo - deben estar desacoplados a través de Observer
• Tratar MVC como una bala de plata - puede ser excesivo para aplicaciones simples
• No reconocer que los patrones trabajan juntos - intentar forzar implementación exacta de ""libro de texto""","anti-pattern mvc behavioral compound-pattern","Behavioral","531"
"What cross-cutting concept does MVC demonstrate about separation of concerns?","MVC separates data/logic (model), presentation (view), and control logic (controller) into distinct components. This separation allows each to vary independently and promotes reuse. In Model 2, also provides separation of production responsibilities between developers (servlets/model) and designers (JSP/HTML).","¿Qué concepto transversal demuestra MVC sobre separación de responsabilidades?","MVC separa datos/lógica (modelo), presentación (vista), y lógica de control (controlador) en componentes distintos. Esta separación permite que cada uno varíe independientemente y promueve la reutilización. En Modelo 2, también proporciona separación de responsabilidades de producción entre desarrolladores (servlets/modelo) y diseñadores (JSP/HTML).","cross-cutting separation-of-concerns design-principles","Cross-Cutting","530"
"Which patterns demonstrate the principle of composition over inheritance?","**Decorator**: Adds behavior through wrapping rather than subclassing

**Strategy**: Provides algorithm variations through composition rather than inheritance

**Composite**: Creates part-whole hierarchies through composition

**MVC**: Controller composed with view rather than view inheriting behavior

All demonstrate favoring composition over inheritance for flexibility and runtime behavior changes.","¿Qué patrones demuestran el principio de composición sobre herencia?","**Decorator**: Agrega comportamiento a través de envoltura en lugar de subclasificación

**Strategy**: Proporciona variaciones de algoritmo a través de composición en lugar de herencia

**Composite**: Crea jerarquías parte-todo a través de composición

**MVC**: Controlador compuesto con vista en lugar de que la vista herede comportamiento

Todos demuestran favorecer la composición sobre la herencia para flexibilidad y cambios de comportamiento en tiempo de ejecución.","cross-cutting composition-over-inheritance design-principles","Cross-Cutting","532"
"How do patterns demonstrate the Open/Closed Principle?","**Observer**: Can add new observers without modifying subject - open for extension, closed for modification

**Decorator**: Adds behavior without modifying decorated class - extends without changing existing code

**Strategy**: Can add new algorithms without changing context class

**Abstract Factory**: Can create new product families without modifying client code","¿Cómo demuestran los patrones el Principio Abierto/Cerrado?","**Observer**: Puede agregar nuevos observadores sin modificar el sujeto - abierto para extensión, cerrado para modificación

**Decorator**: Agrega comportamiento sin modificar la clase decorada - extiende sin cambiar código existente

**Strategy**: Puede agregar nuevos algoritmos sin cambiar la clase de contexto

**Abstract Factory**: Puede crear nuevas familias de productos sin modificar código del cliente","cross-cutting open-closed-principle design-principles","Cross-Cutting","532"
"What is the Hollywood Principle and which patterns use it?","**Principle**: ""Don't call us, we'll call you"" - high-level components control when low-level components are called

**Observer**: Model calls observers when state changes rather than observers polling the model

**MVC**: Model notifies view when to update rather than view constantly checking model state

**Strategy**: Context calls strategy methods rather than strategy deciding when to execute","¿Cuál es el Principio de Hollywood y qué patrones lo usan?","**Principio**: ""No nos llames, te llamaremos"" - los componentes de alto nivel controlan cuándo se llaman los componentes de bajo nivel

**Observer**: El modelo llama a los observadores cuando el estado cambia en lugar de que los observadores sondeen el modelo

**MVC**: El modelo notifica a la vista cuándo actualizar en lugar de que la vista constantemente verifique el estado del modelo

**Strategy**: El contexto llama a los métodos de estrategia en lugar de que la estrategia decida cuándo ejecutarse","cross-cutting hollywood-principle design-principles","Cross-Cutting","530"
"How does the Adapter Pattern enable MVC reuse?","Adapter allows a new model with an incompatible interface to work with existing views and controllers without modification. Example: HeartAdapter converts HeartModel's getHeartRate() to BeatModel's getBPM(), allowing the DJ View to display heart rate using the same interface. Methods that don't apply to the adapted model (like setBPM() for a heart) are implemented as no-ops.","¿Cómo permite el Patrón Adapter la reutilización de MVC?","Adapter permite que un nuevo modelo con una interfaz incompatible trabaje con vistas y controladores existentes sin modificación. Ejemplo: HeartAdapter convierte getHeartRate() de HeartModel a getBPM() de BeatModel, permitiendo que la Vista DJ muestre la frecuencia cardíaca usando la misma interfaz. Los métodos que no aplican al modelo adaptado (como setBPM() para un corazón) se implementan como no-ops.","implementation adapter-pattern structural mvc reuse","Structural","546"
"What is the Single Responsibility Principle and how does MVC demonstrate it?","A class should have only one reason to change.

MVC separates responsibilities:
• **Model**: Handles data and business logic (changes when business rules change)
• **View**: Handles presentation (changes when UI requirements change)
• **Controller**: Handles user input translation (changes when input handling changes)

Each component has one reason to change, making the system more maintainable and flexible.","¿Cuál es el Principio de Responsabilidad Única y cómo lo demuestra MVC?","Una clase debe tener solo una razón para cambiar.

MVC separa responsabilidades:
• **Modelo**: Maneja datos y lógica de negocio (cambia cuando las reglas de negocio cambian)
• **Vista**: Maneja presentación (cambia cuando los requisitos de UI cambian)
• **Controlador**: Maneja traducción de entrada del usuario (cambia cuando el manejo de entrada cambia)

Cada componente tiene una razón para cambiar, haciendo el sistema más mantenible y flexible.","cross-cutting single-responsibility-principle design-principles mvc","Cross-Cutting","532"
"What is the intent of the Bridge Pattern?","Use the Bridge Pattern to vary not only your implementations, but also your abstractions.","¿Cuál es la intención del Patrón Bridge?","Usa el Patrón Bridge para variar no solo tus implementaciones, sino también tus abstracciones.","intent bridge-pattern structural","Structural","585"
"When would you use the Bridge Pattern?","• When you want to decouple an implementation so it's not permanently bound to an interface
• When abstraction and implementation need to be extended independently
• When you need to vary an interface and implementation in different ways","¿Cuándo usarías el Patrón Bridge?","• Cuando quieres desacoplar una implementación para que no esté permanentemente vinculada a una interfaz
• Cuando la abstracción y la implementación necesitan extenderse independientemente
• Cuando necesitas variar una interfaz e implementación de diferentes maneras","use-case bridge-pattern structural","Structural","585"
"What are the key participants in the Bridge Pattern?","• Abstraction: Defines the abstraction's interface and maintains a reference to an Implementor
• RefinedAbstraction: Extends the interface defined by Abstraction
• Implementor: Defines the interface for implementation classes
• ConcreteImplementor: Implements the Implementor interface","¿Cuáles son los participantes clave en el Patrón Bridge?","• Abstraction (Abstracción): Define la interfaz de la abstracción y mantiene una referencia a un Implementor
• RefinedAbstraction (Abstracción Refinada): Extiende la interfaz definida por Abstraction
• Implementor (Implementador): Define la interfaz para las clases de implementación
• ConcreteImplementor (Implementador Concreto): Implementa la interfaz Implementor","key-concepts bridge-pattern structural","Structural","585"
"What are the benefits and drawbacks of the Bridge Pattern?","Benefits:
• Decouples implementation from interface
• Abstraction and implementation can be extended independently
• Changes to concrete abstraction classes don't affect the client

Drawbacks:
• Increases complexity","¿Cuáles son los beneficios y desventajas del Patrón Bridge?","Beneficios:
• Desacopla la implementación de la interfaz
• La abstracción y la implementación pueden extenderse independientemente
• Los cambios en las clases de abstracción concretas no afectan al cliente

Desventajas:
• Aumenta la complejidad","benefits-drawbacks bridge-pattern structural","Structural","585"
"What are key implementation considerations for the Bridge Pattern?","• Create two hierarchies: one for abstractions and one for implementations
• The abstraction maintains a reference to the implementor
• All methods in abstraction are implemented in terms of the implementation","¿Cuáles son las consideraciones clave de implementación para el Patrón Bridge?","• Crea dos jerarquías: una para abstracciones y otra para implementaciones
• La abstracción mantiene una referencia al implementador
• Todos los métodos en la abstracción se implementan en términos de la implementación","implementation bridge-pattern structural","Structural","585"
"What are real-world examples of the Bridge Pattern?","• Graphic and windowing systems running over multiple platforms
• TV remote controls working with different TV brands","¿Cuáles son ejemplos del mundo real del Patrón Bridge?","• Sistemas gráficos y de ventanas que se ejecutan en múltiples plataformas
• Controles remotos de TV que funcionan con diferentes marcas de televisores","real-world bridge-pattern structural","Structural","585"
"What is the intent of the Builder Pattern?","Use the Builder Pattern to encapsulate the construction of a product and allow it to be constructed in steps.","¿Cuál es la intención del Patrón Builder?","Usa el Patrón Builder para encapsular la construcción de un producto y permitir que se construya en pasos.","intent builder-pattern creational","Creational","585"
"When would you use the Builder Pattern?","• When you need to construct complex objects step by step
• When the construction process must allow different representations
• When you want to isolate construction code from representation code","¿Cuándo usarías el Patrón Builder?","• Cuando necesitas construir objetos complejos paso a paso
• Cuando el proceso de construcción debe permitir diferentes representaciones
• Cuando quieres aislar el código de construcción del código de representación","use-case builder-pattern creational","Creational","585"
"What are the key participants in the Builder Pattern?","• Builder: Abstract interface for creating parts of a Product object
• ConcreteBuilder: Constructs and assembles parts of the product by implementing the Builder interface
• Director: Constructs an object using the Builder interface
• Product: Represents the complex object under construction","¿Cuáles son los participantes clave en el Patrón Builder?","• Builder (Constructor): Interfaz abstracta para crear partes de un objeto Product
• ConcreteBuilder (Constructor Concreto): Construye y ensambla partes del producto implementando la interfaz Builder
• Director: Construye un objeto usando la interfaz Builder
• Product (Producto): Representa el objeto complejo en construcción","key-concepts builder-pattern creational","Creational","585"
"What are the benefits and drawbacks of the Builder Pattern?","Benefits:
• Encapsulates the way complex objects are constructed
• Allows objects to be constructed in multistep and varying process
• Hides internal representation from the client
• Product implementations can be swapped in and out

Drawbacks:
• Requires more domain knowledge from client than Factory","¿Cuáles son los beneficios y desventajas del Patrón Builder?","Beneficios:
• Encapsula la forma en que se construyen objetos complejos
• Permite que los objetos se construyan en un proceso de múltiples pasos y variable
• Oculta la representación interna del cliente
• Las implementaciones de productos pueden intercambiarse fácilmente

Desventajas:
• Requiere más conocimiento del dominio por parte del cliente que Factory","benefits-drawbacks builder-pattern creational","Creational","585"
"What are key implementation considerations for the Builder Pattern?","• Client uses abstract builder interface to construct product
• Concrete builder creates real products and assembles them
• Builder provides method to retrieve final product","¿Cuáles son las consideraciones clave de implementación para el Patrón Builder?","• El cliente usa la interfaz abstracta del builder para construir el producto
• El builder concreto crea productos reales y los ensambla
• El builder proporciona un método para recuperar el producto final","implementation builder-pattern creational","Creational","585"
"What are real-world examples of the Builder Pattern?","• Vacation planner building complex itineraries with hotels, tickets, reservations","¿Cuáles son ejemplos del mundo real del Patrón Builder?","• Planificador de vacaciones que construye itinerarios complejos con hoteles, boletos, reservaciones","real-world builder-pattern creational","Creational","585"
"What is the intent of the Chain of Responsibility Pattern?","Use the Chain of Responsibility Pattern when you want to give more than one object a chance to handle a request.","¿Cuál es la intención del Patrón Chain of Responsibility?","Usa el Patrón Chain of Responsibility cuando quieres dar a más de un objeto la oportunidad de manejar una solicitud.","intent chain-of-responsibility-pattern behavioral","Behavioral","585"
"When would you use the Chain of Responsibility Pattern?","• When more than one object may handle a request
• When you want to issue a request without specifying the handler explicitly
• When the set of handlers should be specified dynamically","¿Cuándo usarías el Patrón Chain of Responsibility?","• Cuando más de un objeto puede manejar una solicitud
• Cuando quieres emitir una solicitud sin especificar el manejador explícitamente
• Cuando el conjunto de manejadores debe especificarse dinámicamente","use-case chain-of-responsibility-pattern behavioral","Behavioral","585"
"What are the key participants in the Chain of Responsibility Pattern?","• Handler: Defines interface for handling requests and optionally implements successor link
• ConcreteHandler: Handles requests it's responsible for or forwards to successor","¿Cuáles son los participantes clave en el Patrón Chain of Responsibility?","• Handler (Manejador): Define la interfaz para manejar solicitudes y opcionalmente implementa el enlace al sucesor
• ConcreteHandler (Manejador Concreto): Maneja las solicitudes de las que es responsable o las reenvía al sucesor","key-concepts chain-of-responsibility-pattern behavioral","Behavioral","585"
"What are the benefits and drawbacks of the Chain of Responsibility Pattern?","Benefits:
• Decouples sender of request from receivers
• Simplifies object by not requiring knowledge of chain structure
• Allows adding or removing responsibilities dynamically

Drawbacks:
• Request execution not guaranteed - may fall off end of chain
• Can be hard to observe runtime characteristics and debug","¿Cuáles son los beneficios y desventajas del Patrón Chain of Responsibility?","Beneficios:
• Desacopla sender of solicitud from receivers
• Simplifies objeto by not requiring knowledge of chain estructura
• Permite adding or removing responsibilities dynamically

Desventajas:
• Request execution not guaranteed - may fall off end of chain
• Can be hard to observe runtime characteristics and debug","benefits-drawbacks chain-of-responsibility-pattern behavioral","Behavioral","585"
"What are key implementation considerations for the Chain of Responsibility Pattern?","• Each handler has reference to successor
• Handler either processes request or passes to successor
• Client initiates request to first handler in chain","¿Cuáles son las consideraciones clave de implementación para el Patrón Chain of Responsibility?","• Each manejador has reference to successor
• Handler either processes solicitud or passes to successor
• Client initiates solicitud to first manejador in chain","implementation chain-of-responsibility-pattern behavioral","Behavioral","585"
"What are real-world examples of the Chain of Responsibility Pattern?","• Email filtering system routing spam, fan mail, complaints
• Windows event handling for mouse clicks and keyboard events","¿Cuáles son ejemplos del mundo real del Patrón Chain of Responsibility?","• Email filtering system routing spam, fan mail, complaints
• Windows event handling for mouse clicks and keyboard events","real-world chain-of-responsibility-pattern behavioral","Behavioral","585"
"What is the intent of the Flyweight Pattern?","Use the Flyweight Pattern when one instance of a class can be used to provide many 'virtual instances.'","¿Cuál es la intención del Patrón Flyweight?","Usa el Patrón Flyweight when one instancia of a clase can be used to proporcionar many 'virtual instancias.'","intent flyweight-pattern structural","Structural","585"
"When would you use the Flyweight Pattern?","• When a class has many instances that can all be controlled identically
• When memory usage is a critical concern
• When most object state can be made extrinsic","¿Cuándo usarías el Patrón Flyweight?","• Cuando a clase has many instancias that can all be controlled identically
• Cuando memory usage is a critical concern
• Cuando most objeto state can be made extrinsic","use-case flyweight-pattern structural","Structural","585"
"What are the key participants in the Flyweight Pattern?","• Flyweight: Declares interface through which flyweights can receive and act on extrinsic state
• ConcreteFlyweight: Implements Flyweight interface and stores intrinsic state
• FlyweightFactory: Creates and manages flyweight objects
• Client: Maintains references to flyweights and computes or stores extrinsic state","¿Cuáles son los participantes clave en el Patrón Flyweight?","• Flyweight: Declares interfaz through which flyweights can receive and act on extrinsic state
• ConcreteFlyweight: Implementa Flyweight interfaz and stores intrinsic state
• FlyweightFactory: Creates and manages flyweight objetos
• Client: Maintains references to flyweights and computes or stores extrinsic state","key-concepts flyweight-pattern structural","Structural","585"
"What are the benefits and drawbacks of the Flyweight Pattern?","Benefits:
• Reduces number of object instances at runtime
• Saves memory
• Centralizes state for many virtual objects

Drawbacks:
• Single logical instances cannot behave independently","¿Cuáles son los beneficios y desventajas del Patrón Flyweight?","Beneficios:
• Reduces number of objeto instancias at runtime
• Saves memory
• Centralizes state for many virtual objetos

Desventajas:
• Single logical instancias cannot behave independientemente","benefits-drawbacks flyweight-pattern structural","Structural","585"
"What are key implementation considerations for the Flyweight Pattern?","• Separate intrinsic (shared) from extrinsic (context-specific) state
• One flyweight instance provides behavior for many virtual objects
• Client manages extrinsic state in a data structure","¿Cuáles son las consideraciones clave de implementación para el Patrón Flyweight?","• Separate intrinsic (shared) from extrinsic (context-specific) state
• One flyweight instancia proporcionars behavior for many virtual objetos
• Client manages extrinsic state in a data estructura","implementation flyweight-pattern structural","Structural","585"
"What are real-world examples of the Flyweight Pattern?","• Tree objects in landscape design application","¿Cuáles son ejemplos del mundo real del Patrón Flyweight?","• Tree objetos in landscape design application","real-world flyweight-pattern structural","Structural","585"
"What is the intent of the Interpreter Pattern?","Use the Interpreter Pattern to build an interpreter for a language.","¿Cuál es la intención del Patrón Interpreter?","Usa el Patrón Interpreter to build an interpreter for a language.","intent interpreter-pattern behavioral","Behavioral","585"
"When would you use the Interpreter Pattern?","• When you need to implement a simple language
• When grammar is simple and efficiency is not critical
• When you have scripting or programming language needs","¿Cuándo usarías el Patrón Interpreter?","• Cuando necesitas implementar a simple language
• Cuando grammar is simple and efficiency is not critical
• Cuando you have scripting or programming language needs","use-case interpreter-pattern behavioral","Behavioral","585"
"What are the key participants in the Interpreter Pattern?","• AbstractExpression: Declares interpret operation
• TerminalExpression: Implements interpret for terminal symbols in grammar
• NonterminalExpression: Implements interpret for nonterminal symbols
• Context: Contains information global to interpreter","¿Cuáles son los participantes clave en el Patrón Interpreter?","• AbstractExpression: Declares interpret operación
• TerminalExpression: Implementa interpret for terminal symbols in grammar
• NonterminalExpression: Implementa interpret for nonterminal symbols
• Context: Contains information global to interpreter","key-concepts interpreter-pattern behavioral","Behavioral","585"
"What are the benefits and drawbacks of the Interpreter Pattern?","Benefits:
• Easy to implement simple grammars
• Easy to change or extend language
• Can add new behaviors beyond interpretation

Drawbacks:
• Becomes cumbersome with large grammars","¿Cuáles son los beneficios y desventajas del Patrón Interpreter?","Beneficios:
• Easy to implementar simple grammars
• Easy to change or extender language
• Can add new behaviors beyond interpretation

Desventajas:
• Becomes cumbersome with large grammars","benefits-drawbacks interpreter-pattern behavioral","Behavioral","585"
"What are key implementation considerations for the Interpreter Pattern?","• Create class for each grammar rule
• Direct mapping between grammar and class structure
• Each class implements interpret() method","¿Cuáles son las consideraciones clave de implementación para el Patrón Interpreter?","• Create clase for each grammar rule
• Direct mapping between grammar and clase estructura
• Each clase implementars interpret() método","implementation interpreter-pattern behavioral","Behavioral","585"
"What are real-world examples of the Interpreter Pattern?","• Duck simulator control language","¿Cuáles son ejemplos del mundo real del Patrón Interpreter?","• Duck simulator control language","real-world interpreter-pattern behavioral","Behavioral","585"
"What is the intent of the Mediator Pattern?","Use the Mediator Pattern to centralize complex communications and control between related objects.","¿Cuál es la intención del Patrón Mediator?","Usa el Patrón Mediator to centralize complejos communications and control between related objetos.","intent mediator-pattern behavioral","Behavioral","585"
"When would you use the Mediator Pattern?","• When object interaction is complex and produces interdependencies
• When reusing objects is difficult due to tight coupling
• When behavior distributed among classes should be customizable","¿Cuándo usarías el Patrón Mediator?","• Cuando objeto interaction is complejos and produces interdependencies
• Cuando reusing objetos is difficult due to tight coupling
• Cuando behavior distributed among clasees should be customizable","use-case mediator-pattern behavioral","Behavioral","585"
"What are the key participants in the Mediator Pattern?","• Mediator: Defines interface for communicating with Colleague objects
• ConcreteMediator: Implements cooperative behavior by coordinating Colleague objects
• Colleague: Communicates with other Colleagues through its Mediator","¿Cuáles son los participantes clave en el Patrón Mediator?","• Mediator: Define interfaz for communicating with Colleague objetos
• ConcreteMediator: Implementa cooperative behavior by coordinating Colleague objetos
• Colleague: Communicates with other Colleagues through its Mediator","key-concepts mediator-pattern behavioral","Behavioral","585"
"What are the benefits and drawbacks of the Mediator Pattern?","Benefits:
• Increases reusability by decoupling objects
• Simplifies maintenance by centralizing control logic
• Reduces variety of messages between objects

Drawbacks:
• Mediator can become overly complex without proper design","¿Cuáles son los beneficios y desventajas del Patrón Mediator?","Beneficios:
• Aumenta reusability by decoupling objetos
• Simplifies maintenance by centralizing control logic
• Reduces variety of messages between objetos

Desventajas:
• Mediator can become overly complejos without proper design","benefits-drawbacks mediator-pattern behavioral","Behavioral","585"
"What are key implementation considerations for the Mediator Pattern?","• Colleagues notify mediator when state changes
• Colleagues respond to requests from mediator
• Mediator contains all control logic","¿Cuáles son las consideraciones clave de implementación para el Patrón Mediator?","• Colleagues notify mediator when state changes
• Colleagues respond to solicituds from mediator
• Mediator contains all control logic","implementation mediator-pattern behavioral","Behavioral","585"
"What are real-world examples of the Mediator Pattern?","• Auto-house appliances coordinating alarm, coffee maker, sprinkler
• GUI component coordination","¿Cuáles son ejemplos del mundo real del Patrón Mediator?","• Auto-house appliances coordinating alarm, coffee maker, sprinkler
• GUI component coordination","real-world mediator-pattern behavioral","Behavioral","585"
"What is the intent of the Memento Pattern?","Use the Memento Pattern when you need to be able to return an object to one of its previous states; for instance, if your user requests an 'undo.'","¿Cuál es la intención del Patrón Memento?","Usa el Patrón Memento cuando necesitas be able to return an objeto to one of its previous states; for instancia, if your user solicituds an 'undo.'","intent memento-pattern behavioral","Behavioral","585"
"When would you use the Memento Pattern?","• When you need to save and restore object state
• When direct access to state would expose implementation details
• When you need undo/restore capability","¿Cuándo usarías el Patrón Memento?","• Cuando necesitas save and restore objeto state
• Cuando direct access to state would expose implementaración details
• Cuando you need undo/restore capability","use-case memento-pattern behavioral","Behavioral","585"
"What are the key participants in the Memento Pattern?","• Memento: Stores internal state of Originator
• Originator: Creates memento and uses it to restore state
• Caretaker: Safekeeps memento but never operates on it","¿Cuáles son los participantes clave en el Patrón Memento?","• Memento: Stores internal state of Originator
• Originator: Creates memento and uses it to restore state
• Caretaker: Safekeeps memento but never operates on it","key-concepts memento-pattern behavioral","Behavioral","585"
"What are the benefits and drawbacks of the Memento Pattern?","Benefits:
• Preserves encapsulation boundaries
• Keeps saved state external from key object
• Provides easy recovery capability

Drawbacks:
• Saving and restoring state can be time consuming","¿Cuáles son los beneficios y desventajas del Patrón Memento?","Beneficios:
• Preserves encapsulation boundaries
• Keeps saved state external from key objeto
• Provides easy recovery capability

Desventajas:
• Saving and restoring state can be time consuming","benefits-drawbacks memento-pattern behavioral","Behavioral","585"
"What are key implementation considerations for the Memento Pattern?","• Memento holds state separately from key object
• Originator creates and consumes mementos
• Client triggers save/restore but cannot access memento contents","¿Cuáles son las consideraciones clave de implementación para el Patrón Memento?","• Memento holds state separately from key objeto
• Originator creates and consumes mementos
• Client triggers save/restore but cannot access memento contents","implementation memento-pattern behavioral","Behavioral","585"
"What are real-world examples of the Memento Pattern?","• Game save/restore for role-playing game","¿Cuáles son ejemplos del mundo real del Patrón Memento?","• Game save/restore for role-playing game","real-world memento-pattern behavioral","Behavioral","585"
"What is the intent of the Prototype Pattern?","Use the Prototype Pattern when creating an instance of a given class is either expensive or complicated.","¿Cuál es la intención del Patrón Prototype?","Usa el Patrón Prototype when creating an instancia of a given clase is either expensive or complicated.","intent prototype-pattern creational","Creational","585"
"When would you use the Prototype Pattern?","• When system must create objects of many types in complex hierarchy
• When instantiation is expensive or complex
• When you want to hide creation complexity from client","¿Cuándo usarías el Patrón Prototype?","• Cuando system must create objetos of many types in complejos hierarchy
• Cuando instantiation is expensive or complejos
• Cuando quieres ocultar creation complejosity from cliente","use-case prototype-pattern creational","Creational","585"
"What are the key participants in the Prototype Pattern?","• Prototype: Declares interface for cloning itself
• ConcretePrototype: Implements clone operation
• Client: Creates new object by asking prototype to clone","¿Cuáles son los participantes clave en el Patrón Prototype?","• Prototype: Declares interfaz for cloning itself
• ConcretePrototype: Implementa clone operación
• Client: Creates new objeto by asking prototype to clone","key-concepts prototype-pattern creational","Creational","585"
"What are the benefits and drawbacks of the Prototype Pattern?","Benefits:
• Hides complexity of creating new instances
• Client can generate objects without knowing type
• Copying can be more efficient than creating

Drawbacks:
• Copying objects can be complicated","¿Cuáles son los beneficios y desventajas del Patrón Prototype?","Beneficios:
• Oculta complejosity of creating new instancias
• Client can generate objetos without knowing type
• Copying can be more efficient than creating

Desventajas:
• Copying objetos can be complicated","benefits-drawbacks prototype-pattern creational","Creational","585"
"What are key implementation considerations for the Prototype Pattern?","• Use clone() method or de-serialization
• Registry manages available prototypes
• Client requests clone from registry","¿Cuáles son las consideraciones clave de implementación para el Patrón Prototype?","• Use clone() método or de-serialization
• Registry manages available prototypes
• Client solicituds clone from registry","implementation prototype-pattern creational","Creational","585"
"What are real-world examples of the Prototype Pattern?","• Monster generation in role-playing game","¿Cuáles son ejemplos del mundo real del Patrón Prototype?","• Monster generation in role-playing game","real-world prototype-pattern creational","Creational","585"
"What is the intent of the Visitor Pattern?","Use the Visitor Pattern when you want to add capabilities to a composite of objects and encapsulation is not important.","¿Cuál es la intención del Patrón Visitor?","Usa el Patrón Visitor cuando quieres add capabilities to a composite of objetos and encapsulation is not important.","intent visitor-pattern behavioral","Behavioral","585"
"When would you use the Visitor Pattern?","• When you want to add operations without changing structure
• When adding new operations is more important than encapsulation
• When you need operations across heterogeneous structures","¿Cuándo usarías el Patrón Visitor?","• Cuando quieres add operacións without changing estructura
• Cuando adding new operacións is more important than encapsulation
• Cuando you need operacións across heterogeneous estructuras","use-case visitor-pattern behavioral","Behavioral","585"
"What are the key participants in the Visitor Pattern?","• Visitor: Declares visit operation for each element class
• ConcreteVisitor: Implements operations declared by Visitor
• Element: Defines accept operation taking visitor
• ObjectStructure: Can enumerate elements","¿Cuáles son los participantes clave en el Patrón Visitor?","• Visitor: Declares visit operación for each element clase
• ConcreteVisitor: Implementa operacións declared by Visitor
• Element: Define accept operación taking visitor
• ObjectStructure: Can enumerate elements","key-concepts visitor-pattern behavioral","Behavioral","585"
"What are the benefits and drawbacks of the Visitor Pattern?","Benefits:
• Easy to add new operations
• Centralizes operational code
• Can add capabilities without changing structure

Drawbacks:
• Breaks encapsulation of composite classes
• Changes to structure are more difficult","¿Cuáles son los beneficios y desventajas del Patrón Visitor?","Beneficios:
• Easy to add new operacións
• Centralizes operaciónal code
• Can add capabilities without changing estructura

Desventajas:
• Breaks encapsulation of composite clasees
• Changes to estructura are more difficult","benefits-drawbacks visitor-pattern behavioral","Behavioral","585"
"What are key implementation considerations for the Visitor Pattern?","• Composite classes add getState() method
• Traverser navigates structure
• Visitor collects state and performs operations","¿Cuáles son las consideraciones clave de implementación para el Patrón Visitor?","• Composite clasees add getState() método
• Traverser navigates estructura
• Visitor collects state and performs operacións","implementation visitor-pattern behavioral","Behavioral","585"
"What are real-world examples of the Visitor Pattern?","• Restaurant menu nutritional analysis","¿Cuáles son ejemplos del mundo real del Patrón Visitor?","• Restaurant menu nutritional analysis","real-world visitor-pattern behavioral","Behavioral","585"
"Which patterns embody the Keep It Simple (KISS) principle?","Always solve problems in the simplest way possible. Don't feel unsophisticated if you don't use a pattern - simplicity is the goal.

Patterns: All design patterns benefit from KISS - use them only when they simplify your solution, not to appear sophisticated.","¿Qué patrones incorporan el principio Keep It Simple (KISS)?","Always solve problems en el/la simplest way possible. Don't feel unsophisticated if you don't use a pattern - simplicity is the goal.

Patrones: All design patterns benefit from KISS - use them only when they simplify your solution, not to appear sophisticated.","cross-cutting kiss-principle","Cross-Cutting","585"
"How are design patterns categorized in the Gang of Four approach?","Patterns organized into Creational, Structural, and Behavioral categories. Also classified as Class patterns (inheritance) or Object patterns (composition).","¿Cómo se categorizan los patrones de diseño en el enfoque del Gang of Four?","Patterns organized into Creational, Structural, and Behavioral categories. Also claseified as Class patterns (inheritance) or Object patterns (composition).","cross-cutting pattern-categories","Cross-Cutting","585"
"What is the value of having a shared vocabulary for design patterns?","Pattern names enable succinct, precise communication. Using 'Observer' conveys complete design concept versus lengthy explanation.

Patterns: All patterns provide a shared vocabulary that improves team communication and design discussions.","¿Cuál es el valor de tener un vocabulario compartido para patrones de diseño?","Pattern names enable succinct, precise communication. Using 'Observer' conveys complete design concept versus lengthy explanation.

Patrones: All patterns proporcionar a shared vocabulary that improves team communication and design discussions.","cross-cutting shared-vocabulary","Cross-Cutting","585"
"When should you introduce a design pattern into your code?","Introduce pattern when sure it addresses your problem. If simpler solution works, use it. Let patterns emerge naturally.

Patterns: All patterns - avoid premature optimization and over-engineering.","¿Cuándo deberías introducir un patrón de diseño en tu código?","Introduce pattern when sure it addresses your problem. If simpler solution works, use it. Let patterns emerge naturally.

Patrones: All patterns - avoid premature optimization and over-engineering.","cross-cutting pattern-timing","Cross-Cutting","585"
"How do design patterns relate to refactoring?","Refactoring is great time to introduce patterns. Code with many conditionals might need State. Concrete dependencies might need Factory.

Patterns: All patterns - they often emerge naturally during refactoring rather than being forced upfront.","¿Cómo se relacionan los patrones de diseño con la refactorización?","Refactoring is great time to introduce patterns. Code with many conditionals might need State. Concrete dependencies might need Factory.

Patrones: All patterns - they often emerge naturally during refactoring rather than being forced upfront.","cross-cutting refactoring","Cross-Cutting","585"
"Compare Bridge Pattern vs Adapter Pattern","Similarities:
• Both provide indirection between interface and implementation
• Both are structural patterns
• Both use composition

Differences:
• Intent: Bridge separates abstraction from implementation for independent variation; Adapter converts one interface to another
• Timing: Bridge designed upfront; Adapter used to make unrelated classes work together
• Scope: Bridge affects multiple related implementations; Adapter typically wraps single class

When to use each:
• Bridge: When you want to vary both abstraction and implementation independently
• Adapter: When you need to make existing incompatible interfaces work together","Compara el Patrón Bridge vs Patrón Adapter","Similitudes:
• Both proporcionar indirection between interfaz and implementaración
• Both are structural patterns
• Both use composition

Diferencias:
• Intención: Bridge separates abstracción from implementaración for independent variation; Adapter converts one interfaz to another
• Momento: Bridge designed upfront; Adapter used to make unrelated clasees work together
• Alcance: Bridge affects multiple related implementaracións; Adapter typically wraps single clase

Cuándo usar cada uno:
• Bridge: Cuando quieres vary both abstracción and implementaración independientemente
• Adapter: Cuando necesitas make existing incompatible interfazs work together","comparison bridge-pattern adapter-pattern","Comparison","585"
"Compare Builder Pattern vs Abstract Factory Pattern","Similarities:
• Both are creational patterns
• Both create complex objects
• Both hide construction details

Differences:
• Construction: Builder constructs objects step-by-step; Abstract Factory creates families of related objects at once
• Control: Builder gives client more control over construction process; Abstract Factory creates complete products immediately
• Focus: Builder focuses on how object is assembled; Abstract Factory focuses on creating families of related objects

When to use each:
• Builder: When construction is complex with many steps, or different representations needed
• Abstract Factory: When you need to create families of related objects with consistent interfaces","Compara el Patrón Builder vs Patrón Abstract Factory","Similitudes:
• Both are creational patterns
• Both create complejos objetos
• Both ocultar construirion details

Diferencias:
• Construcción: Builder construirs objetos paso a paso; Abstract Factory creates families of related objetos at once
• Control: Builder gives cliente more control over construirion process; Abstract Factory creates complete productos immediately
• Enfoque: Builder focuses on how objeto is assembled; Abstract Factory focuses on creating families of related objetos

Cuándo usar cada uno:
• Builder: Cuando construirion is complejos with many steps, or different representarations needed
• Abstract Factory: Cuando necesitas create families of related objetos with consistent interfazs","comparison builder-pattern abstract-factory-pattern","Comparison","585"
"Compare Chain of Responsibility vs Mediator Pattern","Similarities:
• Both are behavioral patterns
• Both decouple senders from receivers
• Both centralize control logic

Differences:
• Communication: Chain passes request along linear chain; Mediator manages hub-and-spoke communication
• Coupling: Chain has loose coupling between handlers; Mediator has all colleagues coupled to mediator
• Request handling: Chain allows multiple handlers to process request; Mediator coordinates interactions between colleagues

When to use each:
• Chain of Responsibility: When multiple objects might handle request, and handler isn't known in advance
• Mediator: When objects have complex interdependencies and you want to centralize control logic","Compara el Patrón Chain of Responsibility vs Patrón Mediator","Similitudes:
• Both are behavioral patterns
• Both desacoplar senders from receivers
• Both centralize control logic

Diferencias:
• Comunicación: Chain passes solicitud along linear chain; Mediator manages hub-and-spoke communication
• Acoplamiento: Chain has loose coupling between manejadors; Mediator has all colleagues coupled to mediator
• Manejo de solicitudes: Chain permite multiple manejadors to process solicitud; Mediator coordinates interactions between colleagues

Cuándo usar cada uno:
• Chain of Responsibility: Cuando multiple objetos might manejar solicitud, and manejador isn't known in advance
• Mediator: Cuando objetos have complejos interdependencies and you want to centralize control logic","comparison chain-of-responsibility-pattern mediator-pattern","Comparison","585"
"Compare Prototype Pattern vs Factory Method Pattern","Similarities:
• Both are creational patterns
• Both hide object creation complexity
• Both provide flexibility in object creation

Differences:
• Mechanism: Prototype creates by copying existing instance; Factory Method creates by calling method in subclass
• Configuration: Prototype uses instance cloning; Factory Method uses inheritance
• Runtime flexibility: Prototype more flexible - can add/remove prototypes at runtime; Factory Method requires new subclass for new types

When to use each:
• Prototype: When object creation is expensive, or you want runtime configuration of object types
• Factory Method: When subclasses need to specify which objects to create, using inheritance","Compara el Patrón Prototype vs Patrón Factory Method","Similitudes:
• Both are creational patterns
• Both ocultar objeto creation complejosity
• Both proporcionar flexibility in objeto creation

Diferencias:
• Mecanismo: Prototype creates by copying existing instancia; Factory Method creates by calling método in subclase
• Configuración: Prototype uses instancia cloning; Factory Method uses inheritance
• Flexibilidad en tiempo de ejecución: Prototype more flexible - can add/remove prototypes at runtime; Factory Method requerirs new subclase for new types

Cuándo usar cada uno:
• Prototype: Cuando objeto creation is expensive, or you want runtime configuration of objeto types
• Factory Method: Cuando subclasees need to specify which objetos to create, using inheritance","comparison prototype-pattern factory-method-pattern","Comparison","585"
"Compare Visitor Pattern vs Iterator Pattern","Similarities:
• Both are behavioral patterns
• Both traverse object structures
• Both separate algorithm from structure

Differences:
• Purpose: Visitor performs operations on elements; Iterator provides sequential access
• Encapsulation: Visitor breaks encapsulation by requiring getState(); Iterator preserves it
• Operations: Visitor supports adding new operations easily; Iterator supports traversal patterns
• Complexity: Visitor more complex with double dispatch; Iterator simpler with single interface

When to use each:
• Visitor: When you need to perform many unrelated operations on object structure, and encapsulation is acceptable tradeoff
• Iterator: When you need to traverse collection without exposing internal representation","Compara el Patrón Visitor vs Patrón Iterator","Similitudes:
• Both are behavioral patterns
• Both traverse objeto estructuras
• Both separate algorithm from estructura

Diferencias:
• Propósito: Visitor performs operacións on elements; Iterator proporcionars sequential access
• Encapsulación: Visitor breaks encapsulation by requiring getState(); Iterator preserves it
• Operaciones: Visitor supports adding new operacións easily; Iterator supports traversal patterns
• Complejidad: Visitor more complejos with double dispatch; Iterator simpler with single interfaz

Cuándo usar cada uno:
• Visitor: Cuando necesitas perform many unrelated operacións on objeto estructura, and encapsulation is acceptable tradeoff
• Iterator: Cuando necesitas traverse collection without exposing internal representaration","comparison visitor-pattern iterator-pattern","Comparison","585"
"What is the intent of the Proxy Pattern?","Provide a surrogate or placeholder for another object to control access to it. The proxy acts as a representative that controls access to another object, which may be remote, expensive to create, or in need of securing.","¿Cuál es la intención del Patrón Proxy?","Proporcionar un sustituto o marcador de posición para otro objeto con el fin de controlar el acceso a él. El proxy actúa como un representante que controla el acceso a otro objeto, que puede ser remoto, costoso de crear o que necesite ser protegido.","intent proxy-pattern structural","Structural","460"
"When would you use the Proxy Pattern?","Use when you need to:
- Control access to a remote object (Remote Proxy)
- Delay expensive object creation (Virtual Proxy)
- Control access based on permissions (Protection Proxy)
- Add caching for expensive operations (Caching Proxy)
- Provide thread-safe access (Synchronization Proxy)
- Hide complexity of distributed systems","¿Cuándo usarías el Patrón Proxy?","Úsalo cuando necesites:
- Controlar el acceso a un objeto remoto (Proxy Remoto)
- Retrasar la creación de objetos costosos (Proxy Virtual)
- Controlar el acceso basado en permisos (Proxy de Protección)
- Agregar almacenamiento en caché para operaciones costosas (Proxy de Caché)
- Proporcionar acceso seguro para hilos (Proxy de Sincronización)
- Ocultar la complejidad de sistemas distribuidos","use-case proxy-pattern structural","Structural","460"
"What are the key participants in the Proxy Pattern?","Subject: Interface implemented by both RealSubject and Proxy

RealSubject: The real object that does the actual work

Proxy: Maintains a reference to RealSubject, implements the same interface, and controls access to it","¿Cuáles son los participantes clave en el Patrón Proxy?","Subject: Interfaz implementada tanto por RealSubject como por Proxy

RealSubject: El objeto real que hace el trabajo real

Proxy: Mantiene una referencia a RealSubject, implementa la misma interfaz y controla el acceso a él","key-concepts proxy-pattern structural","Structural","461"
"What are the benefits and drawbacks of the Proxy Pattern?","Benefits:
- Controls access to expensive objects
- Enables remote object access
- Adds security layer via access control
- Lazy initialization of heavy resources
- Transparent to clients

Drawbacks:
- Increases number of classes and objects
- May introduce latency (especially Remote Proxy)
- Adds complexity to the design","¿Cuáles son los beneficios y desventajas del Patrón Proxy?","Beneficios:
- Controla el acceso a objetos costosos
- Habilita el acceso a objetos remotos
- Agrega capa de seguridad mediante control de acceso
- Inicialización perezosa de recursos pesados
- Transparente para los clientes

Desventajas:
- Aumenta el número de clases y objetos
- Puede introducir latencia (especialmente Proxy Remoto)
- Agrega complejidad al diseño","benefits-drawbacks proxy-pattern structural","Structural","460"
"What patterns are related to the Proxy Pattern?","Decorator: Similar structure but different intent - Decorator adds behavior, Proxy controls access

Adapter: Both sit in front of objects, but Adapter changes interface while Proxy implements same interface

Facade: Similar to Complexity Hiding Proxy, but Facade provides simplified interface while Proxy controls access","¿Qué patrones están relacionados con el Patrón Proxy?","Decorator: Estructura similar pero diferente intención - Decorator agrega comportamiento, Proxy controla el acceso

Adapter: Ambos se sitúan frente a objetos, pero Adapter cambia la interfaz mientras que Proxy implementa la misma interfaz

Facade: Similar a Proxy de Ocultamiento de Complejidad, pero Facade proporciona una interfaz simplificada mientras que Proxy controla el acceso","related-patterns proxy-pattern structural","Structural","471"
"What are key implementation considerations for Remote Proxy using Java RMI?","1. Create Remote interface extending java.rmi.Remote
2. All methods must throw RemoteException
3. Arguments and return values must be Serializable
4. Implementation extends UnicastRemoteObject
5. Register service with RMI registry using Naming.rebind()
6. Client uses Naming.lookup() to get stub proxy
7. Stub handles network communication transparently","¿Cuáles son las consideraciones clave de implementación para Proxy Remoto usando Java RMI?","1. Crear interfaz Remote que extienda java.rmi.Remote
2. Todos los métodos deben lanzar RemoteException
3. Los argumentos y valores de retorno deben ser Serializable
4. La implementación extiende UnicastRemoteObject
5. Registrar el servicio con el registro RMI usando Naming.rebind()
6. El cliente usa Naming.lookup() para obtener el stub proxy
7. El stub maneja la comunicación de red de forma transparente","implementation proxy-pattern structural java rmi remote-proxy","Structural","441"
"How does a Virtual Proxy defer expensive object creation?

class ImageProxy implements Icon {
  ImageIcon imageIcon;
  URL imageURL;
  
  public void paintIcon(...) {
    if (imageIcon != null) {
      imageIcon.paintIcon(...);
    } else {
      // display loading message
      // start loading in background
    }
  }
}","Pattern: Proxy Pattern (Virtual Proxy variant)

Key elements:
- Proxy checks if real object (imageIcon) exists
- If not created yet, displays placeholder (loading message)
- Initiates background loading using separate thread
- Once loaded, delegates all calls to real object
- Client experiences no blocking","¿Cómo difiere un Proxy Virtual la creación de objetos costosos?

class ImageProxy implements Icon {
  ImageIcon imageIcon;
  URL imageURL;
  
  public void paintIcon(...) {
    if (imageIcon != null) {
      imageIcon.paintIcon(...);
    } else {
      // display loading message
      // start loading in background
    }
  }
}","Patrón: Patrón Proxy (variante Proxy Virtual)

Elementos clave:
- El proxy verifica si el objeto real (imageIcon) existe
- Si aún no está creado, muestra un marcador de posición (mensaje de carga)
- Inicia la carga en segundo plano usando un hilo separado
- Una vez cargado, delega todas las llamadas al objeto real
- El cliente no experimenta bloqueo","code-example proxy-pattern structural virtual-proxy java","Structural","465"
"What are key implementation considerations for Protection Proxy using Dynamic Proxy?","1. Create InvocationHandler that implements invoke() method
2. invoke() receives all method calls on proxy
3. Use Method.getName() to determine which method was called
4. Apply access control logic based on caller's role
5. Forward allowed calls using method.invoke(realSubject, args)
6. Throw IllegalAccessException for denied access
7. Create proxy using Proxy.newProxyInstance() with handler","¿Cuáles son las consideraciones clave de implementación para Proxy de Protección usando Dynamic Proxy?","1. Crear InvocationHandler que implemente el método invoke()
2. invoke() recibe todas las llamadas de métodos en el proxy
3. Usar Method.getName() para determinar qué método fue llamado
4. Aplicar lógica de control de acceso basada en el rol del llamador
5. Reenviar las llamadas permitidas usando method.invoke(realSubject, args)
6. Lanzar IllegalAccessException para acceso denegado
7. Crear proxy usando Proxy.newProxyInstance() con el handler","implementation proxy-pattern structural protection-proxy dynamic-proxy","Structural","480"
"What roles do Stub and Skeleton play in Java RMI Remote Proxy?","Stub (Client Helper):
- Lives in client heap
- Implements remote interface
- Packages method calls and arguments
- Sends request over network
- Unpacks and returns results to client

Skeleton (Service Helper):
- Lives in server heap
- Receives network requests
- Unpacks method information
- Invokes method on real service object
- Packages and returns results","¿Qué roles desempeñan Stub y Skeleton en Java RMI Remote Proxy?","Stub (Ayudante del Cliente):
- Vive en el heap del cliente
- Implementa la interfaz remota
- Empaqueta las llamadas a métodos y argumentos
- Envía la solicitud por la red
- Desempaqueta y devuelve resultados al cliente

Skeleton (Ayudante del Servicio):
- Vive en el heap del servidor
- Recibe solicitudes de red
- Desempaqueta información del método
- Invoca el método en el objeto de servicio real
- Empaqueta y devuelve resultados","implementation proxy-pattern structural rmi java","Structural","437"
"What are real-world examples of the Proxy Pattern?","Remote Proxy: RMI stubs, CORBA proxies, web service proxies

Virtual Proxy: Lazy-loading images in browsers, hibernate lazy collections

Protection Proxy: Java security manager, authentication proxies

Caching Proxy: Web proxy servers, CDN edge servers

Firewall Proxy: Corporate network proxies

Smart Reference: Java WeakReference, reference counting","¿Cuáles son ejemplos del mundo real del Patrón Proxy?","Proxy Remoto: Stubs de RMI, proxies de CORBA, proxies de servicios web

Proxy Virtual: Carga perezosa de imágenes en navegadores, colecciones perezosas de Hibernate

Proxy de Protección: Administrador de seguridad de Java, proxies de autenticación

Proxy de Caché: Servidores proxy web, servidores edge de CDN

Proxy de Firewall: Proxies de redes corporativas

Referencia Inteligente: Java WeakReference, conteo de referencias","real-world proxy-pattern structural","Structural","488"
"How does a Virtual Proxy differ from a Remote Proxy?","Virtual Proxy:
- Controls access to expensive-to-create objects
- Defers object creation until needed
- Provides placeholder behavior before creation
- Lives in same JVM as client
- Example: Image loading proxy

Remote Proxy:
- Controls access to objects in different JVM
- Handles network communication
- Manages serialization/deserialization
- Example: RMI stub","¿En qué se diferencia un Proxy Virtual de un Proxy Remoto?","Proxy Virtual:
- Controla el acceso a objetos costosos de crear
- Difiere la creación del objeto hasta que sea necesario
- Proporciona comportamiento de marcador de posición antes de la creación
- Vive en la misma JVM que el cliente
- Ejemplo: Proxy de carga de imágenes

Proxy Remoto:
- Controla el acceso a objetos en diferente JVM
- Maneja la comunicación de red
- Gestiona la serialización/deserialización
- Ejemplo: Stub de RMI","comparison proxy-pattern virtual-proxy remote-proxy","Comparison","462"
"How does a Protection Proxy control access to an object?","Protection Proxy controls access based on caller's permissions:

1. Implements same interface as real object
2. Checks caller's access rights before forwarding calls
3. Allows or denies method invocations based on role
4. Can provide different proxy instances for different roles
5. Throws security exceptions for unauthorized access

Example: Dating service where owners can edit their info but not rate themselves","¿Cómo controla un Proxy de Protección el acceso a un objeto?","El Proxy de Protección controla el acceso basándose en los permisos del llamador:

1. Implementa la misma interfaz que el objeto real
2. Verifica los derechos de acceso del llamador antes de reenviar llamadas
3. Permite o niega invocaciones de métodos según el rol
4. Puede proporcionar diferentes instancias de proxy para diferentes roles
5. Lanza excepciones de seguridad para acceso no autorizado

Ejemplo: Servicio de citas donde los propietarios pueden editar su información pero no calificarse a sí mismos","implementation proxy-pattern protection-proxy structural","Structural","477"
"How does Java's Dynamic Proxy create proxies at runtime?","1. Proxy class is generated at runtime by JVM
2. Proxy.newProxyInstance() takes: ClassLoader, interfaces array, InvocationHandler
3. Generated proxy implements all specified interfaces
4. All method calls are forwarded to InvocationHandler.invoke()
5. InvocationHandler decides how to handle each call
6. No need to manually create proxy classes
7. Enables flexible, reusable access control logic","¿Cómo crea el Dynamic Proxy de Java proxies en tiempo de ejecución?","1. La clase proxy es generada en tiempo de ejecución por la JVM
2. Proxy.newProxyInstance() toma: ClassLoader, array de interfaces, InvocationHandler
3. El proxy generado implementa todas las interfaces especificadas
4. Todas las llamadas de métodos se reenvían a InvocationHandler.invoke()
5. InvocationHandler decide cómo manejar cada llamada
6. No hay necesidad de crear clases proxy manualmente
7. Permite lógica de control de acceso flexible y reutilizable","implementation proxy-pattern dynamic-proxy java","Structural","474"
"Compare Proxy Pattern vs Decorator Pattern","Similarities:
- Both implement same interface as wrapped object
- Both use composition and delegation
- Structurally very similar

Differences:
- Decorator adds behavior; Proxy controls access
- Decorator can stack multiple wrappers; Proxy typically doesn't
- Proxy may create the real object; Decorator doesn't
- Proxy may not wrap existing object (e.g., remote proxy)

When to use:
- Decorator: Need to add responsibilities
- Proxy: Need to control access or manage lifecycle","Compara el Patrón Proxy vs el Patrón Decorator","Similitudes:
- Ambos implementan la misma interfaz que el objeto envuelto
- Ambos usan composición y delegación
- Estructuralmente muy similares

Diferencias:
- Decorator agrega comportamiento; Proxy controla el acceso
- Decorator puede apilar múltiples envoltorios; Proxy típicamente no
- Proxy puede crear el objeto real; Decorator no
- Proxy puede no envolver un objeto existente (ej., proxy remoto)

Cuándo usar:
- Decorator: Necesitas agregar responsabilidades
- Proxy: Necesitas controlar el acceso o gestionar el ciclo de vida","comparison proxy-pattern decorator-pattern","Comparison","472"
"Compare Proxy vs Adapter vs Facade patterns","Proxy:
- Same interface as real object
- Controls access
- Client unaware of proxy

Adapter:
- Changes interface to match client expectations
- Makes incompatible interfaces work together
- Client aware of using adapter

Facade:
- Provides simplified interface to complex subsystem
- Not focused on access control
- Wraps multiple objects

Note: Protection Proxy can provide partial interface like Adapter","Compara los patrones Proxy vs Adapter vs Facade","Proxy:
- Misma interfaz que el objeto real
- Controla el acceso
- Cliente no consciente del proxy

Adapter:
- Cambia la interfaz para cumplir expectativas del cliente
- Hace que interfaces incompatibles trabajen juntas
- Cliente consciente de usar adaptador

Facade:
- Proporciona interfaz simplificada a subsistema complejo
- No enfocado en control de acceso
- Envuelve múltiples objetos

Nota: Proxy de Protección puede proporcionar interfaz parcial como Adapter","comparison proxy-pattern adapter-pattern facade-pattern","Comparison","471"
"Compare State Pattern vs Strategy Pattern","Similarities:
- Same class diagram structure
- Both use composition and delegation
- Both encapsulate behaviors in separate classes

Differences:
- State: Behavior changes based on internal state; context changes state automatically; state transitions
- Strategy: Behavior is configured by client; client chooses algorithm; no automatic transitions

When to use:
- State: Object behavior varies with state changes
- Strategy: Need interchangeable algorithms","Compara el Patrón State vs el Patrón Strategy","Similitudes:
- Mismo diagrama de estructura de clases
- Ambos usan composición y delegación
- Ambos encapsulan comportamientos en clases separadas

Diferencias:
- State: Comportamiento cambia según estado interno; contexto cambia estado automáticamente; transiciones de estado
- Strategy: Comportamiento es configurado por el cliente; cliente elige algoritmo; sin transiciones automáticas

Cuándo usar:
- State: Comportamiento del objeto varía con cambios de estado
- Strategy: Necesitas algoritmos intercambiables","comparison state-pattern strategy-pattern behavioral","Comparison","422"
"Which patterns use Remote Method Invocation as an implementation technique?","RMI is primarily used in Remote Proxy pattern implementation.

Key concepts:
- Client helper (Stub) acts as local proxy
- Service helper (Skeleton) receives remote calls
- Serialization packages method arguments and return values
- RMI registry provides lookup service
- Enables distributed object communication

Patterns: Remote Proxy","¿Qué patrones usan Remote Method Invocation como técnica de implementación?","RMI se usa principalmente en la implementación del patrón Remote Proxy.

Conceptos clave:
- El ayudante del cliente (Stub) actúa como proxy local
- El ayudante del servicio (Skeleton) recibe llamadas remotas
- La serialización empaqueta argumentos de método y valores de retorno
- El registro RMI proporciona servicio de búsqueda
- Permite comunicación de objetos distribuidos

Patrones: Proxy Remoto","cross-cutting rmi distributed-systems proxy-pattern","Cross-Cutting","440"
"Which patterns use Serialization and why is it important?","Serialization is critical for Remote Proxy pattern.

Why it's needed:
- Method arguments must be sent over network
- Return values must be transferred back to client
- Object state must be packaged for transmission
- Primitives, Strings, and Serializable objects supported
- Use 'transient' keyword to exclude fields from serialization

Patterns: Remote Proxy, distributed system patterns","¿Qué patrones usan Serialización y por qué es importante?","La serialización es crítica para el patrón Remote Proxy.

Por qué se necesita:
- Los argumentos de método deben enviarse por la red
- Los valores de retorno deben transferirse de vuelta al cliente
- El estado del objeto debe empaquetarse para transmisión
- Se admiten primitivas, Strings y objetos Serializable
- Usar palabra clave 'transient' para excluir campos de la serialización

Patrones: Proxy Remoto, patrones de sistemas distribuidos","cross-cutting serialization proxy-pattern java","Cross-Cutting","442"
"Which patterns use InvocationHandler and how does it work?","InvocationHandler is used in Dynamic Proxy pattern (Protection Proxy variant).

How it works:
- Single invoke() method handles all method calls
- Receives: proxy object, Method object, arguments array
- Uses reflection to determine method name
- Applies custom logic (access control, logging, etc.)
- Forwards calls to real object using method.invoke()

Patterns: Protection Proxy, Dynamic Proxy","¿Qué patrones usan InvocationHandler y cómo funciona?","InvocationHandler se usa en el patrón Dynamic Proxy (variante Proxy de Protección).

Cómo funciona:
- Un único método invoke() maneja todas las llamadas de métodos
- Recibe: objeto proxy, objeto Method, array de argumentos
- Usa reflexión para determinar nombre del método
- Aplica lógica personalizada (control de acceso, logging, etc.)
- Reenvía llamadas al objeto real usando method.invoke()

Patrones: Proxy de Protección, Dynamic Proxy","cross-cutting dynamic-proxy invocation-handler java","Cross-Cutting","480"
"What are the steps to create a Remote Proxy using Java RMI?","Server side:
1. Create Remote interface extending java.rmi.Remote
2. Create implementation extending UnicastRemoteObject
3. Generate stubs/skeletons with rmic (pre-Java 5)
4. Start rmiregistry
5. Register service with Naming.rebind()

Client side:
1. Use Naming.lookup() to get stub from registry
2. Cast returned object to Remote interface
3. Call methods catching RemoteException
4. Stub handles all network communication","¿Cuáles son los pasos para crear un Proxy Remoto usando Java RMI?","Lado del servidor:
1. Crear interfaz Remote que extienda java.rmi.Remote
2. Crear implementación que extienda UnicastRemoteObject
3. Generar stubs/skeletons con rmic (antes de Java 5)
4. Iniciar rmiregistry
5. Registrar servicio con Naming.rebind()

Lado del cliente:
1. Usar Naming.lookup() para obtener stub del registro
2. Hacer cast del objeto devuelto a la interfaz Remote
3. Llamar métodos capturando RemoteException
4. Stub maneja toda la comunicación de red","implementation proxy-pattern rmi remote-proxy java","Structural","441"
"Why does Virtual Proxy use separate threads for object loading?","Separate threads prevent UI blocking:

- ImageIcon constructor is synchronous (blocks until loaded)
- Without threading, entire application would freeze
- Background thread loads expensive resource
- Main thread continues responding to user
- Proxy displays placeholder while loading
- Calls Component.repaint() when ready
- Next paint cycle shows real object","¿Por qué el Proxy Virtual usa hilos separados para la carga de objetos?","Los hilos separados previenen el bloqueo de la interfaz:

- El constructor de ImageIcon es síncrono (bloquea hasta que carga)
- Sin hilos, toda la aplicación se congelaría
- Un hilo en segundo plano carga el recurso costoso
- El hilo principal continúa respondiendo al usuario
- El proxy muestra un marcador de posición mientras carga
- Llama a Component.repaint() cuando está listo
- El siguiente ciclo de pintura muestra el objeto real","implementation proxy-pattern virtual-proxy threading java","Structural","466"
"What are common misuses of the Proxy Pattern?","1. Using Proxy when Decorator is more appropriate (adding behavior vs controlling access)
2. Forgetting to start rmiregistry before remote service
3. Not making RMI arguments/return types Serializable
4. Confusing Proxy with Adapter (Proxy keeps same interface)
5. Overusing Protection Proxy instead of proper security architecture
6. Creating too many proxy layers (complicates debugging)
7. Not handling RemoteException properly in RMI clients","¿Cuáles son los usos incorrectos comunes del Patrón Proxy?","1. Usar Proxy cuando Decorator es más apropiado (agregar comportamiento vs controlar acceso)
2. Olvidar iniciar rmiregistry antes del servicio remoto
3. No hacer que los argumentos/tipos de retorno RMI sean Serializable
4. Confundir Proxy con Adapter (Proxy mantiene la misma interfaz)
5. Sobreuso de Proxy de Protección en lugar de arquitectura de seguridad adecuada
6. Crear demasiadas capas de proxy (complica la depuración)
7. No manejar RemoteException adecuadamente en clientes RMI","anti-pattern proxy-pattern structural","Structural","449"
"What are the different variants of the Proxy Pattern?","1. Remote Proxy: Access objects in different JVM/address space
2. Virtual Proxy: Defer expensive object creation
3. Protection Proxy: Control access based on permissions
4. Caching Proxy: Cache expensive operation results
5. Firewall Proxy: Protect from network threats
6. Smart Reference Proxy: Add reference counting, logging
7. Synchronization Proxy: Thread-safe access control
8. Complexity Hiding Proxy: Hide complex subsystems
9. Copy-On-Write Proxy: Defer copying until modification","¿Cuáles son las diferentes variantes del Patrón Proxy?","1. Proxy Remoto: Acceso a objetos en diferente JVM/espacio de direcciones
2. Proxy Virtual: Difiere la creación de objetos costosos
3. Proxy de Protección: Controla el acceso basado en permisos
4. Proxy de Caché: Almacena en caché resultados de operaciones costosas
5. Proxy de Firewall: Protege de amenazas de red
6. Proxy de Referencia Inteligente: Agrega conteo de referencias, logging
7. Proxy de Sincronización: Control de acceso seguro para hilos
8. Proxy de Ocultamiento de Complejidad: Oculta subsistemas complejos
9. Proxy de Copia-en-Escritura: Difiere la copia hasta la modificación","key-concepts proxy-pattern structural","Structural","488"
"What makes this a valid RMI Remote interface?

import java.rmi.*;

public interface GumballMachineRemote extends Remote {
  public int getCount() throws RemoteException;
  public String getLocation() throws RemoteException;
  public State getState() throws RemoteException;
}","Pattern: Remote Proxy

Key elements:
- Extends java.rmi.Remote marker interface
- All methods throw RemoteException
- Return types are primitives or Serializable (State must implement Serializable)
- Defines methods clients can call remotely
- Both stub and real service implement this interface","¿Qué hace que esta sea una interfaz Remote RMI válida?

import java.rmi.*;

public interface GumballMachineRemote extends Remote {
  public int getCount() throws RemoteException;
  public String getLocation() throws RemoteException;
  public State getState() throws RemoteException;
}","Patrón: Proxy Remoto

Elementos clave:
- Extiende la interfaz marcadora java.rmi.Remote
- Todos los métodos lanzan RemoteException
- Los tipos de retorno son primitivas o Serializable (State debe implementar Serializable)
- Define métodos que los clientes pueden llamar remotamente
- Tanto el stub como el servicio real implementan esta interfaz","code-example proxy-pattern remote-proxy java rmi","Structural","451"
"How does this code create a Protection Proxy?

PersonBean getOwnerProxy(PersonBean person) {
  return (PersonBean) Proxy.newProxyInstance(
    person.getClass().getClassLoader(),
    person.getClass().getInterfaces(),
    new OwnerInvocationHandler(person));
}","Pattern: Protection Proxy using Dynamic Proxy

Key elements:
- Proxy.newProxyInstance() creates proxy at runtime
- ClassLoader parameter enables class loading
- Interfaces array defines proxy's interface
- InvocationHandler controls access logic
- Returns proxy typed as subject interface
- No manual proxy class coding needed","¿Cómo crea este código un Protection Proxy?

PersonBean getOwnerProxy(PersonBean person) {
  return (PersonBean) Proxy.newProxyInstance(
    person.getClass().getClassLoader(),
    person.getClass().getInterfaces(),
    new OwnerInvocationHandler(person));
}","Patrón: Proxy de Protección usando Dynamic Proxy

Elementos clave:
- Proxy.newProxyInstance() crea proxy en tiempo de ejecución
- El parámetro ClassLoader habilita la carga de clases
- El array de interfaces define la interfaz del proxy
- InvocationHandler controla la lógica de acceso
- Devuelve proxy tipado como interfaz del sujeto
- No se necesita codificación manual de clase proxy","code-example proxy-pattern protection-proxy dynamic-proxy java","Structural","483"
"What real-world problem does the GumballMachine Remote Proxy example solve?","Problem: CEO needs to monitor gumball machines across different locations remotely

Solution using Remote Proxy:
- GumballMachine becomes remote service (extends UnicastRemoteObject)
- Stub proxy created automatically by RMI
- GumballMonitor uses proxy to call getLocation(), getCount(), getState()
- Network communication handled transparently
- Monitor code unchanged except for RemoteException handling
- Can monitor machines anywhere on network","¿Qué problema del mundo real resuelve el ejemplo del Remote Proxy de GumballMachine?","Problema: El CEO necesita monitorear máquinas de chicles en diferentes ubicaciones de forma remota

Solución usando Proxy Remoto:
- GumballMachine se convierte en servicio remoto (extiende UnicastRemoteObject)
- El stub proxy se crea automáticamente por RMI
- GumballMonitor usa el proxy para llamar getLocation(), getCount(), getState()
- La comunicación de red se maneja de forma transparente
- El código del monitor no cambia excepto por el manejo de RemoteException
- Puede monitorear máquinas en cualquier lugar de la red","real-world proxy-pattern remote-proxy rmi","Structural","432"
"What real-world problem does the ImageProxy Virtual Proxy example solve?","Problem: Loading CD cover images from network would freeze UI

Solution using Virtual Proxy:
- ImageProxy implements Icon interface
- Initially displays loading message (800x600 placeholder)
- Spawns background thread to load ImageIcon
- Swing UI remains responsive during load
- Once loaded, delegates paintIcon() to real ImageIcon
- User sees progressive enhancement, not blocking

Benefit: Responsive UI with lazy loading","¿Qué problema del mundo real resuelve el ejemplo del Proxy Virtual de ImageProxy?","Problema: Cargar imágenes de portadas de CD desde la red congelaría la interfaz de usuario

Solución usando Proxy Virtual:
- ImageProxy implementa la interfaz Icon
- Inicialmente muestra mensaje de carga (marcador de posición de 800x600)
- Genera un hilo en segundo plano para cargar ImageIcon
- La interfaz de usuario Swing permanece receptiva durante la carga
- Una vez cargado, delega paintIcon() al ImageIcon real
- El usuario ve mejora progresiva, no bloqueo

Beneficio: Interfaz de usuario receptiva con carga perezosa","real-world proxy-pattern virtual-proxy java swing","Structural","463"
"What real-world problem does the PersonBean Protection Proxy example solve?","Problem: Dating service users were changing others' info and rating themselves

Solution using Protection Proxy:
- OwnerInvocationHandler: allows setters for personal info, blocks setHotOrNotRating()
- NonOwnerInvocationHandler: allows only setHotOrNotRating(), blocks other setters
- Both allow all getters
- Dynamic proxy enforces access rules
- Users can't manipulate ratings or alter others' profiles

Result: Proper access control based on user role","¿Qué problema del mundo real resuelve el ejemplo del Protection Proxy de PersonBean?","Problema: Los usuarios del servicio de citas cambiaban la información de otros y se calificaban a sí mismos

Solución usando Proxy de Protección:
- OwnerInvocationHandler: permite setters para información personal, bloquea setHotOrNotRating()
- NonOwnerInvocationHandler: permite solo setHotOrNotRating(), bloquea otros setters
- Ambos permiten todos los getters
- El proxy dinámico hace cumplir las reglas de acceso
- Los usuarios no pueden manipular calificaciones o alterar perfiles ajenos

Resultado: Control de acceso adecuado basado en el rol del usuario","real-world proxy-pattern protection-proxy","Structural","477"
"What are the key characteristics of the State Pattern?","- Allows object to alter behavior when internal state changes
- Unlike procedural state machine, represents state as full class
- Context delegates to current state object
- Encapsulating each state localizes changes
- State and Strategy have same diagram but different intent
- State transitions can be controlled by State or Context classes
- Typically results in greater number of classes
- State classes may be shared among Context instances","¿Cuáles son las características clave del Patrón State?","- Permite que un objeto altere su comportamiento cuando cambia su estado interno
- A diferencia de la máquina de estados procedural, representa el estado como una clase completa
- El contexto delega al objeto de estado actual
- Encapsular cada estado localiza los cambios
- State y Strategy tienen el mismo diagrama pero diferente intención
- Las transiciones de estado pueden ser controladas por las clases State o Context
- Típicamente resulta en un mayor número de clases
- Las clases State pueden compartirse entre instancias de Context","key-concepts state-pattern behavioral","Behavioral","423"
"Compare State vs Strategy vs Template Method patterns","State:
- Encapsulates state-based behavior
- Delegates to current state
- Automatic state transitions

Strategy:
- Encapsulates interchangeable behaviors
- Uses delegation to decide behavior
- Client selects strategy

Template Method:
- Subclasses decide implementation steps
- Algorithm structure in superclass
- No delegation, uses inheritance

All three manage varying behavior differently","Compara los patrones State vs Strategy vs Template Method","State:
- Encapsula comportamiento basado en estado
- Delega al estado actual
- Transiciones de estado automáticas

Strategy:
- Encapsula comportamientos intercambiables
- Usa delegación para decidir comportamiento
- El cliente selecciona la estrategia

Template Method:
- Las subclases deciden los pasos de implementación
- Estructura del algoritmo en la superclase
- Sin delegación, usa herencia

Los tres manejan comportamiento variable de manera diferente","comparison state-pattern strategy-pattern template-method-pattern","Comparison","422"
"What is a Compound Pattern and how does it differ from using multiple patterns?","Compound Pattern:
- Combines two or more patterns into solution
- Solves recurring or general problem
- Reusable across multiple contexts
- Example: Model-View-Controller

Using Multiple Patterns:
- Patterns work together in specific solution
- May not be reusable pattern itself
- Addresses particular design problem

Key difference: Compound patterns are general-purpose, reusable solutions; merely using patterns together doesn't create compound pattern","¿Qué es un Patrón Compuesto y en qué se diferencia de usar múltiples patrones?","Patrón Compuesto:
- Combina dos o más patrones en una solución
- Resuelve un problema recurrente o general
- Reutilizable en múltiples contextos
- Ejemplo: Modelo-Vista-Controlador

Usar Múltiples Patrones:
- Los patrones trabajan juntos en una solución específica
- Puede no ser un patrón reutilizable en sí mismo
- Aborda un problema de diseño particular

Diferencia clave: Los patrones compuestos son soluciones reutilizables de propósito general; simplemente usar patrones juntos no crea un patrón compuesto","key-concepts compound-patterns fundamentals","Cross-Cutting","500"
"Why is the transient keyword important in RMI State objects?","Problem: State objects maintain reference to GumballMachine; don't want entire machine serialized with state

Solution:
transient GumballMachine gumballMachine;

Effect:
- JVM skips this field during serialization
- Prevents circular serialization of large object graphs
- Reduces network transfer size
- Field will be null after deserialization

Warning: Accessing transient field after deserialization can cause errors","¿Por qué es importante la palabra clave transient en objetos State de RMI?","Problema: Los objetos State mantienen referencia a GumballMachine; no queremos que la máquina entera se serialice con el estado

Solución:
transient GumballMachine gumballMachine;

Efecto:
- JVM omite este campo durante la serialización
- Previene la serialización circular de grandes grafos de objetos
- Reduce el tamaño de transferencia de red
- El campo será null después de la deserialización

Advertencia: Acceder al campo transient después de la deserialización puede causar errores","implementation proxy-pattern rmi serialization java","Structural","452"
"What role does the RMI registry play in Remote Proxy pattern?","RMI Registry functions:
- Acts as naming service (like phone book)
- Server registers stubs using Naming.rebind(name, service)
- Client looks up stubs using Naming.lookup(url)
- Must be running before service registration
- Returns serialized stub to client
- Enables service discovery without hardcoded references

Command: rmiregistry (run in separate terminal)

Common mistake: Forgetting to start registry before service","¿Qué rol desempeña el registro RMI en el patrón Remote Proxy?","Funciones del Registro RMI:
- Actúa como servicio de nombres (como una guía telefónica)
- El servidor registra stubs usando Naming.rebind(name, service)
- El cliente busca stubs usando Naming.lookup(url)
- Debe estar ejecutándose antes del registro del servicio
- Devuelve stub serializado al cliente
- Permite el descubrimiento de servicios sin referencias codificadas

Comando: rmiregistry (ejecutar en terminal separada)

Error común: Olvidar iniciar el registro antes del servicio","implementation proxy-pattern rmi remote-proxy","Structural","444"
"How do you recognize when to apply the Proxy Pattern in your design?","Apply Proxy when you need to:

1. Add indirection between client and object
2. Control or manage object access
3. Work with remote objects transparently
4. Delay expensive object creation
5. Add security/permission layer
6. Provide placeholder during loading
7. Cache expensive operations
8. Add reference counting or logging

Key indicator: Need to control access, not add behavior (that's Decorator)","¿Cómo reconoces cuándo aplicar el Patrón Proxy en tu diseño?","Aplica Proxy cuando necesites:

1. Agregar indirección entre cliente y objeto
2. Controlar o gestionar el acceso al objeto
3. Trabajar con objetos remotos de forma transparente
4. Retrasar la creación de objetos costosos
5. Agregar capa de seguridad/permisos
6. Proporcionar marcador de posición durante la carga
7. Cachear operaciones costosas
8. Agregar conteo de referencias o registro de logs

Indicador clave: Necesidad de controlar el acceso, no agregar comportamiento (eso es Decorator)","pattern-recognition proxy-pattern structural","Structural","460"
"How does a Caching Proxy improve performance?","Caching Proxy optimization strategy:

1. Maintains cache of previous results
2. On request, checks if result already cached
3. Returns cached result if available (cache hit)
4. Forwards to real object if not cached (cache miss)
5. Stores result for future requests
6. Multiple clients can share cached results
7. Reduces computation and network latency

Example: Web proxy caching HTTP responses","¿Cómo mejora el rendimiento un Proxy de Caché?","Estrategia de optimización del Proxy de Caché:

1. Mantiene caché de resultados anteriores
2. Ante una solicitud, verifica si el resultado ya está en caché
3. Devuelve resultado en caché si está disponible (acierto de caché)
4. Reenvía al objeto real si no está en caché (fallo de caché)
5. Almacena resultado para solicitudes futuras
6. Múltiples clientes pueden compartir resultados en caché
7. Reduce computación y latencia de red

Ejemplo: Proxy web cacheando respuestas HTTP","implementation proxy-pattern caching-proxy structural","Structural","471"
"What is the intent of the State Pattern?","Allows an object to alter its behavior when its internal state changes. The object will appear to change its class.","¿Cuál es la intención del Patrón State?","Permite que un objeto altere su comportamiento cuando cambia su estado interno. El objeto parecerá cambiar su clase.","intent state-pattern behavioral","Behavioral","385"
"When would you use the State Pattern?","• An object's behavior depends on its state and must change at runtime
• Operations have large, multipart conditional statements based on state
• State transitions are well-defined and need to be made explicit
• You want to avoid large monolithic conditional statements","¿Cuándo usarías el Patrón State?","• El comportamiento de un objeto depende de su estado y debe cambiar en tiempo de ejecución
• Las operaciones tienen declaraciones condicionales grandes de múltiples partes basadas en el estado
• Las transiciones de estado están bien definidas y necesitan hacerse explícitas
• Quieres evitar grandes declaraciones condicionales monolíticas","use-case state-pattern behavioral","Behavioral","386"
"What are the key participants in the State Pattern?","• Context: Defines client interface and maintains current ConcreteState instance
• State: Defines interface for encapsulating behavior associated with a Context state
• ConcreteState: Each subclass implements behavior associated with a state of the Context","¿Cuáles son los participantes clave en el Patrón State?","• Context: Define la interfaz del cliente y mantiene la instancia actual de ConcreteState
• State: Define la interfaz para encapsular el comportamiento asociado con un estado del Context
• ConcreteState: Cada subclase implementa el comportamiento asociado con un estado del Context","key-concepts state-pattern behavioral","Behavioral","388"
"What are the benefits and drawbacks of the State Pattern?","Benefits:
• Localizes state-specific behavior and partitions behavior for different states
• Makes state transitions explicit
• State objects can be shared if they have no instance variables
• Eliminates large conditional statements
• Easier to maintain and extend with new states
• Follows Open/Closed Principle

Drawbacks:
• Increases the number of classes in your design
• Can be overkill if state machine has only a few states or rarely changes
• Creates dependencies between State classes if states need to know about other states","¿Cuáles son los beneficios y desventajas del Patrón State?","Beneficios:
• Localiza el comportamiento específico del estado y particiona el comportamiento para diferentes estados
• Hace explícitas las transiciones de estado
• Los objetos State pueden compartirse si no tienen variables de instancia
• Elimina grandes declaraciones condicionales
• Más fácil de mantener y extender con nuevos estados
• Sigue el Principio Abierto/Cerrado

Desventajas:
• Aumenta el número de clases en tu diseño
• Puede ser excesivo si la máquina de estados tiene solo unos pocos estados o raramente cambia
• Crea dependencias entre clases State si los estados necesitan conocer otros estados","benefits-drawbacks state-pattern behavioral","Behavioral","390"
"What patterns are related to the State Pattern?","Strategy Pattern: Similar structure but different intent. Strategy encapsulates interchangeable algorithms, while State encapsulates state-dependent behavior. State changes internal state to change behavior, Strategy configures behavior with different algorithms.

Singleton Pattern: State objects are often Singletons when they contain no instance variables and can be shared.","¿Qué patrones están relacionados con el Patrón State?","Patrón Strategy: Estructura similar pero intención diferente. Strategy encapsula algoritmos intercambiables, mientras que State encapsula comportamiento dependiente del estado. State cambia el estado interno para cambiar el comportamiento, Strategy configura el comportamiento con diferentes algoritmos.

Patrón Singleton: Los objetos State son a menudo Singletons cuando no contienen variables de instancia y pueden compartirse.","related-patterns state-pattern behavioral strategy singleton","Behavioral","411"
"What are key implementation considerations for the State Pattern?","• Decide whether Context or State subclasses specify state transitions (fixed transitions in Context, dynamic in State classes)
• Consider using static state instances shared across contexts if states have no instance variables
• State can be implemented as interface or abstract class depending on whether default behavior is needed
• Consider creating state objects only when needed and destroying them afterwards to save resources","¿Cuáles son las consideraciones clave de implementación para el Patrón State?","• Decidir si Context o las subclases State especifican las transiciones de estado (transiciones fijas en Context, dinámicas en clases State)
• Considerar usar instancias de estado estáticas compartidas entre contextos si los estados no tienen variables de instancia
• State puede implementarse como interfaz o clase abstracta dependiendo de si se necesita comportamiento predeterminado
• Considerar crear objetos de estado solo cuando se necesiten y destruirlos después para ahorrar recursos","implementation state-pattern behavioral","Behavioral","405"
"What are real-world examples of the State Pattern?","• Gumball vending machine with states: NoQuarter, HasQuarter, Sold, SoldOut
• TCP connection states: Established, Listen, Closed
• Document workflow states: Draft, Review, Published
• Media player states: Playing, Paused, Stopped
• Order processing states: New, Paid, Shipped, Delivered","¿Cuáles son ejemplos del mundo real del Patrón State?","• Máquina expendedora de chicles con estados: NoQuarter, HasQuarter, Sold, SoldOut
• Estados de conexión TCP: Established, Listen, Closed
• Estados de flujo de trabajo de documentos: Draft, Review, Published
• Estados de reproductor multimedia: Playing, Paused, Stopped
• Estados de procesamiento de pedidos: New, Paid, Shipped, Delivered","real-world state-pattern behavioral","Behavioral","387"
"In the State Pattern, how does the Context collaborate with ConcreteState objects?","The Context delegates state-specific requests to the current ConcreteState object. The Context may pass itself as an argument to the State object handling the request, allowing the State object to access the context if necessary. State transitions can be controlled by the State objects themselves or by the Context.","En el Patrón State, ¿cómo colabora el Context con los objetos ConcreteState?","El Context delega solicitudes específicas del estado al objeto ConcreteState actual. El Context puede pasarse a sí mismo como argumento al objeto State que maneja la solicitud, permitiendo que el objeto State acceda al contexto si es necesario. Las transiciones de estado pueden ser controladas por los propios objetos State o por el Context.","key-concepts state-pattern behavioral collaboration","Behavioral","389"
"public interface State {
    void insertQuarter();
    void ejectQuarter();
    void turnCrank();
    void dispense();
}

public class NoQuarterState implements State {
    GumballMachine gumballMachine;
    
    public NoQuarterState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }
    
    public void insertQuarter() {
        System.out.println(""You inserted a quarter"");
        gumballMachine.setState(gumballMachine.getHasQuarterState());
    }
    
    public void ejectQuarter() {
        System.out.println(""You haven't inserted a quarter"");
    }
    
    public void turnCrank() {
        System.out.println(""You turned, but there's no quarter"");
    }
    
    public void dispense() {
        System.out.println(""You need to pay first"");
    }
}

What pattern does this code demonstrate?","Pattern: State Pattern

Key elements:
• State interface defines methods for all possible actions (insertQuarter, ejectQuarter, turnCrank, dispense)
• NoQuarterState is a ConcreteState that implements appropriate behavior for the ""no quarter"" state
• The state handles transitions by calling gumballMachine.setState() to change to a different state
• Each method provides state-specific behavior or error messages","public interface State {
    void insertQuarter();
    void ejectQuarter();
    void turnCrank();
    void dispense();
}

public class NoQuarterState implements State {
    GumballMachine gumballMachine;
    
    public NoQuarterState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }
    
    public void insertQuarter() {
        System.out.println(""You inserted a quarter"");
        gumballMachine.setState(gumballMachine.getHasQuarterState());
    }
    
    public void ejectQuarter() {
        System.out.println(""You haven't inserted a quarter"");
    }
    
    public void turnCrank() {
        System.out.println(""You turned, but there's no quarter"");
    }
    
    public void dispense() {
        System.out.println(""You need to pay first"");
    }
}

¿Qué patrón demuestra este código?","Patrón: State Pattern

Elementos clave:
• La interfaz State define métodos para todas las acciones posibles (insertQuarter, ejectQuarter, turnCrank, dispense)
• NoQuarterState es un ConcreteState que implementa el comportamiento apropiado para el estado ""sin moneda""
• El estado maneja las transiciones llamando a gumballMachine.setState() para cambiar a un estado diferente
• Cada método proporciona comportamiento específico del estado o mensajes de error","code-example state-pattern behavioral java","Behavioral","394"
"public class GumballMachine {
    State soldOutState;
    State noQuarterState;
    State hasQuarterState;
    State soldState;
    
    State state = soldOutState;
    int count = 0;
    
    public GumballMachine(int numberGumballs) {
        soldOutState = new SoldOutState(this);
        noQuarterState = new NoQuarterState(this);
        hasQuarterState = new HasQuarterState(this);
        soldState = new SoldState(this);
        
        this.count = numberGumballs;
        if (numberGumballs > 0) {
            state = noQuarterState;
        }
    }
    
    public void insertQuarter() {
        state.insertQuarter();
    }
    
    public void setState(State state) {
        this.state = state;
    }
}

What role does GumballMachine play in the State Pattern?","Pattern: State Pattern

Key elements:
• GumballMachine is the Context that maintains references to all state objects
• It holds a reference to the current state and delegates all requests to it (state.insertQuarter())
• The Context provides a setState() method allowing states to trigger transitions
• All state objects are initialized in constructor and passed a reference to the Context (this)","public class GumballMachine {
    State soldOutState;
    State noQuarterState;
    State hasQuarterState;
    State soldState;
    
    State state = soldOutState;
    int count = 0;
    
    public GumballMachine(int numberGumballs) {
        soldOutState = new SoldOutState(this);
        noQuarterState = new NoQuarterState(this);
        hasQuarterState = new HasQuarterState(this);
        soldState = new SoldState(this);
        
        this.count = numberGumballs;
        if (numberGumballs > 0) {
            state = noQuarterState;
        }
    }
    
    public void insertQuarter() {
        state.insertQuarter();
    }
    
    public void setState(State state) {
        this.state = state;
    }
}

¿Qué papel juega GumballMachine en el Patrón State?","Patrón: State Pattern

Elementos clave:
• GumballMachine es el Context que mantiene referencias a todos los objetos de estado
• Contiene una referencia al estado actual y delega todas las solicitudes a él (state.insertQuarter())
• El Context proporciona un método setState() que permite a los estados activar transiciones
• Todos los objetos de estado se inicializan en el constructor y reciben una referencia al Context (this)","code-example state-pattern behavioral java","Behavioral","396"
"Compare State Pattern vs Strategy Pattern","Similarities:
• Both use composition and delegation
• Both have similar class structures
• Both allow behavior to be changed at runtime

Differences:
• State: Encapsulates state-dependent behavior, object appears to change class when state changes
• Strategy: Encapsulates interchangeable algorithms, behavior is configured from outside

When to use each:
• State: When object behavior depends on internal state and changes automatically
• Strategy: When you want to configure an object with one of many algorithms/behaviors","Compara Patrón State vs Patrón Strategy","Similitudes:
• Ambos usan composición y delegación
• Ambos tienen estructuras de clase similares
• Ambos permiten que el comportamiento cambie en tiempo de ejecución

Diferencias:
• State: Encapsula comportamiento dependiente del estado, el objeto parece cambiar de clase cuando cambia el estado
• Strategy: Encapsula algoritmos intercambiables, el comportamiento se configura desde fuera

Cuándo usar cada uno:
• State: Cuando el comportamiento del objeto depende del estado interno y cambia automáticamente
• Strategy: Cuando quieres configurar un objeto con uno de muchos algoritmos/comportamientos","comparison state-pattern strategy-pattern","Comparison","411"
"Which patterns use the concept 'Encapsulation of State Behavior'?","The State Pattern demonstrates how to encapsulate varying behavior by placing it in separate state classes. Each state class encapsulates the behavior appropriate for that particular state, eliminating large conditional statements and making the code more maintainable.

Patterns: State Pattern","¿Qué patrones usan el concepto 'Encapsulación del Comportamiento del Estado'?","El Patrón State demuestra cómo encapsular comportamiento variable colocándolo en clases de estado separadas. Cada clase de estado encapsula el comportamiento apropiado para ese estado particular, eliminando grandes declaraciones condicionales y haciendo el código más mantenible.

Patrones: State Pattern","cross-cutting encapsulation state-behavior","Cross-Cutting","388"
"Which patterns use the concept 'Delegation'?","Both State and Strategy patterns use delegation to vary behavior. The Context delegates requests to composed objects (state or strategy objects) rather than implementing all behavior itself. This provides flexibility to change behavior at runtime through composition.

Patterns: State Pattern, Strategy Pattern","¿Qué patrones usan el concepto 'Delegación'?","Tanto los patrones State como Strategy usan delegación para variar el comportamiento. El Context delega solicitudes a objetos compuestos (objetos state o strategy) en lugar de implementar todo el comportamiento él mismo. Esto proporciona flexibilidad para cambiar el comportamiento en tiempo de ejecución a través de la composición.

Patrones: State Pattern, Strategy Pattern","cross-cutting delegation","Cross-Cutting","389"
"How does the State Pattern follow the Open/Closed Principle?","The State Pattern follows the Open/Closed Principle by allowing you to add new states without modifying existing code. Each state is closed for modification but the system is open for extension through new state classes.

Patterns: State Pattern","¿Cómo sigue el Patrón State el Principio Abierto/Cerrado?","El Patrón State sigue el Principio Abierto/Cerrado al permitirte agregar nuevos estados sin modificar el código existente. Cada estado está cerrado para modificación pero el sistema está abierto para extensión a través de nuevas clases de estado.

Patrones: State Pattern","cross-cutting open-closed-principle","Cross-Cutting","390"
"How does the State Pattern demonstrate the Single Responsibility Principle?","Each state class has a single responsibility: to implement the behavior appropriate for that particular state. This localizes state-specific code and makes it easier to understand and maintain.

Patterns: State Pattern","¿Cómo demuestra el Patrón State el Principio de Responsabilidad Única?","Cada clase de estado tiene una única responsabilidad: implementar el comportamiento apropiado para ese estado particular. Esto localiza el código específico del estado y lo hace más fácil de entender y mantener.

Patrones: State Pattern","cross-cutting single-responsibility-principle","Cross-Cutting","388"
"In the State Pattern, who controls state transitions?","State transitions can be controlled either by the Context or by the State objects themselves. Fixed transitions belong in the Context, while dynamic transitions that depend on runtime conditions belong in the State classes. This design decision affects which classes are open for modification.

Patterns: State Pattern","En el Patrón State, ¿quién controla las transiciones de estado?","Las transiciones de estado pueden ser controladas por el Context o por los propios objetos State. Las transiciones fijas pertenecen al Context, mientras que las transiciones dinámicas que dependen de condiciones en tiempo de ejecución pertenecen a las clases State. Esta decisión de diseño afecta qué clases están abiertas para modificación.

Patrones: State Pattern","cross-cutting state-transitions","Cross-Cutting","405"
"How does the State Pattern demonstrate Composition over Inheritance?","The State Pattern uses composition to achieve behavioral flexibility instead of relying on inheritance. This allows behavior to be changed dynamically at runtime by switching state objects, which wouldn't be possible with inheritance alone.

Patterns: State Pattern, Strategy Pattern","¿Cómo demuestra el Patrón State Composición sobre Herencia?","El Patrón State usa composición para lograr flexibilidad de comportamiento en lugar de depender de la herencia. Esto permite que el comportamiento cambie dinámicamente en tiempo de ejecución cambiando objetos de estado, lo cual no sería posible solo con herencia.

Patrones: State Pattern, Strategy Pattern","cross-cutting composition-over-inheritance","Cross-Cutting","389"
"What common mistakes should be avoided when using the State Pattern?","• Using State Pattern when a simple conditional would suffice (only a few states that rarely change)
• Creating tight coupling between State classes by having them know about each other
• Not considering whether states can be shared (missing Singleton optimization)
• Putting state transition logic in the wrong place (Context vs State classes)
• Creating unnecessary state objects instead of using shared instances","¿Qué errores comunes deben evitarse al usar el Patrón State?","• Usar el Patrón State cuando un condicional simple sería suficiente (solo unos pocos estados que raramente cambian)
• Crear acoplamiento estrecho entre clases State al hacer que se conozcan entre sí
• No considerar si los estados pueden compartirse (perder la optimización Singleton)
• Poner la lógica de transición de estado en el lugar equivocado (Context vs clases State)
• Crear objetos de estado innecesarios en lugar de usar instancias compartidas","anti-pattern state-pattern behavioral","Behavioral","405"
"In the State Pattern gumball machine example, what happens when insertQuarter() is called in the NoQuarterState?","The NoQuarterState prints ""You inserted a quarter"" and then calls gumballMachine.setState(gumballMachine.getHasQuarterState()) to transition the machine to the HasQuarterState. This demonstrates how a ConcreteState can handle both behavior (printing message) and state transitions.","En el ejemplo de la máquina de chicles del Patrón State, ¿qué sucede cuando se llama a insertQuarter() en el NoQuarterState?","El NoQuarterState imprime ""You inserted a quarter"" y luego llama a gumballMachine.setState(gumballMachine.getHasQuarterState()) para transicionar la máquina al HasQuarterState. Esto demuestra cómo un ConcreteState puede manejar tanto el comportamiento (imprimir mensaje) como las transiciones de estado.","implementation state-pattern behavioral state-transitions","Behavioral","394"
"Why might you implement State objects as Singletons?","State objects can be implemented as Singletons when they contain no instance variables and their behavior depends only on the Context they're given. This allows multiple Context objects to share the same state instances, reducing memory overhead and object creation costs.","¿Por qué podrías implementar objetos State como Singletons?","Los objetos State pueden implementarse como Singletons cuando no contienen variables de instancia y su comportamiento depende solo del Context que se les proporciona. Esto permite que múltiples objetos Context compartan las mismas instancias de estado, reduciendo la sobrecarga de memoria y los costos de creación de objetos.","implementation state-pattern behavioral singleton","Behavioral","408"
"How does the State Pattern eliminate large conditional statements?","Instead of having one class with large if/else or switch statements checking the current state for every operation, the State Pattern distributes state-specific behavior across separate ConcreteState classes. Each state class only contains the behavior relevant to that state, and the Context simply delegates to the current state object.","¿Cómo elimina el Patrón State las grandes declaraciones condicionales?","En lugar de tener una clase con grandes declaraciones if/else o switch verificando el estado actual para cada operación, el Patrón State distribuye el comportamiento específico del estado en clases ConcreteState separadas. Cada clase de estado solo contiene el comportamiento relevante para ese estado, y el Context simplemente delega al objeto de estado actual.","key-concepts state-pattern behavioral","Behavioral","387"
"What is the intent of the Template Method pattern?","Define the skeleton of an algorithm in a method, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.","¿Cuál es el propósito del patrón Template Method (Método Plantilla)?","Definir el esqueleto de un algoritmo en un método, delegando algunos pasos a las subclases. Template Method permite a las subclases redefinir ciertos pasos de un algoritmo sin cambiar la estructura del algoritmo.","intent template-method behavioral","Behavioral","275"
"When would you use the Template Method pattern?","• When you have multiple classes implementing similar algorithms with only minor differences in certain steps
• When you want to control which parts of an algorithm can be overridden by subclasses
• When you want to avoid code duplication across similar classes
• When you want to provide a framework where subclasses can plug in their specific behavior
• When you need to implement the Hollywood Principle (don't call us, we'll call you)","¿Cuándo usarías el patrón Template Method?","• Cuando tienes múltiples clases implementando algoritmos similares con solo diferencias menores en ciertos pasos
• Cuando quieres controlar qué partes de un algoritmo pueden ser sobrescritas por las subclases
• Cuando quieres evitar la duplicación de código entre clases similares
• Cuando quieres proporcionar un framework donde las subclases puedan integrar su comportamiento específico
• Cuando necesitas implementar el Principio de Hollywood (no nos llames, nosotros te llamaremos)","use-case template-method behavioral","Behavioral","275"
"What are the key participants in the Template Method pattern?","• AbstractClass: Defines abstract primitive operations that concrete subclasses implement, and implements the template method defining the algorithm's skeleton
• ConcreteClass: Implements the primitive operations to carry out subclass-specific steps of the algorithm
• Template Method: The method that defines the algorithm's structure, typically declared final to prevent subclasses from changing the sequence
• Primitive Operations: Abstract methods that must be implemented by subclasses
• Hooks: Optional methods with empty or default implementations that subclasses can override
• Concrete Operations: Methods implemented in the abstract class that may be used by the template method or subclasses","¿Cuáles son los participantes clave en el patrón Template Method?","• ClaseAbstracta: Define operaciones primitivas abstractas que las subclases concretas implementan, e implementa el método plantilla que define el esqueleto del algoritmo
• ClaseConcreta: Implementa las operaciones primitivas para llevar a cabo pasos específicos de la subclase del algoritmo
• Método Plantilla: El método que define la estructura del algoritmo, típicamente declarado final para prevenir que las subclases cambien la secuencia
• Operaciones Primitivas: Métodos abstractos que deben ser implementados por las subclases
• Hooks (Ganchos): Métodos opcionales con implementaciones vacías o predeterminadas que las subclases pueden sobrescribir
• Operaciones Concretas: Métodos implementados en la clase abstracta que pueden ser usados por el método plantilla o las subclases","key-concepts template-method behavioral","Behavioral","275"
"What are the benefits and drawbacks of the Template Method pattern?","Benefits:
• Maximizes code reuse by putting common algorithm code in the superclass
• Provides a framework that can be extended with new concrete classes easily
• Centralizes knowledge about the algorithm in one place
• Protects the algorithm structure by declaring the template method final
• Provides control over which parts of the algorithm can be extended
• Inverts control flow (Hollywood Principle) - superclass calls subclass methods rather than vice versa
• Reduces code duplication across similar classes

Drawbacks:
• Creates dependency between subclasses and superclass
• Can lead to a proliferation of subclasses if you need many variations
• Less flexible than composition-based approaches like Strategy
• Clients cannot change algorithm at runtime (unlike Strategy pattern)
• Can be harder to debug due to flow of control through multiple classes
• Requires inheritance which is less flexible than composition","¿Cuáles son los beneficios y desventajas del patrón Template Method?","Beneficios:
• Maximiza la reutilización de código al colocar el código común del algoritmo en la superclase
• Proporciona un framework que puede ser extendido fácilmente con nuevas clases concretas
• Centraliza el conocimiento sobre el algoritmo en un solo lugar
• Protege la estructura del algoritmo al declarar el método plantilla como final
• Proporciona control sobre qué partes del algoritmo pueden ser extendidas
• Invierte el flujo de control (Principio de Hollywood) - la superclase llama a los métodos de la subclase en lugar de viceversa
• Reduce la duplicación de código entre clases similares

Desventajas:
• Crea dependencia entre las subclases y la superclase
• Puede llevar a una proliferación de subclases si necesitas muchas variaciones
• Menos flexible que enfoques basados en composición como Strategy
• Los clientes no pueden cambiar el algoritmo en tiempo de ejecución (a diferencia del patrón Strategy)
• Puede ser más difícil de depurar debido al flujo de control a través de múltiples clases
• Requiere herencia que es menos flexible que la composición","benefits-drawbacks template-method behavioral","Behavioral","275"
"What patterns are related to the Template Method pattern?","• Strategy: Both encapsulate algorithms. Template Method uses inheritance while Strategy uses composition. Strategy is more flexible (runtime algorithm selection) while Template Method has less overhead.
• Factory Method: Factory Method is a specialization of Template Method where primitive operations are used to create and return objects
• Hollywood Principle: Template Method is a primary example of the Hollywood Principle - high-level components call low-level components, not the other way around","¿Qué patrones están relacionados con el patrón Template Method?","• Strategy (Estrategia): Ambos encapsulan algoritmos. Template Method usa herencia mientras Strategy usa composición. Strategy es más flexible (selección de algoritmo en tiempo de ejecución) mientras Template Method tiene menos sobrecarga.
• Factory Method (Método de Fábrica): Factory Method es una especialización de Template Method donde las operaciones primitivas se usan para crear y retornar objetos
• Principio de Hollywood: Template Method es un ejemplo primario del Principio de Hollywood - los componentes de alto nivel llaman a los componentes de bajo nivel, no al revés","related-patterns template-method behavioral","Behavioral","275"
"What are key implementation considerations for the Template Method pattern?","• Declare the template method final to prevent subclasses from changing the algorithm structure
• Use abstract methods when subclasses MUST provide an implementation
• Use hooks (methods with empty/default implementations) for optional steps
• Keep the number of abstract methods reasonable to reduce burden on subclasses
• Consider using concrete operations in the abstract class for shared functionality
• Minimize the number of primitive operations to keep subclass implementation simple
• Balance granularity of steps: more granular = more flexible but more work for subclasses","¿Cuáles son las consideraciones clave de implementación para el patrón Template Method?","• Declarar el método plantilla como final para prevenir que las subclases cambien la estructura del algoritmo
• Usar métodos abstractos cuando las subclases DEBEN proporcionar una implementación
• Usar hooks (métodos con implementaciones vacías/predeterminadas) para pasos opcionales
• Mantener un número razonable de métodos abstractos para reducir la carga sobre las subclases
• Considerar usar operaciones concretas en la clase abstracta para funcionalidad compartida
• Minimizar el número de operaciones primitivas para mantener simple la implementación de subclases
• Equilibrar la granularidad de los pasos: más granular = más flexible pero más trabajo para las subclases","implementation template-method behavioral","Behavioral","275"
"```java
public abstract class CaffeineBeverage {
  final void prepareRecipe() {
    boilWater();
    brew();
    pourInCup();
    addCondiments();
  }
  abstract void brew();
  abstract void addCondiments();
  void boilWater() {
    System.out.println(""Boiling water"");
  }
  void pourInCup() {
    System.out.println(""Pouring into cup"");
  }
}
```
What pattern does this code demonstrate?","Pattern: Template Method
Key elements: Template method (prepareRecipe) defines algorithm skeleton. Some steps (boilWater, pourInCup) are implemented in the abstract class, while others (brew, addCondiments) are abstract and must be implemented by subclasses.","```java
public abstract class CaffeineBeverage {
  final void prepareRecipe() {
    boilWater();
    brew();
    pourInCup();
    addCondiments();
  }
  abstract void brew();
  abstract void addCondiments();
  void boilWater() {
    System.out.println(""Boiling water"");
  }
  void pourInCup() {
    System.out.println(""Pouring into cup"");
  }
}
```
¿Qué patrón demuestra este código?","Patrón: Template Method
Elementos clave: El método plantilla (prepareRecipe) define el esqueleto del algoritmo. Algunos pasos (boilWater, pourInCup) están implementados en la clase abstracta, mientras que otros (brew, addCondiments) son abstractos y deben ser implementados por las subclases.","code-example template-method behavioral java","Behavioral","275"
"```java
public abstract class CaffeineBeverageWithHook {
  final void prepareRecipe() {
    boilWater();
    brew();
    pourInCup();
    if (customerWantsCondiments()) {
      addCondiments();
    }
  }
  boolean customerWantsCondiments() {
    return true;
  }
}
```
What Template Method concept does this demonstrate?","Pattern: Template Method with Hook
Key elements: The hook method 'customerWantsCondiments()' provides a default implementation (return true) but subclasses can override it to control algorithm flow conditionally. Hooks allow optional extension points in the algorithm.","```java
public abstract class CaffeineBeverageWithHook {
  final void prepareRecipe() {
    boilWater();
    brew();
    pourInCup();
    if (customerWantsCondiments()) {
      addCondiments();
    }
  }
  boolean customerWantsCondiments() {
    return true;
  }
}
```
¿Qué concepto de Template Method demuestra esto?","Patrón: Template Method con Hook
Elementos clave: El método hook 'customerWantsCondiments()' proporciona una implementación predeterminada (return true) pero las subclases pueden sobrescribirlo para controlar el flujo del algoritmo condicionalmente. Los hooks permiten puntos de extensión opcionales en el algoritmo.","code-example template-method behavioral java","Behavioral","275"
"What are real-world examples of the Template Method pattern?","• Java Arrays.sort() uses compareTo() as a primitive operation that classes must implement
• Java InputStream read(byte b[], int off, int len) is a template method that uses read() primitive operation
• Swing JFrame uses paint() as a hook method for custom rendering
• Java Applet with init(), start(), stop(), destroy() hook methods for lifecycle management","¿Cuáles son ejemplos del mundo real del patrón Template Method?","• Java Arrays.sort() usa compareTo() como operación primitiva que las clases deben implementar
• Java InputStream read(byte b[], int off, int len) es un método plantilla que usa la operación primitiva read()
• Swing JFrame usa paint() como método hook para renderizado personalizado
• Java Applet con métodos hook init(), start(), stop(), destroy() para gestión del ciclo de vida","real-world template-method behavioral","Behavioral","275"
"What is the intent of the Iterator pattern?","Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.","¿Cuál es el propósito del patrón Iterator (Iterador)?","Proporcionar una forma de acceder a los elementos de un objeto agregado secuencialmente sin exponer su representación subyacente.","intent iterator behavioral","Behavioral","315"
"When would you use the Iterator pattern?","• When you need to access an aggregate object's contents without exposing its internal representation
• When you need to support multiple traversals of aggregate objects
• When you want to provide a uniform interface for traversing different aggregate structures (polymorphic iteration)
• When you want to decouple collection classes from iteration algorithms
• When you have multiple collection implementations that need a consistent interface","¿Cuándo usarías el patrón Iterator?","• Cuando necesitas acceder al contenido de un objeto agregado sin exponer su representación interna
• Cuando necesitas soportar múltiples recorridos de objetos agregados
• Cuando quieres proporcionar una interfaz uniforme para recorrer diferentes estructuras agregadas (iteración polimórfica)
• Cuando quieres desacoplar las clases de colección de los algoritmos de iteración
• Cuando tienes múltiples implementaciones de colecciones que necesitan una interfaz consistente","use-case iterator behavioral","Behavioral","315"
"What are the key participants in the Iterator pattern?","• Iterator: Defines an interface for accessing and traversing elements (hasNext(), next(), remove())
• ConcreteIterator: Implements the Iterator interface and keeps track of the current position in the traversal
• Aggregate: Defines an interface for creating an Iterator object
• ConcreteAggregate: Implements the Iterator creation interface to return an instance of the proper ConcreteIterator","¿Cuáles son los participantes clave en el patrón Iterator?","• Iterator (Iterador): Define una interfaz para acceder y recorrer elementos (hasNext(), next(), remove())
• ConcreteIterator (Iterador Concreto): Implementa la interfaz Iterator y mantiene el rastro de la posición actual en el recorrido
• Aggregate (Agregado): Define una interfaz para crear un objeto Iterator
• ConcreteAggregate (Agregado Concreto): Implementa la interfaz de creación de Iterator para retornar una instancia del ConcreteIterator apropiado","key-concepts iterator behavioral","Behavioral","315"
"What are the benefits and drawbacks of the Iterator pattern?","Benefits:
• Supports multiple simultaneous traversals of an aggregate
• Provides a uniform interface for traversing different aggregate structures (polymorphic iteration)
• Decouples clients from the implementation of collections
• Simplifies the aggregate interface by removing traversal responsibility
• Promotes Single Responsibility Principle - aggregate manages collection, iterator manages traversal
• Allows different iteration strategies without changing the aggregate

Drawbacks:
• Can be overkill for simple collections
• May have performance overhead compared to direct access
• Requires additional classes (ConcreteIterator) to be maintained
• Behavior can be undefined if collection is modified during iteration","¿Cuáles son los beneficios y desventajas del patrón Iterator?","Beneficios:
• Soporta múltiples recorridos simultáneos de un agregado
• Proporciona una interfaz uniforme para recorrer diferentes estructuras agregadas (iteración polimórfica)
• Desacopla a los clientes de la implementación de las colecciones
• Simplifica la interfaz del agregado al eliminar la responsabilidad de recorrido
• Promueve el Principio de Responsabilidad Única - el agregado gestiona la colección, el iterador gestiona el recorrido
• Permite diferentes estrategias de iteración sin cambiar el agregado

Desventajas:
• Puede ser excesivo para colecciones simples
• Puede tener sobrecarga de rendimiento comparado con acceso directo
• Requiere clases adicionales (ConcreteIterator) a mantener
• El comportamiento puede ser indefinido si la colección se modifica durante la iteración","benefits-drawbacks iterator behavioral","Behavioral","315"
"What patterns are related to the Iterator pattern?","• Composite: Often used together. Iterators can be used to traverse Composite structures.
• Factory Method: Iterator pattern class diagram is similar to Factory Method - aggregate decides which concrete iterator to create
• Memento: Can be used together to capture iteration state","¿Qué patrones están relacionados con el patrón Iterator?","• Composite (Compuesto): A menudo se usan juntos. Los iteradores pueden usarse para recorrer estructuras Composite.
• Factory Method (Método de Fábrica): El diagrama de clases del patrón Iterator es similar a Factory Method - el agregado decide qué iterador concreto crear
• Memento: Puede usarse junto con Iterator para capturar el estado de la iteración","related-patterns iterator behavioral","Behavioral","315"
"What are key implementation considerations for the Iterator pattern?","• Iterator interface typically includes hasNext(), next(), and optionally remove()
• ConcreteIterator must track current position in the traversal
• remove() is optional - throw UnsupportedOperationException if not supported
• Be careful with concurrent modifications during iteration
• External iterators (client controls iteration) are more common than internal iterators
• Can extend Iterator interface to add functionality like previous() for bidirectional iteration
• Java collections framework provides built-in iterator support","¿Cuáles son las consideraciones clave de implementación para el patrón Iterator?","• La interfaz Iterator típicamente incluye hasNext(), next(), y opcionalmente remove()
• ConcreteIterator debe mantener el rastro de la posición actual en el recorrido
• remove() es opcional - lanza UnsupportedOperationException si no es soportado
• Ten cuidado con modificaciones concurrentes durante la iteración
• Los iteradores externos (cliente controla la iteración) son más comunes que los iteradores internos
• Puedes extender la interfaz Iterator para agregar funcionalidad como previous() para iteración bidireccional
• El framework de colecciones de Java proporciona soporte integrado de iteradores","implementation iterator behavioral","Behavioral","315"
"```java
public interface Iterator {
  boolean hasNext();
  Object next();
}
```
What pattern does this interface represent?","Pattern: Iterator
Key elements: Simple Iterator interface with two core methods for checking if more elements exist (hasNext) and getting the next element (next).","```java
public interface Iterator {
  boolean hasNext();
  Object next();
}
```
¿Qué patrón representa esta interfaz?","Patrón: Iterator
Elementos clave: Interfaz Iterator simple con dos métodos principales para verificar si existen más elementos (hasNext) y obtener el siguiente elemento (next).","code-example iterator behavioral java","Behavioral","315"
"```java
public class DinerMenuIterator implements Iterator {
  MenuItem[] items;
  int position = 0;
  
  public DinerMenuIterator(MenuItem[] items) {
    this.items = items;
  }
  
  public Object next() {
    MenuItem menuItem = items[position];
    position = position + 1;
    return menuItem;
  }
  
  public boolean hasNext() {
    if (position >= items.length || items[position] == null) {
      return false;
    } else {
      return true;
    }
  }
}
```
What does this code demonstrate?","Pattern: Iterator (ConcreteIterator)
Key elements: Concrete iterator for array-based collection. Tracks position and handles traversal logic including null checking for partially filled arrays.","```java
public class DinerMenuIterator implements Iterator {
  MenuItem[] items;
  int position = 0;
  
  public DinerMenuIterator(MenuItem[] items) {
    this.items = items;
  }
  
  public Object next() {
    MenuItem menuItem = items[position];
    position = position + 1;
    return menuItem;
  }
  
  public boolean hasNext() {
    if (position >= items.length || items[position] == null) {
      return false;
    } else {
      return true;
    }
  }
}
```
¿Qué demuestra este código?","Patrón: Iterator (ConcreteIterator)
Elementos clave: Iterador concreto para colección basada en arreglo. Mantiene el rastro de la posición y maneja la lógica de recorrido incluyendo verificación de nulos para arreglos parcialmente llenos.","code-example iterator behavioral java","Behavioral","315"
"```java
Iterator iterator = menu.createIterator();
while (iterator.hasNext()) {
  MenuItem item = (MenuItem)iterator.next();
  System.out.println(item.getName());
}
```
What principle does this client code demonstrate?","Pattern: Iterator (Client usage)
Key elements: Client uses iterator without knowing internal collection structure. Same code works for arrays, ArrayLists, Hashtables, etc. Demonstrates polymorphic iteration and programming to interfaces.","```java
Iterator iterator = menu.createIterator();
while (iterator.hasNext()) {
  MenuItem item = (MenuItem)iterator.next();
  System.out.println(item.getName());
}
```
¿Qué principio demuestra este código del cliente?","Patrón: Iterator (uso del cliente)
Elementos clave: El cliente usa el iterador sin conocer la estructura interna de la colección. El mismo código funciona para arreglos, ArrayLists, Hashtables, etc. Demuestra iteración polimórfica y programación a interfaces.","code-example iterator behavioral java","Behavioral","315"
"What are real-world examples of the Iterator pattern?","• Java Collections Framework - ArrayList.iterator(), HashMap.values().iterator()
• Java Enumeration interface (older, replaced by Iterator)
• Database result sets that allow sequential access to query results
• File system directory traversal
• Tree and graph traversal algorithms","¿Cuáles son ejemplos del mundo real del patrón Iterator?","• Java Collections Framework - ArrayList.iterator(), HashMap.values().iterator()
• Interfaz Java Enumeration (más antigua, reemplazada por Iterator)
• Conjuntos de resultados de bases de datos que permiten acceso secuencial a los resultados de consultas
• Recorrido de directorios del sistema de archivos
• Algoritmos de recorrido de árboles y grafos","real-world iterator behavioral","Behavioral","315"
"Compare Template Method vs Strategy pattern","Similarities:
• Both encapsulate algorithms
• Both provide ways to vary behavior

Differences:
• Template Method uses inheritance, Strategy uses composition
• Template Method defines algorithm structure in superclass, Strategy encapsulates entire algorithm
• Template Method algorithm fixed at compile-time, Strategy can change at runtime
• Template Method has less overhead, Strategy is more flexible

When to use each:
• Template Method: When algorithm structure is stable and only certain steps vary
• Strategy: When you need to switch algorithms at runtime or avoid inheritance","Compara Template Method vs el patrón Strategy","Similitudes:
• Ambos encapsulan algoritmos
• Ambos proporcionan formas de variar el comportamiento

Diferencias:
• Template Method usa herencia, Strategy usa composición
• Template Method define la estructura del algoritmo en la superclase, Strategy encapsula el algoritmo completo
• El algoritmo de Template Method se fija en tiempo de compilación, Strategy puede cambiar en tiempo de ejecución
• Template Method tiene menos sobrecarga, Strategy es más flexible

Cuándo usar cada uno:
• Template Method: Cuando la estructura del algoritmo es estable y solo ciertos pasos varían
• Strategy: Cuando necesitas cambiar algoritmos en tiempo de ejecución o evitar la herencia","comparison template-method strategy-pattern","Comparison","275"
"Which patterns use the Hollywood Principle?","The Hollywood Principle states 'Don't call us, we'll call you' - high-level components determine when and how low-level components are used. This prevents dependency rot where components depend on each other in complex ways. Low-level components hook into a system but high-level components control them.

Patterns: Template Method (superclass calls subclass methods), Factory Method (framework calls factory methods), Observer (subject notifies observers)","¿Qué patrones usan el Principio de Hollywood?","El Principio de Hollywood establece 'No nos llames, nosotros te llamaremos' - los componentes de alto nivel determinan cuándo y cómo se usan los componentes de bajo nivel. Esto previene la pudrición de dependencias donde los componentes dependen unos de otros de formas complejas. Los componentes de bajo nivel se enganchan en un sistema pero los componentes de alto nivel los controlan.

Patrones: Template Method (la superclase llama a los métodos de la subclase), Factory Method (el framework llama a los métodos de fábrica), Observer (el sujeto notifica a los observadores)","cross-cutting hollywood-principle","Cross-Cutting","275"
"Which patterns promote the Single Responsibility Principle?","The Single Responsibility Principle states that a class should have only one reason to change. Each responsibility is an area of potential change. Multiple responsibilities mean multiple reasons to change. Related to cohesion - classes with high cohesion are designed around related functions, while low cohesion indicates unrelated functions grouped together.

Patterns: Iterator (separates collection management from traversal), Strategy (separates algorithm from context), Template Method (separates algorithm structure from implementation details)","¿Qué patrones promueven el Principio de Responsabilidad Única?","El Principio de Responsabilidad Única establece que una clase debe tener solo una razón para cambiar. Cada responsabilidad es un área de cambio potencial. Múltiples responsabilidades significan múltiples razones para cambiar. Relacionado con la cohesión - las clases con alta cohesión están diseñadas alrededor de funciones relacionadas, mientras que la baja cohesión indica funciones no relacionadas agrupadas.

Patrones: Iterator (separa la gestión de colecciones del recorrido), Strategy (separa el algoritmo del contexto), Template Method (separa la estructura del algoritmo de los detalles de implementación)","cross-cutting single-responsibility","Cross-Cutting","315"
"What is the Principle of Least Knowledge and which patterns use it?","Talk only to your immediate friends. From any method, only invoke methods that belong to: (1) the object itself, (2) objects passed as parameters, (3) objects the method creates, (4) components of the object. This prevents building fragile systems with many coupled dependencies. Reduces dependencies but may require more wrapper classes and increase complexity.

Patterns: Facade (provides simple interface), Template Method (controlled interaction through defined methods), Iterator (hides internal collection structure)","¿Qué es el Principio de Mínimo Conocimiento y qué patrones lo usan?","Habla solo con tus amigos inmediatos. Desde cualquier método, invoca solo métodos que pertenecen a: (1) el objeto mismo, (2) objetos pasados como parámetros, (3) objetos que el método crea, (4) componentes del objeto. Esto previene construir sistemas frágiles con muchas dependencias acopladas. Reduce dependencias pero puede requerir más clases wrapper e incrementar la complejidad.

Patrones: Facade (proporciona interfaz simple), Template Method (interacción controlada a través de métodos definidos), Iterator (oculta la estructura interna de la colección)","cross-cutting principle-of-least-knowledge","Cross-Cutting","265"
"Which patterns demonstrate Encapsulate What Varies?","This principle states: Identify aspects of code that vary and separate them from what stays the same. In Iterator, the iteration mechanism varies based on collection type. In Template Method, certain algorithm steps vary while the overall structure stays the same.

Patterns: Iterator (encapsulates traversal logic), Template Method (encapsulates varying algorithm steps), Strategy (encapsulates interchangeable algorithms)","¿Qué patrones demuestran Encapsular lo que Varía?","Este principio establece: Identifica aspectos del código que varían y sepáralos de lo que permanece igual. En Iterator, el mecanismo de iteración varía según el tipo de colección. En Template Method, ciertos pasos del algoritmo varían mientras que la estructura general permanece igual.

Patrones: Iterator (encapsula la lógica de recorrido), Template Method (encapsula pasos variables del algoritmo), Strategy (encapsula algoritmos intercambiables)","cross-cutting encapsulation","Cross-Cutting","315"
"Which patterns exemplify Programming to Interfaces, Not Implementations?","This principle states that clients should depend on interfaces rather than concrete classes. This reduces coupling and increases flexibility. Seen in Iterator where Waitress depends on Menu interface and Iterator interface rather than concrete menu classes.

Patterns: Iterator (Iterator and Aggregate interfaces), Strategy (Strategy interface), Factory Method (Product interface), Adapter (Target interface), Facade (unified interface)","¿Qué patrones ejemplifican Programar a Interfaces, No a Implementaciones?","Este principio establece que los clientes deben depender de interfaces en lugar de clases concretas. Esto reduce el acoplamiento y aumenta la flexibilidad. Se ve en Iterator donde Waitress depende de la interfaz Menu y la interfaz Iterator en lugar de clases de menú concretas.

Patrones: Iterator (interfaces Iterator y Aggregate), Strategy (interfaz Strategy), Factory Method (interfaz Product), Adapter (interfaz Target), Facade (interfaz unificada)","cross-cutting program-to-interfaces","Cross-Cutting","315"
"What are hooks in the Template Method pattern and when are they used?","Hooks are methods declared in abstract class with empty or default implementations. Subclasses can override hooks but don't have to. Provides optional extension points in an algorithm.

Examples: paint() in JFrame for custom rendering, customerWantsCondiments() in beverage example to control whether condiments are added

Use when: You want to give subclasses the option to react to certain steps in an algorithm, but it's not required","¿Qué son los hooks en el patrón Template Method y cuándo se usan?","Los hooks son métodos declarados en la clase abstracta con implementaciones vacías o predeterminadas. Las subclases pueden sobrescribir los hooks pero no tienen que hacerlo. Proporciona puntos de extensión opcionales en un algoritmo.

Ejemplos: paint() en JFrame para renderizado personalizado, customerWantsCondiments() en el ejemplo de bebidas para controlar si se añaden condimentos

Usar cuando: Quieres dar a las subclases la opción de reaccionar a ciertos pasos en un algoritmo, pero no es requerido","cross-cutting hooks template-method","Cross-Cutting","275"
"What is polymorphic iteration and which pattern enables it?","Polymorphic iteration means writing code that can iterate over any collection as long as it supports Iterator. Creates polymorphic code that works with multiple aggregate types without knowing their implementation details.

Enabled by: Iterator pattern

Benefit: Client code remains the same whether iterating over ArrayList, array, HashMap, or custom collection. The iterator abstracts the traversal mechanism.","¿Qué es la iteración polimórfica y qué patrón la habilita?","La iteración polimórfica significa escribir código que puede iterar sobre cualquier colección siempre que soporte Iterator. Crea código polimórfico que funciona con múltiples tipos de agregados sin conocer sus detalles de implementación.

Habilitado por: patrón Iterator

Beneficio: El código del cliente permanece igual ya sea iterando sobre ArrayList, arreglo, HashMap o colección personalizada. El iterador abstrae el mecanismo de recorrido.","cross-cutting polymorphic-iteration iterator","Cross-Cutting","315"
"What is cohesion and which patterns promote high cohesion?","Cohesion is a measure of how closely a class or module supports a single purpose or responsibility. High cohesion means designed around related functions. Low cohesion means unrelated functions grouped together. Classes adhering to Single Responsibility Principle tend to have high cohesion.

Patterns promoting high cohesion: Iterator (each class has single purpose: collection management OR traversal), Template Method (abstract class handles algorithm structure, concrete classes handle specific implementations)","¿Qué es la cohesión y qué patrones promueven alta cohesión?","La cohesión es una medida de cuán estrechamente una clase o módulo soporta un único propósito o responsabilidad. Alta cohesión significa diseñado alrededor de funciones relacionadas. Baja cohesión significa funciones no relacionadas agrupadas juntas. Las clases que se adhieren al Principio de Responsabilidad Única tienden a tener alta cohesión.

Patrones que promueven alta cohesión: Iterator (cada clase tiene un único propósito: gestión de colección O recorrido), Template Method (la clase abstracta maneja la estructura del algoritmo, las clases concretas manejan implementaciones específicas)","cross-cutting cohesion","Cross-Cutting","315"
"What is the intent of the Singleton Pattern?","Ensure a class has only one instance and provide a global point of access to it.","¿Cuál es la intención del Patrón Singleton?","Asegurar que una clase tenga solo una instancia y proporcionar un punto de acceso global a ella.","intent singleton creational","Creational","186"
"When would you use the Singleton Pattern?","- When you need at most one instance of a class in your application
- When you need to provide a global access point to that instance
- When you want to control access to a sole instance
- For managing shared resources like thread pools, caches, or database connections","¿Cuándo usarías el Patrón Singleton?","- Cuando necesitas como máximo una instancia de una clase en tu aplicación
- Cuando necesitas proporcionar un punto de acceso global a esa instancia
- Cuando quieres controlar el acceso a una única instancia
- Para gestionar recursos compartidos como pools de hilos, cachés o conexiones de base de datos","use-case singleton creational","Creational","186"
"What are the benefits and drawbacks of the Singleton Pattern?","Benefits:
- Controlled access to sole instance
- Reduced namespace pollution
- Permits refinement of operations and representation
- More flexible than class operations

Drawbacks:
- Difficult to test
- Hidden dependencies
- Can violate Single Responsibility Principle
- Multiple class loaders could defeat implementation","¿Cuáles son los beneficios y desventajas del Patrón Singleton?","Beneficios:
- Acceso controlado a la única instancia
- Reducción de la contaminación del espacio de nombres
- Permite refinamiento de operaciones y representación
- Más flexible que operaciones de clase

Desventajas:
- Difícil de probar
- Dependencias ocultas
- Puede violar el Principio de Responsabilidad Única
- Múltiples cargadores de clases podrían anular la implementación","benefits-drawbacks singleton creational","Creational","186"
"What are key implementation considerations for the Singleton Pattern?","- Use a private constructor to prevent direct instantiation
- Use a static method combined with a static variable to hold the instance
- Examine performance and resource constraints for multithreaded applications
- Consider all applications multithreaded when designing
- Options for thread-safe implementation: synchronize getInstance(), eager instantiation, or double-checked locking (Java 5+)
- Be careful with multiple class loaders","¿Cuáles son las consideraciones clave de implementación para el Patrón Singleton?","- Usar un constructor privado para prevenir la instanciación directa
- Usar un método estático combinado con una variable estática para mantener la instancia
- Examinar restricciones de rendimiento y recursos para aplicaciones multihilo
- Considerar todas las aplicaciones como multihilo al diseñar
- Opciones para implementación segura en hilos: sincronizar getInstance(), instanciación anticipada, o bloqueo de doble verificación (Java 5+)
- Tener cuidado con múltiples cargadores de clases","implementation singleton creational","Creational","186"
"What are real-world examples of the Singleton Pattern?","- ChocolateBoiler control system
- Thread pools
- Database connection pools
- Logging objects
- Device drivers
- Configuration managers
- Caches
- Dialog boxes in GUI applications","¿Cuáles son ejemplos del mundo real del Patrón Singleton?","- Sistema de control ChocolateBoiler
- Pools de hilos
- Pools de conexiones de base de datos
- Objetos de registro (logging)
- Controladores de dispositivos
- Gestores de configuración
- Cachés
- Cuadros de diálogo en aplicaciones GUI","real-world singleton creational","Creational","186"
"What is the intent of the Command Pattern?","Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.","¿Cuál es la intención del Patrón Command?","Encapsular una petición como un objeto, permitiendo así parametrizar clientes con diferentes peticiones, encolar o registrar peticiones, y soportar operaciones que se pueden deshacer.","intent command behavioral","Behavioral","191"
"When would you use the Command Pattern?","- When you need to decouple an object making requests from the objects that know how to perform the requests
- When you want to parameterize objects with actions to perform
- When you need to support undo/redo operations
- When you want to queue or log requests
- When you need to support transactional systems
- When you want to structure a system around high-level operations built on primitives operations","¿Cuándo usarías el Patrón Command?","- Cuando necesitas desacoplar un objeto que hace peticiones de los objetos que saben cómo realizar las peticiones
- Cuando quieres parametrizar objetos con acciones a realizar
- Cuando necesitas soportar operaciones de deshacer/rehacer
- Cuando quieres encolar o registrar peticiones
- Cuando necesitas soportar sistemas transaccionales
- Cuando quieres estructurar un sistema alrededor de operaciones de alto nivel construidas sobre operaciones primitivas","use-case command behavioral","Behavioral","191"
"What are the key participants in the Command Pattern?","- Command: Declares an interface for executing an operation, typically with execute() and undo() methods
- ConcreteCommand: Defines a binding between a Receiver object and an action. Implements execute() by invoking corresponding operations on Receiver
- Client: Creates a ConcreteCommand object and sets its Receiver
- Invoker: Asks the command to carry out the request by calling execute()
- Receiver: Knows how to perform the work needed to carry out the request. Any class can act as a Receiver","¿Cuáles son los participantes clave en el Patrón Command?","- Command: Declara una interfaz para ejecutar una operación, típicamente con métodos execute() y undo()
- ConcreteCommand: Define una vinculación entre un objeto Receiver y una acción. Implementa execute() invocando las operaciones correspondientes en Receiver
- Client: Crea un objeto ConcreteCommand y establece su Receiver
- Invoker: Solicita al comando que ejecute la petición llamando a execute()
- Receiver: Sabe cómo realizar el trabajo necesario para ejecutar la petición. Cualquier clase puede actuar como Receiver","key-concepts command behavioral","Behavioral","191"
"What are the benefits and drawbacks of the Command Pattern?","Benefits:
- Decouples object making request from object that knows how to perform it
- Commands are first-class objects that can be manipulated and extended
- Commands can be assembled into composite commands (MacroCommand)
- Easy to add new Commands without changing existing code
- Supports undo/redo operations
- Supports logging and transactional systems
- Supports queuing requests

Drawbacks:
- Can result in many small command classes
- May increase complexity for simple operations","¿Cuáles son los beneficios y desventajas del Patrón Command?","Beneficios:
- Desacopla el objeto que hace la petición del objeto que sabe cómo realizarla
- Los comandos son objetos de primera clase que pueden ser manipulados y extendidos
- Los comandos pueden ser ensamblados en comandos compuestos (MacroCommand)
- Fácil agregar nuevos Commands sin cambiar el código existente
- Soporta operaciones de deshacer/rehacer
- Soporta registro y sistemas transaccionales
- Soporta encolar peticiones

Desventajas:
- Puede resultar en muchas clases de comando pequeñas
- Puede aumentar la complejidad para operaciones simples","benefits-drawbacks command behavioral","Behavioral","191"
"What patterns are related to the Command Pattern?","- Composite: MacroCommand is an example of Composite pattern - commands composed of other commands
- Memento: Can be used for maintaining undo state","¿Qué patrones están relacionados con el Patrón Command?","- Composite: MacroCommand es un ejemplo del patrón Composite - comandos compuestos de otros comandos
- Memento: Puede ser usado para mantener el estado de deshacer","related-patterns command behavioral","Behavioral","191"
"What are key implementation considerations for the Command Pattern?","- All command objects implement the same interface with at least execute() method
- Command object encapsulates a request by binding together actions and receiver
- For undo support, add undo() method that reverses execute()
- Invoker can be parameterized with different commands, even dynamically at runtime
- Use NoCommand object as null object pattern to avoid null checks
- For logging/recovery: add store() and load() methods, use serialization
- MacroCommands allow multiple commands to be executed as one
- Smart commands can implement logic themselves rather than delegating to receiver","¿Cuáles son las consideraciones clave de implementación para el Patrón Command?","- Todos los objetos de comando implementan la misma interfaz con al menos el método execute()
- El objeto de comando encapsula una petición vinculando acciones y receptor
- Para soporte de deshacer, agregar método undo() que revierta execute()
- El Invoker puede ser parametrizado con diferentes comandos, incluso dinámicamente en tiempo de ejecución
- Usar objeto NoCommand como patrón de objeto nulo para evitar verificaciones de null
- Para registro/recuperación: agregar métodos store() y load(), usar serialización
- Los MacroCommands permiten que múltiples comandos se ejecuten como uno
- Los comandos inteligentes pueden implementar lógica ellos mismos en lugar de delegar al receptor","implementation command behavioral","Behavioral","191"
"What are real-world examples of the Command Pattern?","- Home automation remote control
- Job queues and thread pools
- Schedulers
- Web server request handling
- Spreadsheet operations with undo
- Transaction systems","¿Cuáles son ejemplos del mundo real del Patrón Command?","- Control remoto de domótica
- Colas de trabajos y pools de hilos
- Planificadores
- Manejo de peticiones en servidor web
- Operaciones de hoja de cálculo con deshacer
- Sistemas transaccionales","real-world command behavioral","Behavioral","191"
"public interface Command {
  public void execute();
  public void undo();
}","Pattern: Command Pattern
Key elements: Command interface with execute and undo methods. This is the base interface that all concrete commands implement to encapsulate requests as objects.","public interface Command {
  public void execute();
  public void undo();
}","Patrón: Patrón Command
Elementos clave: Interfaz Command con métodos execute y undo. Esta es la interfaz base que todos los comandos concretos implementan para encapsular peticiones como objetos.","code-example command behavioral java","Behavioral","191"
"public class LightOnCommand implements Command {
  Light light;
  
  public LightOnCommand(Light light) {
    this.light = light;
  }
  
  public void execute() {
    light.on();
  }
  
  public void undo() {
    light.off();
  }
}","Pattern: Command Pattern
Key elements: Concrete command that turns a light on. Constructor takes the receiver (Light) and execute() calls the action on the receiver. The undo() method reverses the action.","public class LightOnCommand implements Command {
  Light light;
  
  public LightOnCommand(Light light) {
    this.light = light;
  }
  
  public void execute() {
    light.on();
  }
  
  public void undo() {
    light.off();
  }
}","Patrón: Patrón Command
Elementos clave: Comando concreto que enciende una luz. El constructor toma el receptor (Light) y execute() llama a la acción en el receptor. El método undo() revierte la acción.","code-example command behavioral java","Behavioral","191"
"public class MacroCommand implements Command {
  Command[] commands;
  
  public MacroCommand(Command[] commands) {
    this.commands = commands;
  }
  
  public void execute() {
    for (int i = 0; i < commands.length; i++) {
      commands[i].execute();
    }
  }
  
  public void undo() {
    for (int i = 0; i < commands.length; i++) {
      commands[i].undo();
    }
  }
}","Pattern: Command Pattern (MacroCommand)
Key elements: MacroCommand executes multiple commands in sequence, allowing party mode functionality. This is an example of the Composite pattern applied to commands.","public class MacroCommand implements Command {
  Command[] commands;
  
  public MacroCommand(Command[] commands) {
    this.commands = commands;
  }
  
  public void execute() {
    for (int i = 0; i < commands.length; i++) {
      commands[i].execute();
    }
  }
  
  public void undo() {
    for (int i = 0; i < commands.length; i++) {
      commands[i].undo();
    }
  }
}","Pattern: Command Pattern (MacroCommand)
Key elements: MacroCommand executes multiple commands in sequence, allowing party mode functionality. This is an example of the Composite pattern applied to commands.","code-example command behavioral java","Behavioral","191"
"What is the intent of the Adapter Pattern?","Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.","What is the intent of the Adapter Pattern?","Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.","intent adapter structural","Structural","235"
"When would you use the Adapter Pattern?","- When you want to use an existing class but its interface doesn't match the one you need
- When you need to create a reusable class that cooperates with unrelated classes with incompatible interfaces
- When you need to use several existing subclasses but it's impractical to adapt their interface by subclassing each one","When would you use the Adapter Pattern?","- When you want to use an existing class but its interface doesn't match the one you need
- When you need to create a reusable class that cooperates with unrelated classes with incompatible interfaces
- When you need to use several existing subclasses but it's impractical to adapt their interface by subclassing each one","use-case adapter structural","Structural","235"
"What are the key participants in the Adapter Pattern?","- Target: Defines the domain-specific interface that Client uses
- Client: Collaborates with objects conforming to the Target interface
- Adaptee: Defines an existing interface that needs adapting
- Adapter: Adapts the interface of Adaptee to the Target interface","What are the key participants in the Adapter Pattern?","- Target: Defines the domain-specific interface that Client uses
- Client: Collaborates with objects conforming to the Target interface
- Adaptee: Defines an existing interface that needs adapting
- Adapter: Adapts the interface of Adaptee to the Target interface","key-concepts adapter structural","Structural","235"
"What are the benefits and drawbacks of the Adapter Pattern?","Benefits:
- Allows client to use new libraries and subsets without changing code
- Decouples client from implemented interface
- Can work with any subclass of the adaptee (object adapter)
- Introduces only one object with no additional pointer indirection to get to adaptee

Drawbacks:
- Amount of work required is proportional to size of target interface
- Class adapter requires multiple inheritance (not available in Java)
- Class adapter can't adapt a class and all its subclasses","What are the benefits and drawbacks of the Adapter Pattern?","Benefits:
- Allows client to use new libraries and subsets without changing code
- Decouples client from implemented interface
- Can work with any subclass of the adaptee (object adapter)
- Introduces only one object with no additional pointer indirection to get to adaptee

Drawbacks:
- Amount of work required is proportional to size of target interface
- Class adapter requires multiple inheritance (not available in Java)
- Class adapter can't adapt a class and all its subclasses","benefits-drawbacks adapter structural","Structural","235"
"What patterns are related to the Adapter Pattern?","- Decorator: Decorator adds responsibilities without changing interface, while Adapter changes the interface
- Facade: Facade simplifies an interface, Adapter converts one interface to another","What patterns are related to the Adapter Pattern?","- Decorator: Decorator adds responsibilities without changing interface, while Adapter changes the interface
- Facade: Facade simplifies an interface, Adapter converts one interface to another","related-patterns adapter structural","Structural","235"
"What are key implementation considerations for the Adapter Pattern?","- Object Adapter uses composition - adapter holds instance of adaptee
- Class Adapter uses multiple inheritance - adapter subclasses both target and adaptee
- Adapter implements target interface client expects
- Adapter translates requests to adaptee interface
- Two-way adapters can support both interfaces by implementing both
- Job of implementing adapter is proportional to target interface size
- May need to wrap multiple adaptees to provide interface client expects","What are key implementation considerations for the Adapter Pattern?","- Object Adapter uses composition - adapter holds instance of adaptee
- Class Adapter uses multiple inheritance - adapter subclasses both target and adaptee
- Adapter implements target interface client expects
- Adapter translates requests to adaptee interface
- Two-way adapters can support both interfaces by implementing both
- Job of implementing adapter is proportional to target interface size
- May need to wrap multiple adaptees to provide interface client expects","implementation adapter structural","Structural","235"
"What are real-world examples of the Adapter Pattern?","- AC power adapter converting European outlet to US plug
- Enumeration to Iterator adapter in Java collections
- Vendor class integration when interfaces don't match","What are real-world examples of the Adapter Pattern?","- AC power adapter converting European outlet to US plug
- Enumeration to Iterator adapter in Java collections
- Vendor class integration when interfaces don't match","real-world adapter structural","Structural","235"
"public class TurkeyAdapter implements Duck {
  Turkey turkey;
  
  public TurkeyAdapter(Turkey turkey) {
    this.turkey = turkey;
  }
  
  public void quack() {
    turkey.gobble();
  }
  
  public void fly() {
    for(int i=0; i < 5; i++) {
      turkey.fly();
    }
  }
}","Pattern: Adapter Pattern
Key elements: TurkeyAdapter makes a Turkey look like a Duck by implementing Duck interface and delegating to Turkey methods. The fly() method calls turkey.fly() multiple times since turkeys fly shorter distances.","public class TurkeyAdapter implements Duck {
  Turkey turkey;
  
  public TurkeyAdapter(Turkey turkey) {
    this.turkey = turkey;
  }
  
  public void quack() {
    turkey.gobble();
  }
  
  public void fly() {
    for(int i=0; i < 5; i++) {
      turkey.fly();
    }
  }
}","Pattern: Adapter Pattern
Key elements: TurkeyAdapter makes a Turkey look like a Duck by implementing Duck interface and delegating to Turkey methods. The fly() method calls turkey.fly() multiple times since turkeys fly shorter distances.","code-example adapter structural java","Structural","235"
"What is the intent of the Facade Pattern?","Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.","What is the intent of the Facade Pattern?","Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.","intent facade structural","Structural","254"
"When would you use the Facade Pattern?","- When you want to provide a simple interface to a complex subsystem
- When there are many dependencies between clients and implementation classes of an abstraction
- When you want to layer your subsystems - use a facade to define an entry point to each subsystem level
- When you want to decouple client from subsystem components","When would you use the Facade Pattern?","- When you want to provide a simple interface to a complex subsystem
- When there are many dependencies between clients and implementation classes of an abstraction
- When you want to layer your subsystems - use a facade to define an entry point to each subsystem level
- When you want to decouple client from subsystem components","use-case facade structural","Structural","254"
"What are the key participants in the Facade Pattern?","- Facade: Knows which subsystem classes are responsible for a request and delegates client requests to appropriate subsystem objects
- Subsystem classes: Implement subsystem functionality, handle work assigned by Facade object, have no knowledge of facade","What are the key participants in the Facade Pattern?","- Facade: Knows which subsystem classes are responsible for a request and delegates client requests to appropriate subsystem objects
- Subsystem classes: Implement subsystem functionality, handle work assigned by Facade object, have no knowledge of facade","key-concepts facade structural","Structural","254"
"What are the benefits and drawbacks of the Facade Pattern?","Benefits:
- Shields clients from subsystem components
- Promotes weak coupling between subsystem and clients
- Reduces number of objects clients deal with
- Makes subsystem easier to use
- Doesn't prevent access to subsystem classes when needed
- Allows multiple facades for one subsystem
- Simplifies interface while exposing full functionality

Drawbacks:
- Can become a god object coupled to all classes of subsystem if not designed carefully","What are the benefits and drawbacks of the Facade Pattern?","Benefits:
- Shields clients from subsystem components
- Promotes weak coupling between subsystem and clients
- Reduces number of objects clients deal with
- Makes subsystem easier to use
- Doesn't prevent access to subsystem classes when needed
- Allows multiple facades for one subsystem
- Simplifies interface while exposing full functionality

Drawbacks:
- Can become a god object coupled to all classes of subsystem if not designed carefully","benefits-drawbacks facade structural","Structural","254"
"What patterns are related to the Facade Pattern?","- Adapter: Adapter changes interface to match what client expects, Facade simplifies interface. Both may wrap multiple classes but have different intents.
- Decorator: Decorator adds responsibilities without changing interface, Facade provides simplified interface","What patterns are related to the Facade Pattern?","- Adapter: Adapter changes interface to match what client expects, Facade simplifies interface. Both may wrap multiple classes but have different intents.
- Decorator: Decorator adds responsibilities without changing interface, Facade provides simplified interface","related-patterns facade structural","Structural","254"
"What are key implementation considerations for the Facade Pattern?","- Use composition to access all components of subsystem
- Facade provides simplified methods that delegate to subsystem
- Subsystem classes remain accessible for direct use by clients needing advanced functionality
- Facade can add its own logic in addition to delegating to subsystem
- Multiple facades can be created for a given subsystem","What are key implementation considerations for the Facade Pattern?","- Use composition to access all components of subsystem
- Facade provides simplified methods that delegate to subsystem
- Subsystem classes remain accessible for direct use by clients needing advanced functionality
- Facade can add its own logic in addition to delegating to subsystem
- Multiple facades can be created for a given subsystem","implementation facade structural","Structural","254"
"What are real-world examples of the Facade Pattern?","- Home theater system control - simplifying complex interactions with multiple devices
- Computer startup - facade hiding complex boot sequence
- Compiler facade - simplifying lexer, parser, code generator interactions","¿Cuáles son ejemplos del mundo real del Patrón Facade?","- Control de sistema de cine en casa - simplificando interacciones complejas con múltiples dispositivos
- Inicio de computadora - facade ocultando secuencia de arranque compleja
- Facade del compilador - simplificando interacciones de analizador léxico, analizador sintáctico y generador de código","real-world facade structural","Structural","254"
"Compare Adapter Pattern vs Facade Pattern","Similarities:
- Both wrap other classes
- Both provide different interface to wrapped classes
- Both are structural patterns

Differences:
- Adapter converts one interface to another expected by client; Facade simplifies complex interface
- Adapter wraps one class; Facade wraps multiple subsystem classes
- Adapter makes two existing interfaces work together; Facade creates new simplified interface

When to use each:
- Use Adapter when you have incompatible interfaces that need to work together
- Use Facade when you want to simplify a complex subsystem","Compara Patrón Adapter vs Patrón Facade","Similitudes:
- Ambos envuelven otras clases
- Ambos proporcionan interfaz diferente a clases envueltas
- Ambos son patrones estructurales

Diferencias:
- Adapter convierte una interfaz a otra esperada por el cliente; Facade simplifica interfaz compleja
- Adapter envuelve una clase; Facade envuelve múltiples clases de subsistema
- Adapter hace que dos interfaces existentes trabajen juntas; Facade crea nueva interfaz simplificada

Cuándo usar cada uno:
- Usa Adapter cuando tienes interfaces incompatibles que necesitan trabajar juntas
- Usa Facade cuando quieres simplificar un subsistema complejo","comparison adapter facade","Comparison","235"
"Compare Command Pattern vs Strategy Pattern","Similarities:
- Both encapsulate behavior as objects
- Both use composition
- Both follow Open/Closed Principle

Differences:
- Command encapsulates request/action with receiver; Strategy encapsulates algorithm
- Command focuses on decoupling invoker from receiver; Strategy focuses on interchangeable algorithms
- Command supports undo/redo; Strategy doesn't typically support undo
- Command can be queued/logged; Strategy is typically invoked immediately

When to use each:
- Use Command when you need to decouple sender from receiver, support undo, or queue operations
- Use Strategy when you need interchangeable algorithms or behaviors","Compara Patrón Command vs Patrón Strategy","Similitudes:
- Ambos encapsulan comportamiento como objetos
- Ambos usan composición
- Ambos siguen el Principio de Abierto/Cerrado

Diferencias:
- Command encapsula petición/acción con receptor; Strategy encapsula algoritmo
- Command se enfoca en desacoplar invocador de receptor; Strategy se enfoca en algoritmos intercambiables
- Command soporta deshacer/rehacer; Strategy típicamente no soporta deshacer
- Command puede ser encolado/registrado; Strategy se invoca típicamente inmediatamente

Cuándo usar cada uno:
- Usa Command cuando necesitas desacoplar emisor de receptor, soportar deshacer, o encolar operaciones
- Usa Strategy cuando necesitas algoritmos o comportamientos intercambiables","comparison command strategy","Comparison","191"
"Which patterns use the concept 'Encapsulation of Variation'?","All patterns encapsulate what varies to enable flexibility and maintainability.

Patterns: Singleton, Command, Adapter

- Singleton encapsulates object creation
- Command encapsulates method invocation
- Adapter encapsulates interface conversion","¿Qué patrones usan el concepto 'Encapsulación de Variación'?","Todos los patrones encapsulan lo que varía para permitir flexibilidad y mantenibilidad.

Patrones: Singleton, Command, Adapter

- Singleton encapsula la creación de objetos
- Command encapsula la invocación de métodos
- Adapter encapsula la conversión de interfaz","cross-cutting encapsulation","Cross-Cutting","186"
"Which patterns use the concept 'Composition over Inheritance'?","Favoring composition over inheritance provides more flexibility and reduces coupling.

Patterns: Command, Adapter (Object Adapter), Facade

- Object Adapter uses composition to hold adaptee
- Command composes receiver with actions
- Facade composes subsystem components","¿Qué patrones usan el concepto 'Composición sobre Herencia'?","Favorecer la composición sobre la herencia proporciona más flexibilidad y reduce el acoplamiento.

Patrones: Command, Adapter (Object Adapter), Facade

- Object Adapter usa composición para mantener el adaptee
- Command compone el receptor con acciones
- Facade compone componentes del subsistema","cross-cutting composition","Cross-Cutting","191"
"Which patterns use the concept 'Program to Interface, not Implementation'?","Programming to interfaces reduces coupling and increases flexibility.

Patterns: Command, Adapter

- Command pattern uses Command interface so invoker doesn't depend on concrete commands
- Adapter implements target interface to decouple client from adaptee implementation","¿Qué patrones usan el concepto 'Programar a Interfaz, no a Implementación'?","Programar a interfaces reduce el acoplamiento y aumenta la flexibilidad.

Patrones: Command, Adapter

- El patrón Command usa la interfaz Command para que el invocador no dependa de comandos concretos
- Adapter implementa la interfaz target para desacoplar el cliente de la implementación del adaptee","cross-cutting interface","Cross-Cutting","191"
"Which patterns use the concept 'Decoupling'?","Decoupling reduces dependencies between components, improving maintainability and flexibility.

Patterns: Command, Adapter, Facade

- Command decouples invoker from receiver
- Adapter decouples client from incompatible interface
- Facade decouples client from complex subsystem","¿Qué patrones usan el concepto 'Desacoplamiento'?","El desacoplamiento reduce las dependencias entre componentes, mejorando la mantenibilidad y flexibilidad.

Patrones: Command, Adapter, Facade

- Command desacopla el invocador del receptor
- Adapter desacopla el cliente de una interfaz incompatible
- Facade desacopla el cliente de un subsistema complejo","cross-cutting decoupling","Cross-Cutting","191"
"Which patterns use the Null Object Pattern concept?","Null Object Pattern provides a do-nothing object to avoid null checks and simplify code.

Patterns: Command

- NoCommand provides a do-nothing object to avoid null checks in RemoteControl slots
- It's an example of null object pattern used in conjunction with Command pattern","¿Qué patrones usan el concepto del Patrón Null Object?","El Patrón Null Object proporciona un objeto que no hace nada para evitar verificaciones de null y simplificar el código.

Patrones: Command

- NoCommand proporciona un objeto que no hace nada para evitar verificaciones de null en las ranuras del RemoteControl
- Es un ejemplo del patrón null object usado en conjunto con el patrón Command","cross-cutting null-object","Cross-Cutting","191"
"Which patterns use the concept 'Separation of Concerns'?","Separation of concerns divides a system into distinct features with minimal overlap.

Patterns: Command, Facade

- Command separates what needs to be done from how it's done
- Facade separates simple interface from complex subsystem implementation","¿Qué patrones usan el concepto 'Separación de Preocupaciones'?","La separación de preocupaciones divide un sistema en características distintas con superposición mínima.

Patrones: Command, Facade

- Command separa qué necesita ser hecho de cómo se hace
- Facade separa interfaz simple de implementación compleja del subsistema","cross-cutting separation-of-concerns","Cross-Cutting","191"
"What are common misuses of the Singleton Pattern?","- Using Singleton when simple static methods would suffice
- Making everything a Singleton to provide global access (violates encapsulation)
- Not considering thread safety in multithreaded environments
- Using Singleton for mutable state that should be instance-specific
- Making it difficult to test by creating hard dependencies
- Not handling multiple class loaders properly
- Using Singleton to avoid proper dependency injection","¿Cuáles son usos incorrectos comunes del Patrón Singleton?","- Usar Singleton cuando métodos estáticos simples serían suficientes
- Hacer todo un Singleton para proporcionar acceso global (viola encapsulación)
- No considerar seguridad en hilos en entornos multihilo
- Usar Singleton para estado mutable que debería ser específico de instancia
- Hacer difícil probar creando dependencias duras
- No manejar múltiples cargadores de clases apropiadamente
- Usar Singleton para evitar inyección de dependencias apropiada","anti-pattern singleton creational","Creational","186"
"What are common misuses of the Command Pattern?","- Creating commands that are too granular, leading to explosion of tiny classes
- Putting business logic in commands instead of receivers
- Not implementing undo properly (not storing enough state)
- Using Command when a simple callback function would suffice
- Making commands stateful when they should be stateless
- Creating tight coupling between commands and receivers","¿Cuáles son usos incorrectos comunes del Patrón Command?","- Crear comandos que son demasiado granulares, llevando a una explosión de clases diminutas
- Poner lógica de negocio en comandos en lugar de receptores
- No implementar deshacer apropiadamente (no almacenar suficiente estado)
- Usar Command cuando una simple función callback sería suficiente
- Hacer comandos con estado cuando deberían no tener estado
- Crear acoplamiento fuerte entre comandos y receptores","anti-pattern command behavioral","Behavioral","191"
"What are common misuses of the Adapter Pattern?","- Using Adapter to fix poor original design instead of refactoring
- Creating overly complex adapters that do more than interface translation
- Adapter doing too much work beyond simple translation
- Using Adapter when you have control over both interfaces (should standardize instead)
- Creating adapters that violate Liskov Substitution Principle
- Throwing UnsupportedOperationException excessively instead of proper adaptation","¿Cuáles son usos incorrectos comunes del Patrón Adapter?","- Usar Adapter para arreglar diseño original pobre en lugar de refactorizar
- Crear adaptadores excesivamente complejos que hacen más que traducción de interfaz
- Adapter haciendo demasiado trabajo más allá de la simple traducción
- Usar Adapter cuando tienes control sobre ambas interfaces (deberías estandarizar en su lugar)
- Crear adaptadores que violan el Principio de Sustitución de Liskov
- Lanzar UnsupportedOperationException excesivamente en lugar de adaptación apropiada","anti-pattern adapter structural","Structural","235"
"What are common misuses of the Facade Pattern?","- Creating a god object that knows too much about subsystem internals
- Using Facade to hide poor subsystem design instead of fixing it
- Making Facade stateful when it should be stateless
- Creating facades with too many responsibilities
- Preventing access to subsystem when advanced users need it
- Creating circular dependencies between facade and subsystem","¿Cuáles son usos incorrectos comunes del Patrón Facade?","- Crear un objeto divino que sabe demasiado sobre los detalles internos del subsistema
- Usar Facade para ocultar diseño pobre del subsistema en lugar de arreglarlo
- Hacer Facade con estado cuando debería no tener estado
- Crear facades con demasiadas responsabilidades
- Prevenir acceso al subsistema cuando usuarios avanzados lo necesitan
- Crear dependencias circulares entre facade y subsistema","anti-pattern facade structural","Structural","254"
"What is the intent of the Factory Method Pattern?","Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.","¿Cuál es la intención del Patrón Factory Method?","Definir una interfaz para crear un objeto, pero permitir que las subclases decidan qué clase instanciar. Factory Method permite que una clase delegue la instanciación a las subclases.","intent factory-method-pattern creational design-patterns","Creational","106"
"When would you use the Factory Method Pattern?","- When a class can't anticipate the class of objects it must create
- When a class wants its subclasses to specify the objects it creates
- When classes delegate responsibility to one of several helper subclasses and you want to localize the knowledge of which helper subclass is the delegate","¿Cuándo usarías el Patrón Factory Method?","- Cuando una clase no puede anticipar la clase de objetos que debe crear
- Cuando una clase quiere que sus subclases especifiquen los objetos que crea
- Cuando las clases delegan responsabilidad a una de varias subclases auxiliares y quieres localizar el conocimiento de cuál subclase auxiliar es la delegada","use-case factory-method-pattern creational design-patterns","Creational","106"
"What are the key participants in the Factory Method Pattern?","- Creator (abstract class): Defines an abstract factory method that subclasses implement to produce products
- ConcreteCreator: Implements the factory method to create specific product instances
- Product: Defines the interface of objects the factory method creates
- ConcreteProduct: Implements the Product interface","¿Cuáles son los participantes clave en el Patrón Factory Method?","- Creator (clase abstracta): Define un método factory abstracto que las subclases implementan para producir productos
- ConcreteCreator: Implementa el método factory para crear instancias de productos específicos
- Product: Define la interfaz de los objetos que el método factory crea
- ConcreteProduct: Implementa la interfaz Product","key-concepts factory-method-pattern creational design-patterns","Creational","106"
"What are the benefits and drawbacks of the Factory Method Pattern?","Benefits:
- Eliminates the need to bind application-specific classes into code
- Provides hooks for subclasses to customize object creation
- Connects parallel class hierarchies

Drawbacks:
- Clients might have to subclass the Creator class just to create a particular ConcreteProduct object
- Can result in many small classes","¿Cuáles son los beneficios y desventajas del Patrón Factory Method?","Beneficios:
- Elimina la necesidad de vincular clases específicas de la aplicación en el código
- Proporciona puntos de extensión para que las subclases personalicen la creación de objetos
- Conecta jerarquías de clases paralelas

Desventajas:
- Los clientes podrían tener que crear subclases de la clase Creator solo para crear un objeto ConcreteProduct particular
- Puede resultar en muchas clases pequeñas","benefits-drawbacks factory-method-pattern creational design-patterns","Creational","106"
"What patterns are related to the Factory Method Pattern?","- Abstract Factory: Often implemented using Factory Methods. Abstract Factory uses object composition while Factory Method uses inheritance
- Template Method: Factory Methods are often called within Template Methods","¿Qué patrones están relacionados con el Patrón Factory Method?","- Abstract Factory: A menudo se implementa usando Factory Methods. Abstract Factory usa composición de objetos mientras que Factory Method usa herencia
- Template Method: Los Factory Methods a menudo se llaman dentro de Template Methods","related-patterns factory-method-pattern creational design-patterns","Creational","106"
"What are key implementation considerations for the Factory Method Pattern?","- The factory method can be parameterized to create multiple kinds of products
- Factory methods can be implemented as abstract or provide a default implementation
- Creator class may define a default factory method that returns a default ConcreteProduct","¿Cuáles son las consideraciones clave de implementación para el Patrón Factory Method?","- El método factory puede ser parametrizado para crear múltiples tipos de productos
- Los métodos factory pueden implementarse como abstractos o proporcionar una implementación predeterminada
- La clase Creator puede definir un método factory predeterminado que devuelve un ConcreteProduct predeterminado","implementation factory-method-pattern creational design-patterns","Creational","106"
"What code pattern does this represent?

```java
public abstract class PizzaStore {
  public Pizza orderPizza(String type) {
    Pizza pizza = createPizza(type);
    pizza.prepare();
    pizza.bake();
    pizza.cut();
    pizza.box();
    return pizza;
  }
  protected abstract Pizza createPizza(String type);
}
```","Pattern: Factory Method Pattern
Key elements: PizzaStore defines orderPizza framework method and abstract factory method createPizza that subclasses implement to create region-specific pizzas","¿Qué patrón de código representa esto?

```java
public abstract class PizzaStore {
  public Pizza orderPizza(String type) {
    Pizza pizza = createPizza(type);
    pizza.prepare();
    pizza.bake();
    pizza.cut();
    pizza.box();
    return pizza;
  }
  protected abstract Pizza createPizza(String type);
}
```","Patrón: Factory Method Pattern
Elementos clave: PizzaStore define el método marco orderPizza y el método factory abstracto createPizza que las subclases implementan para crear pizzas específicas de cada región","code-example factory-method-pattern creational java design-patterns","Creational","106"
"What are real-world examples of the Factory Method Pattern?","- Document creation in GUI frameworks (different document types)
- Database connection factories
- Regional pizza stores creating region-specific pizzas","¿Cuáles son ejemplos del mundo real del Patrón Factory Method?","- Creación de documentos en frameworks GUI (diferentes tipos de documentos)
- Factories de conexión a bases de datos
- Tiendas de pizza regionales que crean pizzas específicas de cada región","real-world factory-method-pattern creational design-patterns","Creational","106"
"What is the intent of the Abstract Factory Pattern?","Provide an interface for creating families of related or dependent objects without specifying their concrete classes.","¿Cuál es la intención del Patrón Abstract Factory?","Proporcionar una interfaz para crear familias de objetos relacionados o dependientes sin especificar sus clases concretas.","intent abstract-factory-pattern creational design-patterns","Creational","106"
"When would you use the Abstract Factory Pattern?","- A system should be independent of how its products are created, composed, and represented
- A system should be configured with one of multiple families of products
- A family of related product objects is designed to be used together and you need to enforce this constraint
- You want to provide a class library of products and reveal only their interfaces, not implementations","¿Cuándo usarías el Patrón Abstract Factory?","- Un sistema debe ser independiente de cómo se crean, componen y representan sus productos
- Un sistema debe configurarse con una de múltiples familias de productos
- Una familia de objetos de producto relacionados está diseñada para usarse junta y necesitas hacer cumplir esta restricción
- Quieres proporcionar una biblioteca de clases de productos y revelar solo sus interfaces, no las implementaciones","use-case abstract-factory-pattern creational design-patterns","Creational","106"
"What are the key participants in the Abstract Factory Pattern?","- AbstractFactory: Declares an interface for operations that create abstract product objects
- ConcreteFactory: Implements operations to create concrete product objects
- AbstractProduct: Declares an interface for a type of product object
- ConcreteProduct: Defines a product object to be created by the corresponding concrete factory; implements the AbstractProduct interface
- Client: Uses only interfaces declared by AbstractFactory and AbstractProduct classes","¿Cuáles son los participantes clave en el Patrón Abstract Factory?","- AbstractFactory: Declara una interfaz para operaciones que crean objetos de producto abstractos
- ConcreteFactory: Implementa las operaciones para crear objetos de producto concretos
- AbstractProduct: Declara una interfaz para un tipo de objeto de producto
- ConcreteProduct: Define un objeto de producto que será creado por la factory concreta correspondiente; implementa la interfaz AbstractProduct
- Client: Usa solo las interfaces declaradas por las clases AbstractFactory y AbstractProduct","key-concepts abstract-factory-pattern creational design-patterns","Creational","106"
"What are the benefits and drawbacks of the Abstract Factory Pattern?","Benefits:
- Isolates concrete classes from the client
- Makes exchanging product families easy
- Promotes consistency among products
- Supports variations through different concrete factories

Drawbacks:
- Supporting new kinds of products is difficult - requires extending the factory interface, which involves changing the AbstractFactory class and all of its subclasses","¿Cuáles son los beneficios y desventajas del Patrón Abstract Factory?","Beneficios:
- Aísla las clases concretas del cliente
- Facilita el intercambio de familias de productos
- Promueve la consistencia entre productos
- Soporta variaciones a través de diferentes factories concretas

Desventajas:
- Soportar nuevos tipos de productos es difícil - requiere extender la interfaz de la factory, lo que implica cambiar la clase AbstractFactory y todas sus subclases","benefits-drawbacks abstract-factory-pattern creational design-patterns","Creational","106"
"What patterns are related to the Abstract Factory Pattern?","- Factory Method: Abstract Factory classes are often implemented with Factory Methods, but they can also be implemented using Prototype
- Singleton: A concrete factory is often a Singleton","¿Qué patrones están relacionados con el Patrón Abstract Factory?","- Factory Method: Las clases Abstract Factory a menudo se implementan con Factory Methods, pero también pueden implementarse usando Prototype
- Singleton: Una factory concreta a menudo es un Singleton","related-patterns abstract-factory-pattern creational design-patterns","Creational","106"
"What are key implementation considerations for the Abstract Factory Pattern?","- Factories are often implemented as singletons
- Creating products is usually done with factory methods, but can also use Prototype
- A concrete factory is often implemented as a Singleton","¿Cuáles son las consideraciones clave de implementación para el Patrón Abstract Factory?","- Las factories a menudo se implementan como singletons
- La creación de productos generalmente se realiza con métodos factory, pero también puede usar Prototype
- Una factory concreta a menudo se implementa como un Singleton","implementation abstract-factory-pattern creational design-patterns","Creational","106"
"What code pattern does this represent?

```java
public interface PizzaIngredientFactory {
  public Dough createDough();
  public Sauce createSauce();
  public Cheese createCheese();
  public Clams createClam();
}
```","Pattern: Abstract Factory Pattern
Key elements: Abstract factory defining interface for creating a family of related pizza ingredients - all factory methods return abstract product types","¿Qué patrón de código representa esto?

```java
public interface PizzaIngredientFactory {
  public Dough createDough();
  public Sauce createSauce();
  public Cheese createCheese();
  public Veggies[] createVeggies();
  public Pepperoni createPepperoni();
  public Clams createClam();
}
```","Patrón: Abstract Factory Pattern
Elementos clave: Factory abstracta que declara métodos para crear una familia de productos relacionados (ingredientes de pizza) sin especificar sus clases concretas","code-example abstract-factory-pattern creational java design-patterns","Creational","106"
"What code pattern does this represent?

```java
public class NYPizzaIngredientFactory implements PizzaIngredientFactory {
  public Dough createDough() { return new ThinCrustDough(); }
  public Sauce createSauce() { return new MarinaraSauce(); }
  public Cheese createCheese() { return new ReggianoCheese(); }
  public Clams createClam() { return new FreshClams(); }
}
```","Pattern: Abstract Factory Pattern
Key elements: Concrete factory creating New York style ingredients - all products in this family are designed to work together","¿Cuáles son ejemplos del mundo real del Patrón Abstract Factory?","- Kits de widgets de GUI para diferentes sistemas operativos (Windows, Mac, Linux)
- Factories de ingredientes de pizza para diferentes estilos regionales
- Factories de temas para aplicaciones (tema claro, tema oscuro)
- Frameworks de prueba que crean suites de objetos de prueba relacionados","code-example abstract-factory-pattern creational java design-patterns","Creational","106"
"What are real-world examples of the Abstract Factory Pattern?","- UI toolkit libraries that support multiple look-and-feel standards
- Database access layers that support multiple database vendors
- Regional ingredient factories for pizza stores","¿Cuál es la intención del Patrón Singleton?","Asegurar que una clase tenga solo una instancia y proporcionar un punto de acceso global a ella.","real-world abstract-factory-pattern creational design-patterns","Creational","106"
"What is the intent of the Singleton Pattern?","Ensure a class has only one instance, and provide a global point of access to it.","¿Cuándo usarías el Patrón Singleton?","- Debe haber exactamente una instancia de una clase y debe ser accesible a los clientes desde un punto de acceso conocido
- Cuando la única instancia debe ser extensible mediante subclases y los clientes deben poder usar una instancia extendida sin modificar su código
- Para controlar el acceso a recursos compartidos (bases de datos, archivos)
- Para gestionar estado global de la aplicación","intent singleton-pattern creational design-patterns","Creational","169"
"When would you use the Singleton Pattern?","- There must be exactly one instance of a class, and it must be accessible to clients from a well-known access point
- When the sole instance should be extensible by subclassing, and clients should be able to use an extended instance without modifying their code","¿Cuáles son los participantes clave en el Patrón Singleton?","- Singleton: Define una operación getInstance que permite a los clientes acceder a su única instancia. getInstance es una operación de clase (método estático). Puede ser responsable de crear su propia instancia única.","use-case singleton-pattern creational design-patterns","Creational","169"
"What are the key participants in the Singleton Pattern?","- Singleton: Defines a getInstance() operation that lets clients access its unique instance. getInstance() is a class operation (static method). May be responsible for creating its own unique instance.","¿Cuáles son los beneficios y desventajas del Patrón Singleton?","Beneficios:
- Acceso controlado a la única instancia
- Espacio de nombres reducido - evita contaminar el espacio de nombres con variables globales
- Permite el refinamiento de operaciones y representación mediante subclases
- Permite un número variable de instancias (fácilmente modificable a múltiples instancias)
- Más flexible que las operaciones de clase

Desventajas:
- Puede dificultar las pruebas unitarias debido al estado global
- Puede ocultar dependencias y acoplamiento en el código
- Requiere consideración especial en entornos multihilo
- Puede violar el Principio de Responsabilidad Única","key-concepts singleton-pattern creational design-patterns","Creational","169"
"What are the benefits and drawbacks of the Singleton Pattern?","Benefits:
- Controlled access to sole instance
- Reduced namespace pollution compared to global variables
- Permits refinement of operations and representation through subclassing
- More flexible than class operations (static methods)
- Can control the number of instances (can be extended to allow a specific number)

Drawbacks:
- Difficult to test due to global state
- Can introduce hidden dependencies in code
- Violates Single Responsibility Principle (manages its own lifecycle AND its primary responsibility)
- Can cause issues in multithreaded environments if not implemented carefully
- Makes code tightly coupled to concrete classes","¿Qué patrones están relacionados con el Patrón Singleton?","- Abstract Factory, Builder y Prototype pueden implementarse como Singletons
- Facade puede implementarse como un Singleton ya que a menudo solo se necesita un objeto Facade","benefits-drawbacks singleton-pattern creational design-patterns","Creational","169"
"What patterns are related to the Singleton Pattern?","- Abstract Factory: Many patterns can be implemented using the Singleton pattern
- Builder: Can be implemented as Singletons
- Prototype: Can be implemented as Singletons","¿Qué patrón de código representa esto?

```java
public class ChocolateBoiler {
  private boolean empty;
  private boolean boiled;
  private static ChocolateBoiler uniqueInstance;
  
  private ChocolateBoiler() {
    empty = true;
    boiled = false;
  }
  
  public static ChocolateBoiler getInstance() {
    if (uniqueInstance == null) {
      uniqueInstance = new ChocolateBoiler();
    }
    return uniqueInstance;
  }
}
```","Patrón: Singleton Pattern
Elementos clave: Constructor privado, instancia estática, método getInstance - asegura que solo exista un ChocolateBoiler para controlar la caldera de chocolate","related-patterns singleton-pattern creational design-patterns","Creational","169"
"What are key implementation considerations for the Singleton Pattern?","- Use a private constructor to prevent direct instantiation
- Use a static method to provide global access point
- For multithreading: synchronize getInstance(), use eager instantiation, or use double-checked locking (Java 5+)
- Be aware of classloader issues in environments with multiple classloaders
- Lazy instantiation can be beneficial for resource-intensive objects","¿Cuáles son las consideraciones clave de implementación para el Patrón Singleton?","- Usar un constructor privado para prevenir la instanciación directa
- Usar un método estático para proporcionar punto de acceso global
- Para multithreading: sincronizar getInstance(), usar instanciación eager, o usar doble verificación de bloqueo (Java 5+)
- Estar atento a problemas con classloaders en entornos con múltiples classloaders
- La instanciación lazy puede ser beneficiosa para objetos que consumen muchos recursos","implementation singleton-pattern creational design-patterns","Creational","169"
"What code pattern does this represent?

```java
public class Singleton {
  private static Singleton uniqueInstance;
  private Singleton() {}
  public static synchronized Singleton getInstance() {
    if (uniqueInstance == null) {
      uniqueInstance = new Singleton();
    }
    return uniqueInstance;
  }
}
```","Pattern: Singleton Pattern
Key elements: Classic Singleton with lazy instantiation and synchronized getInstance for thread safety - prevents multiple threads from creating multiple instances","¿Qué patrón de código representa esto?

```java
public class Singleton {
  private static Singleton uniqueInstance;
  private Singleton() {}
  public static synchronized Singleton getInstance() {
    if (uniqueInstance == null) {
      uniqueInstance = new Singleton();
    }
    return uniqueInstance;
  }
}
```","Patrón: Singleton Pattern
Elementos clave: Singleton clásico con instanciación lazy y getInstance sincronizado para seguridad de hilos - previene que múltiples hilos creen múltiples instancias","code-example singleton-pattern creational java design-patterns","Creational","169"
"What code pattern does this represent?

```java
public class Singleton {
  private static Singleton uniqueInstance = new Singleton();
  private Singleton() {}
  public static Singleton getInstance() {
    return uniqueInstance;
  }
}
```","Pattern: Singleton Pattern
Key elements: Eager instantiation - instance created when class is loaded, thread-safe without synchronization overhead","¿Qué patrón de código representa esto?

```java
public class Singleton {
  private static Singleton uniqueInstance = new Singleton();
  private Singleton() {}
  public static Singleton getInstance() {
    return uniqueInstance;
  }
}
```","Patrón: Singleton Pattern
Elementos clave: Instanciación eager - la instancia se crea cuando se carga la clase, seguro para hilos sin sobrecarga de sincronización","code-example singleton-pattern creational java design-patterns","Creational","169"
"What code pattern does this represent?

```java
public class Singleton {
  private volatile static Singleton uniqueInstance;
  private Singleton() {}
  public static Singleton getInstance() {
    if (uniqueInstance == null) {
      synchronized (Singleton.class) {
        if (uniqueInstance == null) {
          uniqueInstance = new Singleton();
        }
      }
    }
    return uniqueInstance;
  }
}
```","Pattern: Singleton Pattern
Key elements: Double-checked locking for improved performance - only synchronizes first time through, requires volatile keyword (Java 5+)","¿Qué patrón de código representa esto?

```java
public class Singleton {
  private volatile static Singleton uniqueInstance;
  private Singleton() {}
  public static Singleton getInstance() {
    if (uniqueInstance == null) {
      synchronized (Singleton.class) {
        if (uniqueInstance == null) {
          uniqueInstance = new Singleton();
        }
      }
    }
    return uniqueInstance;
  }
}
```","Patrón: Singleton Pattern
Elementos clave: Doble verificación de bloqueo para mejor rendimiento - solo sincroniza la primera vez, requiere la palabra clave volatile (Java 5+)","code-example singleton-pattern creational java design-patterns","Creational","169"
"What are real-world examples of the Singleton Pattern?","- Logger classes
- Configuration manager
- Thread pool manager
- Database connection pool
- Chocolate boiler controller in factory
- Device drivers for printers and graphics cards","¿Cuáles son ejemplos del mundo real del Patrón Singleton?","- Clases de registro (logger)
- Gestor de configuración
- Gestor de pool de hilos
- Pool de conexiones a base de datos
- Controlador de caldera de chocolate en fábrica
- Controladores de dispositivos para impresoras y tarjetas gráficas","real-world singleton-pattern creational design-patterns","Creational","169"
"What are common misuses of the Singleton Pattern?","- Using Singleton as a substitute for global variables without justification
- Creating Singletons for objects that don't truly need to be restricted to one instance
- Overusing Singletons, leading to tight coupling and hidden dependencies
- Not properly handling thread safety in multithreaded environments
- Making it difficult to write unit tests due to global state","¿Cuáles son los usos incorrectos comunes del Patrón Singleton?","- Usar Singleton como sustituto de variables globales sin justificación
- Crear Singletons para objetos que realmente no necesitan estar restringidos a una instancia
- Abusar de Singletons, llevando a acoplamiento estrecho y dependencias ocultas
- No manejar adecuadamente la seguridad de hilos en entornos multihilo
- Dificultar la escritura de pruebas unitarias debido al estado global","anti-pattern singleton-pattern creational design-patterns","Creational","169"
"Which patterns use the concept 'Dependency Inversion Principle'?","Depend upon abstractions, not concrete classes. Both high-level and low-level modules should depend on abstractions. Factory patterns help achieve this by decoupling client code from concrete implementations.

Patterns: Factory Method, Abstract Factory","¿Qué patrones usan el concepto 'Principio de Inversión de Dependencias'?","Depende de abstracciones, no de clases concretas. Tanto los módulos de alto nivel como de bajo nivel deben depender de abstracciones. Los patrones Factory ayudan a lograr esto al desacoplar el código del cliente de implementaciones concretas.

Patrones: Factory Method, Abstract Factory","cross-cutting dependency-inversion-principle design-patterns","Cross-Cutting","106"
"Which patterns use the concept 'Encapsulation of Object Creation'?","All factory patterns encapsulate object creation, moving instantiation out of client code and into specialized factory components. This provides flexibility and reduces coupling.

Patterns: Factory Method, Abstract Factory, Singleton","¿Qué patrones usan el concepto 'Encapsulación de la Creación de Objetos'?","Todos los patrones factory encapsulan la creación de objetos, moviendo la instanciación fuera del código del cliente y hacia componentes factory especializados. Esto proporciona flexibilidad y reduce el acoplamiento.

Patrones: Factory Method, Abstract Factory, Singleton","cross-cutting encapsulation design-patterns","Cross-Cutting","106"
"Which patterns use the concept 'Programming to Interfaces'?","Clients program to product interfaces rather than concrete classes. Factory methods return abstract types, allowing concrete products to vary without affecting client code.

Patterns: Factory Method, Abstract Factory","¿Qué patrones usan el concepto 'Programación a Interfaces'?","Los clientes programan a interfaces de productos en lugar de clases concretas. Los métodos factory devuelven tipos abstractos, permitiendo que los productos concretos varíen sin afectar el código del cliente.

Patrones: Factory Method, Abstract Factory","cross-cutting programming-to-interfaces design-patterns","Cross-Cutting","106"
"Which patterns use the concept 'Lazy vs Eager Instantiation'?","Lazy instantiation creates objects only when needed, while eager instantiation creates them upfront. Singletons can use either approach depending on performance requirements and resource constraints.

Patterns: Singleton","¿Qué patrones usan el concepto 'Instanciación Lazy vs Eager'?","La instanciación lazy crea objetos solo cuando se necesitan, mientras que la instanciación eager los crea por adelantado. Los Singletons pueden usar cualquier enfoque dependiendo de los requisitos de rendimiento y restricciones de recursos.

Patrones: Singleton","cross-cutting lazy-instantiation eager-instantiation design-patterns","Cross-Cutting","169"
"Which patterns use the concept 'Thread Safety'?","In multithreaded environments, special care must be taken to ensure only one instance is created. Solutions include synchronization, eager instantiation, or double-checked locking.

Patterns: Singleton","¿Qué patrones usan el concepto 'Seguridad de Hilos'?","En entornos multihilo, se debe tener especial cuidado para asegurar que solo se cree una instancia. Las soluciones incluyen sincronización, instanciación eager o doble verificación de bloqueo.

Patrones: Singleton","cross-cutting thread-safety multithreading design-patterns","Cross-Cutting","169"
"Which patterns use the concept 'Parallel Class Hierarchies'?","Factory patterns often result in parallel hierarchies - one for creators/factories and one for products. Each concrete creator corresponds to a family of concrete products.

Patterns: Factory Method, Abstract Factory","¿Qué patrones usan el concepto 'Jerarquías de Clases Paralelas'?","Los patrones Factory a menudo resultan en jerarquías paralelas - una para creadores/factories y otra para productos. Cada creador concreto corresponde a una familia de productos concretos.

Patrones: Factory Method, Abstract Factory","cross-cutting parallel-hierarchies design-patterns","Cross-Cutting","106"
"Compare Factory Method vs Abstract Factory","Similarities:
- Both encapsulate object creation
- Both promote dependency inversion
- Both return abstract types to clients
- Both use polymorphism to create objects

Differences:
- Factory Method uses inheritance (subclasses decide what to create)
- Abstract Factory uses object composition (factory object creates families of products)
- Factory Method creates one product
- Abstract Factory creates families of related products

When to use each:
- Use Factory Method when you need to defer instantiation to subclasses
- Use Abstract Factory when you need to create families of related objects that must be used together","Compara Factory Method vs Abstract Factory","Similitudes:
- Ambos encapsulan la creación de objetos
- Ambos promueven la inversión de dependencias
- Ambos devuelven tipos abstractos a los clientes
- Ambos usan polimorfismo para crear objetos

Diferencias:
- Factory Method usa herencia (las subclases deciden qué crear)
- Abstract Factory usa composición de objetos (el objeto factory crea familias de productos)
- Factory Method crea un producto
- Abstract Factory crea familias de productos relacionados

Cuándo usar cada uno:
- Usa Factory Method cuando necesites diferir la instanciación a las subclases
- Usa Abstract Factory cuando necesites crear familias de objetos relacionados que deben usarse juntos","comparison factory-method-pattern abstract-factory-pattern creational design-patterns","Comparison","106"
"What is the intent of the Strategy Pattern?","Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.","¿Cuál es la intención del Patrón Strategy?","Definir una familia de algoritmos, encapsular cada uno y hacerlos intercambiables. Strategy permite que el algoritmo varíe independientemente de los clientes que lo usan.","intent strategy-pattern behavioral","Behavioral","29"
"When would you use the Strategy Pattern?","• When many related classes differ only in their behavior
• When you need different variants of an algorithm
• When you want to change behavior at runtime
• When you want to avoid exposing complex algorithm-specific data structures","¿Cuándo usarías el Patrón Strategy?","• Cuando muchas clases relacionadas difieren solo en su comportamiento
• Cuando necesitas diferentes variantes de un algoritmo
• Cuando quieres cambiar el comportamiento en tiempo de ejecución
• Cuando quieres evitar exponer estructuras de datos complejas específicas del algoritmo","use-case strategy-pattern behavioral","Behavioral","29"
"What are the key participants in the Strategy Pattern?","• Context: Maintains a reference to a Strategy object (e.g., Duck class)
• Strategy Interface: Common interface for all concrete strategies (e.g., FlyBehavior, QuackBehavior)
• Concrete Strategies: Implement different algorithm variations (e.g., FlyWithWings, FlyNoWay, Quack, Squeak)","¿Cuáles son los participantes clave en el Patrón Strategy?","• Contexto: Mantiene una referencia a un objeto Strategy (ej., clase Duck)
• Interfaz Strategy: Interfaz común para todas las estrategias concretas (ej., FlyBehavior, QuackBehavior)
• Estrategias Concretas: Implementan diferentes variaciones del algoritmo (ej., FlyWithWings, FlyNoWay, Quack, Squeak)","key-concepts strategy-pattern behavioral","Behavioral","29"
"What are the benefits and drawbacks of the Strategy Pattern?","Benefits:
• Eliminates conditional statements for selecting desired behavior
• Provides alternative to subclassing
• Allows runtime behavior changes
• Encapsulates what varies

Drawbacks:
• Clients must be aware of different strategies
• Increases number of objects in application
• Communication overhead between Strategy and Context","¿Cuáles son los beneficios e inconvenientes del Patrón Strategy?","Beneficios:
• Elimina declaraciones condicionales para seleccionar el comportamiento deseado
• Proporciona una alternativa a la subclasificación
• Permite cambios de comportamiento en tiempo de ejecución
• Encapsula lo que varía

Inconvenientes:
• Los clientes deben conocer las diferentes estrategias
• Aumenta el número de objetos en la aplicación
• Sobrecarga de comunicación entre Strategy y Context","benefits-drawbacks strategy-pattern behavioral","Behavioral","29"
"What are key implementation considerations for the Strategy Pattern?","• Use HAS-A relationship (composition) rather than IS-A (inheritance)
• Favor composition over inheritance
• Program to interfaces, not implementations
• Example: Duck HAS-A FlyBehavior and QuackBehavior","¿Cuáles son las consideraciones clave de implementación para el Patrón Strategy?","• Usa la relación HAS-A (composición) en lugar de IS-A (herencia)
• Favorece la composición sobre la herencia
• Programa a interfaces, no a implementaciones
• Ejemplo: Duck HAS-A FlyBehavior y QuackBehavior","implementation strategy-pattern behavioral","Behavioral","29"
"What are real-world examples of the Strategy Pattern?","• Duck simulator with encapsulated fly and quack behaviors
• Character combat system with interchangeable weapons
• Sorting algorithms that can be swapped at runtime
• Payment processing systems with multiple payment methods","¿Cuáles son ejemplos del mundo real del Patrón Strategy?","• Simulador de patos con comportamientos de vuelo y graznido encapsulados
• Sistema de combate de personajes con armas intercambiables
• Algoritmos de ordenación que pueden intercambiarse en tiempo de ejecución
• Sistemas de procesamiento de pagos con múltiples métodos de pago","real-world strategy-pattern behavioral","Behavioral","29"
"abstract class Duck {
  FlyBehavior flyBehavior;
  QuackBehavior quackBehavior;
  
  void performFly() {
    flyBehavior.fly();
  }
  
  void setFlyBehavior(FlyBehavior fb) {
    this.flyBehavior = fb;
  }
}

What pattern does this code demonstrate?","Pattern: Strategy Pattern
Key elements: Duck delegates flying and quacking behavior to strategy objects, allowing runtime changes through setter methods. Uses composition instead of inheritance.","abstract class Duck {
  FlyBehavior flyBehavior;
  QuackBehavior quackBehavior;
  
  void performFly() {
    flyBehavior.fly();
  }
  
  void setFlyBehavior(FlyBehavior fb) {
    this.flyBehavior = fb;
  }
}

¿Qué patrón demuestra este código?","Patrón: Patrón Strategy
Elementos clave: Duck delega el comportamiento de volar y graznar a objetos estrategia, permitiendo cambios en tiempo de ejecución mediante métodos setter. Usa composición en lugar de herencia.","code-example strategy-pattern behavioral java","Behavioral","29"
"What is the intent of the Observer Pattern?","Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.","¿Cuál es la intención del Patrón Observer?","Definir una dependencia uno-a-muchos entre objetos de modo que cuando un objeto cambia de estado, todos sus dependientes son notificados y actualizados automáticamente.","intent observer-pattern behavioral","Behavioral","52"
"When would you use the Observer Pattern?","• When an abstraction has two aspects, one dependent on the other
• When a change to one object requires changing others, and you don't know how many objects need to be changed
• When an object should be able to notify other objects without making assumptions about who these objects are
• When you need loose coupling between interacting objects","¿Cuándo usarías el Patrón Observer?","• Cuando una abstracción tiene dos aspectos, uno dependiente del otro
• Cuando un cambio en un objeto requiere cambiar otros, y no sabes cuántos objetos necesitan cambiarse
• Cuando un objeto debe poder notificar a otros objetos sin hacer suposiciones sobre quiénes son esos objetos
• Cuando necesitas acoplamiento débil entre objetos que interactúan","use-case observer-pattern behavioral","Behavioral","52"
"What are the key participants in the Observer Pattern?","• Subject (Observable): Knows its observers, provides interface for attaching and detaching Observer objects, stores state of interest
• Observer: Defines an updating interface for objects that should be notified of changes
• ConcreteSubject: Stores state that observers want to stay consistent with, sends notifications when state changes (e.g., WeatherData)
• ConcreteObserver: Maintains reference to ConcreteSubject, implements Observer updating interface (e.g., CurrentConditionsDisplay, StatisticsDisplay)","¿Cuáles son los participantes clave en el Patrón Observer?","• Sujeto (Observable): Conoce a sus observadores, proporciona interfaz para adjuntar y desadjuntar objetos Observer, almacena el estado de interés
• Observador: Define una interfaz de actualización para objetos que deben ser notificados de cambios
• SujetoConcreto: Almacena estado que los observadores quieren mantener consistente, envía notificaciones cuando el estado cambia (ej., WeatherData)
• ObservadorConcreto: Mantiene referencia a SujetoConcreto, implementa la interfaz de actualización de Observer (ej., CurrentConditionsDisplay, StatisticsDisplay)","key-concepts observer-pattern behavioral","Behavioral","52"
"What are the benefits and drawbacks of the Observer Pattern?","Benefits:
• Loose coupling between Subject and Observer
• Can add observers at any time without modifying subject
• Can reuse subjects or observers independently
• Changes to subject or observer don't affect the other
• Support for broadcast communication

Drawbacks:
• Observers are notified in random order
• Can cause memory leaks if observers aren't properly unregistered
• Unexpected updates if observers don't understand the full model
• Update overhead when many observers exist","¿Cuáles son los beneficios e inconvenientes del Patrón Observer?","Beneficios:
• Acoplamiento débil entre Sujeto y Observador
• Puedes añadir observadores en cualquier momento sin modificar el sujeto
• Puedes reutilizar sujetos u observadores independientemente
• Los cambios en el sujeto o el observador no afectan al otro
• Soporte para comunicación por difusión

Inconvenientes:
• Los observadores son notificados en orden aleatorio
• Puede causar fugas de memoria si los observadores no se desregistran correctamente
• Actualizaciones inesperadas si los observadores no entienden el modelo completo
• Sobrecarga de actualización cuando existen muchos observadores","benefits-drawbacks observer-pattern behavioral","Behavioral","52"
"What patterns are related to the Observer Pattern?","• MVC (Model-View-Controller): Observer is fundamental to MVC - Model is Subject, Views are Observers
• Mediator: Can use Observer to implement communication between colleague objects
• Singleton: Subject is often a Singleton","¿Qué patrones están relacionados con el Patrón Observer?","• MVC (Modelo-Vista-Controlador): Observer es fundamental para MVC - El Modelo es el Sujeto, las Vistas son Observadores
• Mediator: Puede usar Observer para implementar comunicación entre objetos colegas
• Singleton: El Sujeto a menudo es un Singleton","related-patterns observer-pattern behavioral","Behavioral","52"
"What are key implementation considerations for the Observer Pattern?","• Subject only knows observers implement Observer interface
• Push model: Subject sends detailed information to observers
• Pull model: Subject sends minimal notification, observers pull what they need (more flexible)
• Java provides java.util.Observable (class) and java.util.Observer (interface)
• Observable.setChanged() must be called before notifyObservers()
• Never depend on order of observer notifications","¿Cuáles son las consideraciones clave de implementación para el Patrón Observer?","• El Sujeto solo sabe que los observadores implementan la interfaz Observer
• Modelo push: El Sujeto envía información detallada a los observadores
• Modelo pull: El Sujeto envía notificación mínima, los observadores extraen lo que necesitan (más flexible)
• Java proporciona java.util.Observable (clase) y java.util.Observer (interfaz)
• Observable.setChanged() debe llamarse antes de notifyObservers()
• Nunca dependas del orden de notificaciones de los observadores","implementation observer-pattern behavioral","Behavioral","52"
"What are real-world examples of the Observer Pattern?","• Newspaper/magazine subscription service
• Event handling systems (DOM events, GUI button clicks)
• MVC frameworks where model notifies views of changes
• Java Swing listeners (ActionListener, MouseListener, etc.)
• JavaBeans PropertyChangeListener
• Weather monitoring stations with multiple displays
• Job notification system (headhunter notifying job seekers)","¿Cuáles son ejemplos del mundo real del Patrón Observer?","• Servicio de suscripción a periódicos/revistas
• Sistemas de manejo de eventos (eventos DOM, clics de botones GUI)
• Frameworks MVC donde el modelo notifica a las vistas de cambios
• Listeners de Java Swing (ActionListener, MouseListener, etc.)
• JavaBeans PropertyChangeListener
• Estaciones de monitoreo meteorológico con múltiples pantallas
• Sistema de notificación de empleos (cazatalentos notificando a buscadores de empleo)","real-world observer-pattern behavioral","Behavioral","52"
"public class WeatherData implements Subject {
  private ArrayList observers;
  private float temperature;
  
  public void notifyObservers() {
    for (Observer observer : observers) {
      observer.update(temperature, humidity, pressure);
    }
  }
}

What pattern does this code demonstrate?","Pattern: Observer Pattern
Key elements: WeatherData (ConcreteSubject) maintains a list of observers and notifies them when measurements change by calling update() on each observer.","public class WeatherData implements Subject {
  private ArrayList observers;
  private float temperature;
  
  public void notifyObservers() {
    for (Observer observer : observers) {
      observer.update(temperature, humidity, pressure);
    }
  }
}

¿Qué patrón demuestra este código?","Patrón: Patrón Observer
Elementos clave: WeatherData (SujetoConcreto) mantiene una lista de observadores y los notifica cuando las mediciones cambian llamando a update() en cada observador.","code-example observer-pattern behavioral java","Behavioral","52"
"What is the intent of the Decorator Pattern?","Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.","¿Cuál es la intención del Patrón Decorator?","Adjuntar responsabilidades adicionales a un objeto dinámicamente. Los Decoradores proporcionan una alternativa flexible a la subclasificación para extender funcionalidad.","intent decorator-pattern structural","Structural","79"
"When would you use the Decorator Pattern?","• To add responsibilities to individual objects dynamically and transparently
• For responsibilities that can be withdrawn
• When extension by subclassing is impractical (would produce class explosion)
• When you need to add functionality that can be composed in various combinations","¿Cuándo usarías el Patrón Decorator?","• Para añadir responsabilidades a objetos individuales dinámicamente y de forma transparente
• Para responsabilidades que pueden retirarse
• Cuando la extensión por subclasificación es poco práctica (produciría explosión de clases)
• Cuando necesitas añadir funcionalidad que puede componerse en varias combinaciones","use-case decorator-pattern structural","Structural","79"
"What are the key participants in the Decorator Pattern?","• Component: Defines interface for objects that can have responsibilities added (e.g., Beverage, InputStream)
• ConcreteComponent: Object to which additional responsibilities can be attached (e.g., DarkRoast, Espresso, FileInputStream)
• Decorator: Maintains reference to Component and defines interface conforming to Component (e.g., CondimentDecorator, FilterInputStream)
• ConcreteDecorator: Adds responsibilities to component (e.g., Mocha, Whip, Soy, BufferedInputStream)","¿Cuáles son los participantes clave en el Patrón Decorator?","• Componente: Define la interfaz para objetos que pueden tener responsabilidades añadidas (ej., Beverage, InputStream)
• ComponenteConcreto: Objeto al que se pueden adjuntar responsabilidades adicionales (ej., DarkRoast, Espresso, FileInputStream)
• Decorador: Mantiene referencia a Componente y define interfaz que se ajusta a Componente (ej., CondimentDecorator, FilterInputStream)
• DecoradorConcreto: Añade responsabilidades al componente (ej., Mocha, Whip, Soy, BufferedInputStream)","key-concepts decorator-pattern structural","Structural","79"
"What are the benefits and drawbacks of the Decorator Pattern?","Benefits:
• More flexible than static inheritance
• Avoids feature-laden classes high in hierarchy
• Responsibilities can be added and removed at runtime
• Can combine decorators in various ways
• New functionality can be added without altering existing code
• Follows Open-Closed Principle

Drawbacks:
• Lots of little objects in design can be overwhelming
• Can be complex to instantiate (often addressed with Factory/Builder patterns)
• Code that depends on specific types will break when decorators are introduced
• Can be difficult to remove specific decorator from wrapper stack","¿Cuáles son los beneficios e inconvenientes del Patrón Decorator?","Beneficios:
• Más flexible que la herencia estática
• Evita clases cargadas de funcionalidades en lo alto de la jerarquía
• Las responsabilidades pueden añadirse y eliminarse en tiempo de ejecución
• Puede combinar decoradores de varias maneras
• Se puede añadir nueva funcionalidad sin alterar el código existente
• Sigue el Principio Abierto-Cerrado

Inconvenientes:
• Muchos objetos pequeños en el diseño pueden ser abrumadores
• Puede ser complejo de instanciar (a menudo se aborda con patrones Factory/Builder)
• El código que depende de tipos específicos se romperá cuando se introduzcan decoradores
• Puede ser difícil eliminar un decorador específico de una pila de envoltorios","benefits-drawbacks decorator-pattern structural","Structural","79"
"What patterns are related to the Decorator Pattern?","• Adapter: Decorator changes object's responsibilities, Adapter changes its interface
• Strategy: Both use composition. Decorator adds responsibilities, Strategy changes algorithm/behavior
• Composite: Decorator can be viewed as degenerate composite with only one component","¿Qué patrones están relacionados con el Patrón Decorator?","• Adapter: Decorator cambia las responsabilidades del objeto, Adapter cambia su interfaz
• Strategy: Ambos usan composición. Decorator añade responsabilidades, Strategy cambia algoritmo/comportamiento
• Composite: Decorator puede verse como un compuesto degenerado con solo un componente","related-patterns decorator-pattern structural","Structural","79"
"What are key implementation considerations for the Decorator Pattern?","• Decorator inherits type of component to maintain interface compatibility
• Decorator HAS-A component it wraps (composition)
• Behavior is acquired through composition, not inheritance
• Multiple decorators can wrap same object
• Order of decoration can matter
• Can use abstract decorator class or interface
• In Java, typically extend abstract decorator class (e.g., FilterInputStream)","¿Cuáles son las consideraciones clave de implementación para el Patrón Decorator?","• El Decorador hereda el tipo del componente para mantener la compatibilidad de interfaz
• El Decorador HAS-A componente que envuelve (composición)
• El comportamiento se adquiere mediante composición, no herencia
• Múltiples decoradores pueden envolver el mismo objeto
• El orden de decoración puede importar
• Se puede usar clase decoradora abstracta o interfaz
• En Java, típicamente se extiende la clase decoradora abstracta (ej., FilterInputStream)","implementation decorator-pattern structural","Structural","79"
"What are real-world examples of the Decorator Pattern?","• Java I/O streams (FilterInputStream, BufferedInputStream, LineNumberInputStream)
• Coffee ordering system with condiments (Starbuzz example)
• GUI component scrollbars and borders
• Java I/O Reader/Writer classes","¿Cuáles son ejemplos del mundo real del Patrón Decorator?","• Streams de I/O de Java (FilterInputStream, BufferedInputStream, LineNumberInputStream)
• Sistema de pedidos de café con condimentos (ejemplo Starbuzz)
• Barras de desplazamiento y bordes de componentes GUI
• Clases Reader/Writer de I/O de Java","real-world decorator-pattern structural","Structural","79"
"public class Mocha extends CondimentDecorator {
  Beverage beverage;
  
  public Mocha(Beverage beverage) {
    this.beverage = beverage;
  }
  
  public double cost() {
    return .20 + beverage.cost();
  }
}

What pattern does this code demonstrate?","Pattern: Decorator Pattern
Key elements: Mocha wraps a Beverage and adds to its cost. It maintains a reference to the wrapped component and delegates to it while adding its own behavior.","public class Mocha extends CondimentDecorator {
  Beverage beverage;
  
  public Mocha(Beverage beverage) {
    this.beverage = beverage;
  }
  
  public double cost() {
    return .20 + beverage.cost();
  }
}

¿Qué patrón demuestra este código?","Patrón: Patrón Decorator
Elementos clave: Mocha envuelve una Beverage y añade a su costo. Mantiene una referencia al componente envuelto y delega en él mientras añade su propio comportamiento.","code-example decorator-pattern structural java","Structural","79"
"Which patterns use the concept of 'Encapsulate What Varies'?","This principle suggests identifying aspects that vary and separating them from what stays the same.

Patterns: Strategy (encapsulates varying algorithms), Observer (encapsulates the set of observers that varies), Decorator (encapsulates combinations of decorators that vary)","¿Qué patrones usan el concepto de 'Encapsular lo que Varía'?","Este principio sugiere identificar aspectos que varían y separarlos de lo que permanece igual.

Patrones: Strategy (encapsula algoritmos variables), Observer (encapsula el conjunto de observadores que varía), Decorator (encapsula combinaciones de decoradores que varían)","cross-cutting encapsulation","Cross-Cutting","29"
"Which patterns use the concept of 'Favor Composition Over Inheritance'?","All three patterns use composition to gain flexibility. Strategy composes behaviors, Observer composes observers with subject, Decorator composes wrappers around components. This allows runtime behavior changes unlike static inheritance.

Patterns: Strategy, Observer, Decorator","¿Qué patrones usan el concepto de 'Favorecer Composición sobre Herencia'?","Los tres patrones usan composición para ganar flexibilidad. Strategy compone comportamientos, Observer compone observadores con el sujeto, Decorator compone envoltorios alrededor de componentes. Esto permite cambios de comportamiento en tiempo de ejecución a diferencia de la herencia estática.

Patrones: Strategy, Observer, Decorator","cross-cutting composition","Cross-Cutting","29"
"Which patterns use the concept of 'Program to Interfaces, Not Implementations'?","Strategy uses behavior interfaces, Observer uses Subject and Observer interfaces, Decorator programs to Component interface. This enables loose coupling and flexibility.

Patterns: Strategy, Observer, Decorator","¿Qué patrones usan el concepto de 'Programar a Interfaces, No a Implementaciones'?","Strategy usa interfaces de comportamiento, Observer usa interfaces de Sujeto y Observador, Decorator programa a la interfaz de Componente. Esto permite acoplamiento débil y flexibilidad.

Patrones: Strategy, Observer, Decorator","cross-cutting interfaces","Cross-Cutting","29"
"Which patterns demonstrate the concept of 'Loose Coupling'?","Subject knows only that observers implement Observer interface. Can add/remove observers without modifying subject. Changes to either don't affect the other. Enables flexible, resilient designs.

Patterns: Observer (primary example), Strategy, Decorator","¿Qué patrones demuestran el concepto de 'Acoplamiento Débil'?","El Sujeto solo sabe que los observadores implementan la interfaz Observer. Puedes añadir/eliminar observadores sin modificar el sujeto. Los cambios en cualquiera no afectan al otro. Permite diseños flexibles y resilientes.

Patrones: Observer (ejemplo principal), Strategy, Decorator","cross-cutting loose-coupling","Cross-Cutting","52"
"Which patterns demonstrate the 'Open-Closed Principle'?","Classes should be open for extension but closed for modification. Observer allows extending subject by adding new observers without changing subject code. Decorator extends component behavior without modifying component class.

Patterns: Observer, Decorator","¿Qué patrones demuestran el 'Principio Abierto-Cerrado'?","Las clases deben estar abiertas para extensión pero cerradas para modificación. Observer permite extender el sujeto añadiendo nuevos observadores sin cambiar el código del sujeto. Decorator extiende el comportamiento del componente sin modificar la clase del componente.

Patrones: Observer, Decorator","cross-cutting open-closed-principle","Cross-Cutting","52"
"Which patterns enable 'Runtime Flexibility'?","All three patterns enable behavior changes at runtime rather than compile time. Strategy allows switching algorithms, Observer allows dynamic registration, Decorator allows dynamic wrapping.

Patterns: Strategy, Observer, Decorator","¿Qué patrones permiten 'Flexibilidad en Tiempo de Ejecución'?","Los tres patrones permiten cambios de comportamiento en tiempo de ejecución en lugar de tiempo de compilación. Strategy permite cambiar algoritmos, Observer permite registro dinámico, Decorator permite envoltura dinámica.

Patrones: Strategy, Observer, Decorator","cross-cutting runtime-flexibility","Cross-Cutting","29"
"Which patterns use the concept of 'Delegation'?","Rather than inheriting behavior, objects delegate to other objects. Strategy delegates to behavior objects, Decorator delegates to wrapped component.

Patterns: Strategy, Decorator","¿Qué patrones usan el concepto de 'Delegación'?","En lugar de heredar comportamiento, los objetos delegan a otros objetos. Strategy delega a objetos de comportamiento, Decorator delega al componente envuelto.

Patrones: Strategy, Decorator","cross-cutting delegation","Cross-Cutting","29"
"Compare Strategy Pattern vs Decorator Pattern","Similarities:
• Both use composition over inheritance
• Both program to interfaces
• Both provide runtime flexibility

Differences:
• Strategy changes algorithm/behavior, Decorator adds responsibilities
• Strategy is Behavioral, Decorator is Structural
• Strategy typically has one behavior object, Decorator can chain multiple wrappers

When to use each:
• Strategy: When you need interchangeable algorithms
• Decorator: When you need to add responsibilities to objects dynamically","Compara el Patrón Strategy vs el Patrón Decorator","Similitudes:
• Ambos usan composición sobre herencia
• Ambos programan a interfaces
• Ambos proporcionan flexibilidad en tiempo de ejecución

Diferencias:
• Strategy cambia algoritmo/comportamiento, Decorator añade responsabilidades
• Strategy es Conductual, Decorator es Estructural
• Strategy típicamente tiene un objeto de comportamiento, Decorator puede encadenar múltiples envoltorios

Cuándo usar cada uno:
• Strategy: Cuando necesitas algoritmos intercambiables
• Decorator: Cuando necesitas añadir responsabilidades a objetos dinámicamente","comparison strategy-pattern decorator-pattern","Comparison","29"
"Compare Observer Pattern vs Decorator Pattern","Similarities:
• Both use composition
• Both follow Open-Closed Principle
• Both provide runtime flexibility

Differences:
• Observer creates one-to-many relationships, Decorator wraps one object
• Observer is about notification/communication, Decorator is about adding behavior
• Observer is Behavioral, Decorator is Structural

When to use each:
• Observer: When multiple objects need to react to state changes
• Decorator: When you need to add responsibilities to individual objects","Compara el Patrón Observer vs el Patrón Decorator","Similitudes:
• Ambos usan composición
• Ambos siguen el Principio Abierto-Cerrado
• Ambos proporcionan flexibilidad en tiempo de ejecución

Diferencias:
• Observer crea relaciones uno-a-muchos, Decorator envuelve un objeto
• Observer trata sobre notificación/comunicación, Decorator trata sobre añadir comportamiento
• Observer es Conductual, Decorator es Estructural

Cuándo usar cada uno:
• Observer: Cuando múltiples objetos necesitan reaccionar a cambios de estado
• Decorator: Cuando necesitas añadir responsabilidades a objetos individuales","comparison observer-pattern decorator-pattern","Comparison","52"
"What is the intent of the Strategy Pattern?","Defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.","¿Cuál es la intención del Patrón Strategy?","Define una familia de algoritmos, encapsula cada uno y los hace intercambiables. Strategy permite que el algoritmo varíe independientemente de los clientes que lo usan.","strategy-pattern behavioral intent design-patterns","Behavioral","24"
"When would you use the Strategy Pattern?","• When you need to use different variants of an algorithm
• When you have classes that differ only in their behavior
• When you need to avoid exposing complex, algorithm-specific data structures
• When a class defines many behaviors with multiple conditional statements","¿Cuándo usarías el Patrón Strategy?","• Cuando necesitas usar diferentes variantes de un algoritmo
• Cuando tienes clases que difieren solo en su comportamiento
• Cuando necesitas evitar exponer estructuras de datos complejas y específicas del algoritmo
• Cuando una clase define muchos comportamientos con múltiples declaraciones condicionales","strategy-pattern behavioral use-case design-patterns","Behavioral","14"
"What are the key participants in the Strategy Pattern?","• Strategy: Common interface for all supported algorithms (e.g., FlyBehavior, QuackBehavior)
• ConcreteStrategy: Implements the algorithm using the Strategy interface (e.g., FlyWithWings, FlyNoWay, Quack, Squeak)
• Context: Maintains a reference to a Strategy object and delegates to it (e.g., Duck class)","¿Cuáles son los participantes clave en el Patrón Strategy?","• Strategy: Interfaz común para todos los algoritmos soportados (ej., FlyBehavior, QuackBehavior)
• ConcreteStrategy: Implementa el algoritmo usando la interfaz Strategy (ej., FlyWithWings, FlyNoWay, Quack, Squeak)
• Context: Mantiene una referencia a un objeto Strategy y le delega (ej., clase Duck)","strategy-pattern behavioral key-concepts design-patterns","Behavioral","22"
"What are the benefits and drawbacks of the Strategy Pattern?","Benefits:
• Families of related algorithms can be reused
• Eliminates conditional statements for selecting desired behavior
• Provides an alternative to subclassing for extending functionality
• Behavior can be changed at runtime through setter methods
• Promotes composition over inheritance

Drawbacks:
• Clients must be aware of different strategies
• Increases the number of objects in the application
• Communication overhead between Strategy and Context","¿Cuáles son los beneficios y desventajas del Patrón Strategy?","Beneficios:
• Las familias de algoritmos relacionados pueden ser reutilizadas
• Elimina declaraciones condicionales para seleccionar el comportamiento deseado
• Proporciona una alternativa a la herencia de subclases para extender funcionalidad
• El comportamiento puede cambiarse en tiempo de ejecución a través de métodos setter
• Promueve la composición sobre la herencia

Desventajas:
• Los clientes deben conocer las diferentes estrategias
• Aumenta el número de objetos en la aplicación
• Sobrecarga de comunicación entre Strategy y Context","strategy-pattern behavioral benefits-drawbacks design-patterns","Behavioral","40"
"What patterns are related to the Strategy Pattern and how do they differ?","• State Pattern: Strategy and State are structurally similar but differ in intent. State allows an object to change its behavior when its internal state changes, while Strategy encapsulates interchangeable algorithms.
• Template Method: Template Method uses inheritance to vary parts of an algorithm, whereas Strategy uses composition and delegation.","¿Qué patrones están relacionados con el Patrón Strategy y en qué difieren?","• Patrón State: Strategy y State son estructuralmente similares pero difieren en intención. State permite que un objeto cambie su comportamiento cuando su estado interno cambia, mientras que Strategy encapsula algoritmos intercambiables.
• Template Method: Template Method usa herencia para variar partes de un algoritmo, mientras que Strategy usa composición y delegación.","strategy-pattern behavioral related-patterns design-patterns","Behavioral","57"
"What are key implementation considerations for the Strategy Pattern?","• Use interfaces to define the strategy contract
• Store strategy objects as instance variables in the context
• Provide setter methods to allow runtime strategy changes
• Initialize concrete strategies in constructors or through dependency injection
• Program to an interface (supertype), not an implementation","¿Cuáles son las consideraciones clave de implementación para el Patrón Strategy?","• Usar interfaces para definir el contrato de la estrategia
• Almacenar objetos de estrategia como variables de instancia en el contexto
• Proporcionar métodos setter para permitir cambios de estrategia en tiempo de ejecución
• Inicializar estrategias concretas en constructores o mediante inyección de dependencias
• Programar hacia una interfaz (supertipo), no una implementación","strategy-pattern behavioral implementation design-patterns","Behavioral","47"
"In the SimUDuck example, how does delegation work in the Strategy Pattern?
public void performFly() {
  flyBehavior.fly();
}","Pattern: Strategy Pattern

Key elements: The Duck class delegates flying behavior to a FlyBehavior strategy object instead of implementing the behavior itself. When performFly() is called, it delegates to the fly() method on the flyBehavior object, allowing the behavior to be changed at runtime.","En el ejemplo SimUDuck, ¿cómo funciona la delegación en el Patrón Strategy?
public void performFly() {
  flyBehavior.fly();
}","Patrón: Patrón Strategy

Elementos clave: La clase Duck delega el comportamiento de vuelo a un objeto de estrategia FlyBehavior en lugar de implementar el comportamiento ella misma. Cuando se llama a performFly(), delega al método fly() del objeto flyBehavior, permitiendo que el comportamiento sea cambiado en tiempo de ejecución.","strategy-pattern behavioral code-example design-patterns java","Behavioral","15"
"What are real-world examples of the Strategy Pattern?","• Java Collections.sort() with Comparator strategies
• Layout managers in GUI frameworks
• Compression algorithms in file utilities
• Payment processing systems with different payment method strategies","¿Cuáles son ejemplos del mundo real del Patrón Strategy?","• Java Collections.sort() con estrategias Comparator
• Gestores de diseño en frameworks de GUI
• Algoritmos de compresión en utilidades de archivos
• Sistemas de procesamiento de pagos con diferentes estrategias de métodos de pago","strategy-pattern behavioral real-world design-patterns","Behavioral","72"
"Which design principle states: Identify the aspects of your application that vary and separate them from what stays the same?","This is the first fundamental design principle: Encapsulate what varies.

Used in: Strategy Pattern

It means taking the parts that vary and encapsulating them so you can alter or extend them without affecting the parts that don't change. This forms the basis for almost every design pattern.","¿Qué principio de diseño establece: Identifica los aspectos de tu aplicación que varían y sepáralos de lo que permanece igual?","Este es el primer principio fundamental de diseño: Encapsula lo que varía.

Usado en: Patrón Strategy

Significa tomar las partes que varían y encapsularlas para que puedas alterarlas o extenderlas sin afectar las partes que no cambian. Esto forma la base de casi todos los patrones de diseño.","cross-cutting encapsulation design-principles strategy-pattern","Cross-Cutting","9"
"Which design principle states: Program to an interface, not an implementation?","This principle means declaring variables as interface types so objects assigned to them can be of any concrete implementation that implements the interface.

Used in: Strategy Pattern

This exploits polymorphism and allows runtime flexibility. The declared type should be a supertype (interface or abstract class) rather than a concrete implementation.","¿Qué principio de diseño establece: Programa hacia una interfaz, no una implementación?","Este principio significa declarar variables como tipos de interfaz para que los objetos asignados a ellas puedan ser de cualquier implementación concreta que implemente la interfaz.

Usado en: Patrón Strategy

Esto explota el polimorfismo y permite flexibilidad en tiempo de ejecución. El tipo declarado debe ser un supertipo (interfaz o clase abstracta) en lugar de una implementación concreta.","cross-cutting programming-to-interfaces design-principles strategy-pattern","Cross-Cutting","12"
"Which design principle states: Favor composition over inheritance?","Prefer HAS-A relationships over IS-A relationships.

Used in: Strategy Pattern

Composition provides more flexibility by allowing behavior to be changed at runtime and avoiding the limitations and tight coupling of inheritance hierarchies. Instead of inheriting behavior, objects get their behavior by being composed with the right behavior object.","¿Qué principio de diseño establece: Favorece la composición sobre la herencia?","Prefiere relaciones TIENE-UN sobre relaciones ES-UN.

Usado en: Patrón Strategy

La composición proporciona más flexibilidad al permitir que el comportamiento sea cambiado en tiempo de ejecución y evitar las limitaciones y el acoplamiento fuerte de las jerarquías de herencia. En lugar de heredar comportamiento, los objetos obtienen su comportamiento al ser compuestos con el objeto de comportamiento correcto.","cross-cutting composition-over-inheritance design-principles strategy-pattern","Cross-Cutting","23"
"What is loose coupling and which pattern promotes it?","Loose coupling means striving for designs where interacting objects have minimal dependencies on each other.

Used in: Strategy Pattern

The Strategy Pattern promotes loose coupling by having the context depend on the strategy interface rather than concrete implementations. This allows the algorithm to vary independently from clients that use it.","¿Qué es el acoplamiento débil y qué patrón lo promueve?","El acoplamiento débil significa esforzarse por diseños donde los objetos que interactúan tengan dependencias mínimas entre sí.

Usado en: Patrón Strategy

El Patrón Strategy promueve el acoplamiento débil al hacer que el contexto dependa de la interfaz de estrategia en lugar de implementaciones concretas. Esto permite que el algoritmo varíe independientemente de los clientes que lo usan.","cross-cutting loose-coupling design-principles strategy-pattern","Cross-Cutting","97"
"What is runtime flexibility in the context of design patterns?","Runtime flexibility is the ability to change object behavior at runtime through composition and delegation rather than being locked into compile-time decisions through inheritance.

Used in: Strategy Pattern

Example: Using setter methods to change a duck's flying behavior from FlyWithWings to FlyRocketPowered while the program is running.","¿Qué es la flexibilidad en tiempo de ejecución en el contexto de patrones de diseño?","La flexibilidad en tiempo de ejecución es la capacidad de cambiar el comportamiento de objetos en tiempo de ejecución a través de composición y delegación en lugar de estar bloqueado en decisiones de tiempo de compilación mediante herencia.

Usado en: Patrón Strategy

Ejemplo: Usar métodos setter para cambiar el comportamiento de vuelo de un pato de FlyWithWings a FlyRocketPowered mientras el programa está ejecutándose.","cross-cutting runtime-flexibility design-patterns strategy-pattern","Cross-Cutting","101"
"What is delegation in object-oriented design?","Delegation is when an object passes responsibility for a task to another object instead of implementing the behavior directly.

Used in: Strategy Pattern

In the Strategy Pattern, the context delegates to the strategy object. For example, a Duck object delegates its flying behavior to a FlyBehavior object by calling flyBehavior.fly().","¿Qué es la delegación en el diseño orientado a objetos?","La delegación es cuando un objeto pasa la responsabilidad de una tarea a otro objeto en lugar de implementar el comportamiento directamente.

Usado en: Patrón Strategy

En el Patrón Strategy, el contexto delega al objeto de estrategia. Por ejemplo, un objeto Duck delega su comportamiento de vuelo a un objeto FlyBehavior llamando a flyBehavior.fly().","cross-cutting delegation design-principles strategy-pattern","Cross-Cutting","106"
"In the Strategy Pattern, how do you change behavior at runtime?
public void setFlyBehavior(FlyBehavior fb) {
  flyBehavior = fb;
}

model.setFlyBehavior(new FlyRocketPowered());","Pattern: Strategy Pattern

Key elements: Provide setter methods in the context class that accept strategy interface types. This allows you to dynamically change the behavior by passing in different concrete strategy implementations at runtime, giving you flexibility that inheritance cannot provide.","En el Patrón Strategy, ¿cómo cambias el comportamiento en tiempo de ejecución?
public void setFlyBehavior(FlyBehavior fb) {
  flyBehavior = fb;
}

model.setFlyBehavior(new FlyRocketPowered());","Patrón: Patrón Strategy

Elementos clave: Proporciona métodos setter en la clase de contexto que aceptan tipos de interfaz de estrategia. Esto te permite cambiar dinámicamente el comportamiento pasando diferentes implementaciones de estrategia concretas en tiempo de ejecución, dándote flexibilidad que la herencia no puede proporcionar.","strategy-pattern behavioral code-example implementation java","Behavioral","20"
